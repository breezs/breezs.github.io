{"meta":{"title":"冰山一树Sankey","subtitle":"Zsの知识树","description":"向下以触冰山，向上以触云层，而中以桑基为流，所见即所得！","author":"Sankey","url":"https://bingshanyishu.github.io","root":"/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2022-03-03T12:26:17.034Z","comments":true,"path":"404.html","permalink":"https://bingshanyishu.github.io/404.html","excerpt":"","text":""},{"title":"","date":"2022-03-03T12:48:22.221Z","updated":"2022-02-05T07:49:54.827Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"https://bingshanyishu.github.io/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"list","date":"2019-08-10T08:41:10.000Z","updated":"2022-02-05T07:49:54.737Z","comments":true,"path":"List/index.html","permalink":"https://bingshanyishu.github.io/List/index.html","excerpt":"","text":""},{"title":"","date":"2022-02-05T07:49:54.830Z","updated":"2022-02-05T07:49:54.830Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"https://bingshanyishu.github.io/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2022-02-05T07:49:54.827Z","comments":true,"path":"about/index.html","permalink":"https://bingshanyishu.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2022-02-05T07:49:54.828Z","comments":true,"path":"categories/index.html","permalink":"https://bingshanyishu.github.io/categories/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2022-02-05T07:49:54.827Z","comments":true,"path":"archives/index.html","permalink":"https://bingshanyishu.github.io/archives/index.html","excerpt":"","text":""},{"title":"pdf","date":"2022-03-03T08:40:27.000Z","updated":"2022-03-04T13:57:14.697Z","comments":true,"path":"pdf/index.html","permalink":"https://bingshanyishu.github.io/pdf/index.html","excerpt":"","text":""},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2022-02-05T07:49:54.828Z","comments":true,"path":"census/index.html","permalink":"https://bingshanyishu.github.io/census/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2022-02-05T07:49:54.829Z","comments":true,"path":"friends/index.html","permalink":"https://bingshanyishu.github.io/friends/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2022-02-05T07:49:54.829Z","comments":true,"path":"contact/index.html","permalink":"https://bingshanyishu.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 Zsの友链信息 博客名称: 冰山一树Sankey 博客网址: https://bingshanyishu.github.io 博客介绍: 向下以触冰山，向上以触云层，而中以桑基为流，所见即所得！"},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2022-02-05T07:49:54.833Z","comments":true,"path":"resource/index.html","permalink":"https://bingshanyishu.github.io/resource/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2022-02-05T07:49:54.833Z","comments":true,"path":"tags/index.html","permalink":"https://bingshanyishu.github.io/tags/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2022-02-05T07:49:54.738Z","comments":true,"path":"List/movies/index.html","permalink":"https://bingshanyishu.github.io/List/movies/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-03-11T07:59:17.589Z","updated":"2022-02-05T07:49:54.726Z","comments":true,"path":"List/galleries/index.html","permalink":"https://bingshanyishu.github.io/List/galleries/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2022-02-05T07:49:54.738Z","comments":true,"path":"List/music/index.html","permalink":"https://bingshanyishu.github.io/List/music/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2022-02-05T07:49:54.727Z","updated":"2022-02-05T07:49:54.727Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"https://bingshanyishu.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2022-02-05T07:49:54.739Z","comments":true,"path":"List/tools/index.html","permalink":"https://bingshanyishu.github.io/List/tools/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2022-02-05T07:49:54.727Z","updated":"2022-02-05T07:49:54.727Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"https://bingshanyishu.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2022-02-05T07:49:54.726Z","updated":"2022-02-05T07:49:54.726Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"https://bingshanyishu.github.io/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2022-02-05T07:49:54.726Z","updated":"2022-02-05T07:49:54.726Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"https://bingshanyishu.github.io/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2022-02-05T07:49:54.728Z","updated":"2022-02-05T07:49:54.728Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"https://bingshanyishu.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2022-02-05T07:49:54.734Z","updated":"2022-02-05T07:49:54.734Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"https://bingshanyishu.github.io/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2022-02-05T07:49:54.735Z","updated":"2022-02-05T07:49:54.735Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"https://bingshanyishu.github.io/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2022-02-05T07:49:54.734Z","updated":"2022-02-05T07:49:54.734Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"https://bingshanyishu.github.io/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2022-02-05T07:49:54.735Z","updated":"2022-02-05T07:49:54.735Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"https://bingshanyishu.github.io/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2022-02-05T07:49:54.736Z","updated":"2022-02-05T07:49:54.736Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"https://bingshanyishu.github.io/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2022-02-05T07:49:54.736Z","updated":"2022-02-05T07:49:54.736Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"https://bingshanyishu.github.io/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2022-02-05T07:49:54.737Z","updated":"2022-02-05T07:49:54.737Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"https://bingshanyishu.github.io/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"书籍","date":"2022-01-29T03:34:30.000Z","updated":"2022-02-12T07:40:27.195Z","comments":true,"path":"List/books/index.html","permalink":"https://bingshanyishu.github.io/List/books/index.html","excerpt":"","text":"免费的编程中文书籍索引 免费的编程中文书籍索引，欢迎投稿。 国外程序员在 stackoverflow 推荐的程序员必读书籍，中文版。 stackoverflow 上的程序员应该阅读的非编程类书籍有哪些？ 中文版 github 上的一个流行的编程书籍索引 中文版 如果这个仓库对你有帮助，欢迎 star。如果这个仓库帮你提升了技能找到了工作，可以请我喝杯咖啡： 参与交流欢迎大家将珍藏已久的经典免费书籍共享出来，您可以： 使用 Pull Request 提交 如果你发现了不能访问的链接，也可以提 PR，在无法访问链接的后面增加 :worried:。 贡献者名单: https://github.com/justjavac/free-programming-books-zh_CN/graphs/contributors 目录 语言无关类 操作系统 智能系统 分布式系统 编译原理 函数式概念 计算机图形学 WEB服务器 版本控制 编辑器 NoSQL PostgreSQL MySQL 管理和监控 项目相关 设计模式 Web 大数据 编程艺术 其它 语言相关类 Android APP AWK C/C++ C# Clojure CSS/HTML Dart Elixir Erlang Fortran Go Groovy Haskell iOS Java JavaScript Kotlin LaTeX LISP Lua OCaml Perl PHP Prolog Python R Ruby Rust Scala Shell Swift 读书笔记及其它 测试相关 置顶 [笔记]前端工程师的入门与进阶 💯 [全文]如何正确的学习 Node.js 💯 操作系统 开源世界旅行手册 鸟哥的Linux私房菜 The Linux Command Line (中英文版) Linux 设备驱动 (第三版) 深入分析Linux内核源码 😟 UNIX TOOLBOX Docker中文指南 Docker —— 从入门到实践 Docker入门实战 Docker Cheat Sheet FreeRADIUS新手入门 😟 Mac 开发配置手册 FreeBSD 使用手册 Linux 命令行(中文版) Linux 构建指南 Linux工具快速教程 Linux Documentation (中文版) 嵌入式 Linux 知识库 (eLinux.org 中文版) 理解Linux进程 命令行的艺术 SystemTap新手指南 操作系统思考 返回目录 智能系统 一步步搭建物联网系统 返回目录 分布式系统 走向分布式 返回目录 编译原理 《计算机程序的结构和解释》公开课 翻译项目 返回目录 函数式概念 傻瓜函数编程 返回目录 计算机图形学 OpenGL 教程 WebGL自学网 😟 《Real-Time Rendering 3rd》提炼总结 返回目录 WEB服务器 Nginx开发从入门到精通 (淘宝团队出品) Nginx教程从入门到精通(PDF版本，运维生存时间出品) OpenResty最佳实践 Apache 中文手册 返回目录 版本控制 Git教程 （本文由 廖雪峰 创作，如果觉得本教程对您有帮助，可以去 iTunes 购买） git - 简易指南 猴子都能懂的GIT入门 Git 参考手册 Pro Git Pro Git 中文版 (整理在gitbook上) Git Magic GotGitHub Git权威指南 Git Community Book 中文版 Mercurial 使用教程 HgInit (中文版) 沉浸式学 Git Git-Cheat-Sheet （感谢 @flyhigher139 翻译了中文版） GitHub秘籍 GitHub帮助文档 git-flow 备忘清单 svn 手册 GitHub漫游指南 返回目录 编辑器 exvim–vim 改良成IDE项目 笨方法学Vimscript 中译本 😟 Vim中文文档 所需即所获：像 IDE 一样使用 vim vim 实操教程 Atom飞行手册中文版 Markdown·简单的世界 一年成为 Emacs 高手 Emacs 生存指南 Atom官方手册 返回目录 NoSQL NoSQL数据库笔谈 Redis 设计与实现 Redis 命令参考 带有详细注释的 Redis 3.0 代码 带有详细注释的 Redis 2.6 代码 The Little MongoDB Book The Little Redis Book Neo4j 简体中文手册 v1.8 Neo4j .rb 中文資源 Disque 使用教程 Apache Spark 设计与实现 返回目录 PostgreSQL PostgreSQL 8.2.3 中文文档 PostgreSQL 9.3.1 中文文档 PostgreSQL 9.5.3 中文文档 返回目录 MySQL MySQL索引背后的数据结构及算法原理 21分钟MySQL入门教程 返回目录 管理和监控 ELKstack 中文指南 Mastering Elasticsearch(中文版) ElasticSearch 权威指南 Elasticsearch 权威指南（中文版） Logstash 最佳实践 Puppet 2.7 Cookbook 中文版 返回目录 项目相关 持续集成（第二版） (译言网) 让开发自动化系列专栏 追求代码质量 selenium 中文文档 Selenium Webdriver 简易教程 Joel谈软件 約耳談軟體(Joel on Software) Gradle 2 用户指南 Gradle 中文使用文档 编码规范 开源软件架构 GNU make 指南 GNU make 中文手册 The Twelve-Factor App 返回目录 设计模式 图说设计模式 史上最全设计模式导学目录 design pattern 包教不包会 设计模式 Java 版 返回目录 Web 关于浏览器和网络的 20 项须知 浏览器开发工具的秘密 Chrome 开发者工具中文手册 Chrome扩展开发文档 Grunt中文文档 gulp中文文档 Gulp 入门指南 移动Web前端知识库 正则表达式30分钟入门教程 前端开发体系建设日记 移动前端开发收藏夹 JSON风格指南 HTTP 接口设计指北 前端资源分享（一） 前端资源分享（二） 前端代码规范 及 最佳实践 前端开发者手册 前端工程师手册 w3school教程整理 Wireshark用户手册 一站式学习Wireshark HTTP 下午茶 HTTP/2.0 中文翻译 RFC 7540 - HTTP/2 中文翻译版 http2讲解 3 Web Designs in 3 Weeks 站点可靠性工程 Web安全学习笔记 Serverless 架构应用开发指南 返回目录 大数据 大数据/数据挖掘/推荐系统/机器学习相关资源 面向程序员的数据挖掘指南 大型集群上的快速和通用数据处理架构 数据挖掘中经典的算法实现和详细的注释 Spark 编程指南简体中文版 返回目录 编程艺术 程序员编程艺术 每个程序员都应该了解的内存知识(译)【第一部分】 取悦的工序：如何理解游戏 (豆瓣阅读，免费书籍) 返回目录 其它 OpenWrt智能、自动、透明翻墙路由器教程 SAN 管理入门系列 Sketch 中文手册 深入理解并行编程 程序员的自我修养 Growth: 全栈增长工程师指南 系统重构与迁移指南 返回目录 Android Android Design(中文版) Google Material Design 正體中文版 (译本一 译本二) Material Design 中文版 Google Android官方培训课程中文版 Android学习之路 Android开发技术前线(android-tech-frontier) Point-of-Android Android 一些重要知识点解析整理 Android6.0新特性详解 返回目录 APP Apache Cordova 开发指南 返回目录 AWK awk程序设计语言 awk中文指南 awk实战指南 返回目录 C/C++ C/C++ 中文参考手册 (欢迎大家参与在线翻译和校对) C 语言编程透视 C++ 并发编程指南 Linux C编程一站式学习 (宋劲杉, 北京亚嵌教育研究中心) CGDB中文手册 100个gdb小技巧 100个gcc小技巧 ZMQ 指南 How to Think Like a Computer Scientist (中英文版) 跟我一起写 Makefile GNU make中文手册 (需科学上网) (PDF) GNU make 指南 Google C++ 风格指南 C/C++ Primer (by @andycai) 简单易懂的C魔法 C++ FAQ LITE(中文版) C++ Primer 5th Answers C++ 并发编程(基于C++11) QT 教程 DevBean的《Qt学习之路2》(Qt5) 中文版《QmlBook》 C++ Template 进阶指南 libuv中文教程 Boost 库中文教程 笨办法学C 高速上手 C++11/14/17 返回目录 C# Microsoft Docs C# 官方文档 ASP.NET MVC 5 入门指南 超全面的 .NET GDI+ 图形图像编程教程 .NET控件开发基础 .NET开发要点精讲（初稿） 返回目录 Clojure Clojure入门教程 返回目录 CSS/HTML 学习CSS布局 通用 CSS 笔记、建议与指导 CSS参考手册 Emmet 文档 前端代码规范 (腾讯 AlloyTeam 团队) HTML和CSS编码规范 Sass Guidelines 中文 CSS3 Tutorial 《CSS3 教程》 MDN HTML 中文文档 MDN CSS 中文文档 返回目录 Dart Dart 语言导览 返回目录 Elixir Elixir编程入门 返回目录 Erlang 21天学通Erlang 返回目录 Fortran Fortran77和90/95编程入门 返回目录 Go Go编程基础 Go入门指南 学习Go语言 Go Web 编程 (此书已经出版，希望开发者们去购买，支持作者的创作) Go实战开发 (当我收录此项目时，作者已经写完第三章，如果读完前面章节觉得有帮助，可以给作者捐赠，以鼓励作者的继续创作) Network programming with Go 中文翻译版本 Effective Go Go 语言标准库 Golang标准库文档 Revel 框架手册 Java程序员的Golang入门指南 Go命令教程 Go语言博客实践 Go 官方文档翻译 深入解析Go Go语言圣经(中文版) (GitBook) golang runtime源码分析 Go语言实战: 编写可维护Go语言代码建议 Golang 系列教程(译) Go RPC 开发指南GitBook Go语言高级编程 Go2编程指南 Go语言设计模式 Go语言四十二章经 返回目录 Groovy 实战 Groovy 系列 返回目录 Haskell Real World Haskell 中文版 Haskell趣学指南 返回目录 iOS iOS开发60分钟入门 iOS7人机界面指南 Google Objective-C Style Guide 中文版 iPhone 6 屏幕揭秘 Apple Watch开发初探 马上着手开发 iOS 应用程序 网易斯坦福大学公开课：iOS 7应用开发字幕文件 返回目录 Java Apache Shiro 用户指南 Jersey 2.x 用户指南 Spring Framework 4.x参考文档 Spring Boot参考指南 (翻译中) MyBatis中文文档 MyBatis Generator 中文文档 用jersey构建REST服务 Activiti 5.x 用户指南 Google Java编程风格指南 Netty 4.x 用户指南 Netty 实战(精髓) REST 实战 Java 编码规范 Apache MINA 2 用户指南 H2 Database 教程 Java Servlet 3.1 规范 JSSE 参考指南 Java开源实现及最佳实践 Java 编程要点 Think Java Java 8 简明教程 On Java 8 中文版 (翻译中) Effective Java 第3版中文版 返回目录 JavaScript 现代 Javascript 教程 Google JavaScript 代码风格指南 Google JSON 风格指南 Airbnb JavaScript 规范 JavaScript 标准参考教程（alpha） Javascript编程指南 (源码) javascript 的 12 个怪癖 JavaScript 秘密花园 JavaScript核心概念及实践 (PDF) (此书已由人民邮电出版社出版发行，但作者依然免费提供PDF版本，希望开发者们去购买，支持作者) 《JavaScript 模式》 “JavaScript patterns”中译本 JavaScript语言精粹 命名函数表达式探秘 (注:原文由为之漫笔翻译，原始地址无法打开，所以此处地址为我博客上的备份) 学用 JavaScript 设计模式 (开源中国) 深入理解JavaScript系列 ECMAScript 5.1 中文版 ECMAScript 6 入门 (作者：阮一峰) JavaScript Promise迷你书 You-Dont-Know-JS (深入JavaScript语言核心机制的系列图书) JavaScript 教程 廖雪峰 MDN JavaScript 中文文档 jQuery jQuery 解构 简单易懂的JQuery魔法 How to write jQuery plugin You Don’t Need jQuery 如何实现一个类jQuery？ Node.js Node入门 七天学会NodeJS Nodejs Wiki Book (繁体中文) express.js 中文文档 koa 中文文档 一起学koa 使用 Express + MongoDB 搭建多人博客 Express框架 Node.js 包教不包会 Learn You The Node.js For Much Win! (中文版) Node debug 三法三例 nodejs中文文档 orm2 中文文档 一起学 Node.js underscore.js Underscore.js中文文档 backbone.js backbone.js中文文档 backbone.js入门教程 (PDF) Backbone.js入门教程第二版 Developing Backbone.js Applications(中文版) AngularJS AngularJS最佳实践和风格指南 AngularJS中译本 AngularJS入门教程 构建自己的AngularJS 在Windows环境下用Yeoman构建AngularJS项目 Zepto.js Zepto.js 中文文档 Sea.js Hello Sea.js React.js React 学习之道 React.js 小书 React.js 中文文档 React webpack-cookbook React 入门教程 React 入门教程 (作者：hulufei, 与上行不同作者) React Native 中文文档(含最新Android内容) Learn React &amp; Webpack by building the Hacker News front page impress.js impress.js的中文教程 CoffeeScript CoffeeScript Cookbook The Little Book on CoffeeScript中文版 CoffeeScript 编码风格指南 TypeScipt TypeScript Handbook ExtJS Ext4.1.0 中文文档 Meteor Discover Meteor Meteor 中文文档 Angular-Meteor 中文教程 VueJS 逐行剖析 Vue.js 源码 Chrome扩展及应用开发 Kotlin Kotlin 官方参考文档 中文版 Kotlin 中文文档 GitHub Kotlin 参考文档 《Kotlin for android developers》中文版 返回目录 LaTeX 一份其实很短的 LaTeX 入门文档 一份不太简短的 LATEX 2ε 介绍 （PDF版） 返回目录 LISP Common Lisp ANSI Common Lisp 中文翻譯版 On Lisp 中文翻译版本 Scheme Yet Another Scheme Tutorial Scheme入门教程 Scheme语言简明教程 Racket Racket book 返回目录 Lua Lua编程入门 Lua 5.1 参考手册 中文翻译 Lua 5.3 参考手册 中文翻译 Lua源码欣赏 返回目录 OCaml Real World OCaml 返回目录 Perl Modern Perl 中文版 Perl 程序员应该知道的事 返回目录 PHP PHP 官方手册 PHP调试技术手册(PDF) PHP之道：php-the-right-way (@wulijun版 PHPHub版) PHP 最佳实践 PHP 开发者实践 深入理解PHP内核 PHP扩展开发及内核应用 Laravel5.1 中文文档 Laravel 5.1 LTS 速查表 Symfony2 Cookbook 中文版(版本 2.7.0 LTS) Symfony2中文文档 (未译完) YiiBook几本Yii框架的在线教程 深入理解 Yii 2.0 Yii 框架中文官网 简单易懂的PHP魔法 swoole文档及入门教程 Composer 中文网 Slim 中文文档 Lumen 中文文档 PHPUnit 中文文档 PHP-LeetCode 返回目录 Prolog 笨办法学Prolog 返回目录 Python 廖雪峰 Python 2.7 中文教程 廖雪峰 Python 3 中文教程 简明Python教程 简明 Python 教程(Python 3) 零基础学 Python 第一版 零基础学 Python 第二版 可爱的 Python Python 2.7 官方教程中文版 Python 3.3 官方教程中文版 Python Cookbook 中文版 Python3 Cookbook 中文版 深入 Python 深入 Python 3 PEP8 Python代码风格规范 Google Python 风格指南 中文版 Python入门教程 (PDF) 笨办法学 Python (PDF EPUB) Python自然语言处理中文版 （感谢陈涛同学的翻译，也谢谢 @shwley 联系了作者） Python 绘图库 matplotlib 官方指南中文翻译 Scrapy 0.25 文档 ThinkPython ThinkPython 2ed Python快速教程 Python 正则表达式操作指南 python初级教程：入门详解 Twisted 与异步编程入门 TextGrocery 中文 API ( 基于svm算法的一个短文本分类 Python 库 ) Requests: HTTP for Humans Pillow 中文文档 PyMOTW 中文版 Python 官方文档中文版 Fabric 中文文档 Beautiful Soup 4.2.0 中文文档 Python 中的 Socket 编程 用Python做科学计算 Sphinx 中文文档 精通 Python 设计模式 python 安全编程教程 程序设计思想与方法 知乎周刊·编程小白学Python Scipy 讲义 Python 学习笔记 基础篇 Python 学习笔记 模块篇 Python 标准库 中文版 Python进阶 Python 核心编程 第二版 CPyUG译 Python最佳实践指南 Python 精要教程 Python 量化交易教程 Django Django 1.5 文档中文版 正在翻译中 Django 2.0 文档中文版 Django 最佳实践 Django 2.1 搭建个人博客教程 ( 编写中 ) Django搭建简易博客教程 The Django Book 中文版 Django 设计模式与最佳实践 Django 网站开发 Cookbook Django Girls 學習指南 Flask Flask 文档中文版 Jinja2 文档中文版 Werkzeug 文档中文版 Flask之旅 Flask 扩展文档汇总 Flask 大型教程 SQLAlchemy 中文文档 Flask 入门教程 web.py web.py 0.3 新手指南 Web.py Cookbook 简体中文版 Tornado Introduction to Tornado 中文翻译 Tornado源码解析 Tornado 4.3 文档中文版 返回目录 R R语言忍者秘笈 返回目录 Ruby Ruby 风格指南 Rails 风格指南 笨方法學 Ruby Ruby on Rails 指南 Ruby on Rails 實戰聖經 Ruby on Rails Tutorial 原书第 3 版 (本书网页版免费提供，电子版以 PDF、EPub 和 Mobi 格式提供购买，仅售 9.9 美元) Rails 实践 Rails 5 开发进阶(Beta) Rails 102 编写Ruby的C拓展 Ruby 源码解读 Ruby中的元编程 返回目录 Rust Rust编程语言 中文翻译 Rust Primer 返回目录 Scala Scala课堂 (Twitter的Scala中文教程) Effective Scala(Twitter的Scala最佳实践的中文翻译) Scala指南 返回目录 Shell Shell脚本编程30分钟入门 Bash脚本15分钟进阶教程 Linux工具快速教程 shell十三问 Shell编程范例 Linux命令搜索引擎 返回目录 Swift The Swift Programming Language 中文版 Swift 语言指南 Stanford 公开课，Developing iOS 8 Apps with Swift 字幕翻译文件 C4iOS - COSMOS 返回目录 读书笔记及其它 编译原理（紫龙书）中文第2版习题答案 把《编程珠玑》读薄 Effective C++读书笔记 Golang 学习笔记、Python 学习笔记、C 学习笔记 (PDF) Jsoup 学习笔记 学习笔记: Vim、Python、memcached 图灵开放书翻译计划–C++、Python、Java等 蒂姆·奥莱利随笔 （由译言网翻译，电子版免费） SICP 解题集 精彩博客集合 中文文案排版指北 Standard C 语言标准函数库速查 (Cheat Sheet) Git Cheatsheet Chs GitBook简明教程 制造开源软件 提问的智慧 Markdown 入门参考 AsciiDoc简明指南 背包问题九讲 老齐的技术资料 前端技能汇总 借助开源项目，学习软件开发 前端工作面试问题 leetcode/lintcode题解/算法学习笔记 前端开发笔记本 LeetCode题解 《不可替代的团队领袖培养计划》 返回目录 测试相关"}],"posts":[{"title":"如何在Ajax中使用FormData对象传递数据，$.ajax方法怎么使用","slug":"如何在Ajax中使用FormData对象传递数据，-ajax方法怎么使用","date":"2022-03-19T14:54:35.000Z","updated":"2022-03-19T14:55:48.964Z","comments":true,"path":"posts/202203192254.html","link":"","permalink":"https://bingshanyishu.github.io/posts/202203192254.html","excerpt":"","text":"如何在Ajax中使用FormData对象传递数据，$.ajax方法怎么使用博客园主页：博客园主页-冰山一树SankeyCSDN主页：CSDN主页-冰山一树Sankey Ajax基础概述以及封装请查看 Ajax概述，封装以及联合模板引擎进行数据交互_冰山一树Sankey的博客-CSDN博客 一. FormData对象1.1 使用作用： 模拟HTML表单，相当于将HTML表单映射成表单对象，自动将表单对象中的数据拼接成请求参数的格式。 异步上传二进制文件 准备 HTML 表单 &lt;form id=\"form\"&gt; &lt;input type=\"text\" name=\"username\" /&gt; &lt;input type=\"password\" name=\"password\" /&gt; &lt;input type=\"button\"/&gt; &lt;/form&gt; 将 HTML 表单转化为 formData 对象 var form = document.getElementById('form'); var formData = new FormData(form); 提交表单对象 xhr.send(formData); 注意： Formdata 对象不能用于 get 请求，因为对象需要被传递到 send 方法中，而 get 请求方式的请求参数只能放在请求地址的后面。 服务器端 bodyParser 模块不能解析 formData 对象表单数据，我们需要使用 formidable 模块进行解析。 具体可看下面代码 服务端app.js中代码 // 引入express框架 const express = require('express'); // 路径处理模块 const path = require('path'); const formidable = require('formidable'); // 创建web服务器 const app = express(); // 静态资源访问服务功能 app.use(express.static(path.join(__dirname, 'public'))); app.post('/formData', (req, res) =&gt; { // 创建formidable表单解析对象 const form = new formidable.IncomingForm(); // 解析客户端传递过来的FormData对象 form.parse(req, (err, fields, files) =&gt; { res.send(fields); }); }); // 监听端口 app.listen(3000); // 控制台提示输出 console.log('服务器启动成功'); 浏览器端代码 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 创建普通的html表单 --&gt; &lt;form id=\"form\"&gt; &lt;input type=\"text\" name=\"username\"&gt; &lt;input type=\"password\" name=\"password\"&gt; &lt;input type=\"button\" id=\"btn\" value=\"提交\"&gt; &lt;/form&gt; &lt;script type=\"text/javascript\"&gt; // 获取按钮 var btn = document.getElementById('btn'); // 获取表单 var form = document.getElementById('form'); // 为按钮添加点击事件 btn.onclick = function () { // 将普通的html表单转换为表单对象 var formData = new FormData(form); // 创建ajax对象 var xhr = new XMLHttpRequest(); // 对ajax对象进行配置 xhr.open('post', 'http://localhost:3000/formData'); // 发送ajax请求 xhr.send(formData); // 监听xhr对象下面的onload事件 xhr.onload = function () { // 对象http状态码进行判断 if (xhr.status == 200) { console.log(xhr.responseText); } } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 1.2 实例方法 获取表单对象中属性的值 formData.get('key'); 设置表单对象中属性的值 formData.set('key', 'value'); 删除表单对象中属性的值 formData.delete('key'); 向表单对象中追加属性值 formData.append('key', 'value'); 注意：set 方法与 append 方法的区别是，在属性名已存在的情况下，set 会覆盖已有键名的值，append会保留两个值。 1.3 实现二级制文件上传在public文件夹下面新建FormData对象实现二进制文件上传.html，然后添加 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"/assets/bootstrap/dist/css/bootstrap.min.css\"&gt; &lt;style type=\"text/css\"&gt; .container { padding-top: 60px; } .padding { padding: 5px 0 20px 0; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;请选择文件&lt;/label&gt; &lt;input type=\"file\" id=\"file\"&gt; &lt;div class=\"padding\" id=\"box\"&gt; &lt;!--&lt;img src=\"\" class=\"img-rounded img-responsive\"&gt;--&gt; &lt;/div&gt; &lt;div class=\"progress\"&gt; &lt;div class=\"progress-bar\" style=\"width: 0%;\" id=\"bar\"&gt;0%&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; // 获取文件选择控件 var file = document.getElementById('file'); // 获取进度条元素 var bar = document.getElementById('bar'); // 获取图片容器 var box = document.getElementById('box'); // 为文件选择控件添加onchanges事件 // 在用户选择文件时触发 file.onchange = function () { // 创建空的formData表单对象 var formData = new FormData(); // 将用户选择的文件追加到formData表单对象中 formData.append('attrName', this.files[0]); // 创建ajax对象 var xhr = new XMLHttpRequest(); // 对ajax对象进行配置 xhr.open('post', 'http://localhost:3000/upload'); // 在文件上传的过程中持续触发 xhr.upload.onprogress = function (ev) { // ev.loaded 文件已经上传了多少 // ev.total 上传文件的总大小 var result = (ev.loaded / ev.total) * 100 + '%'; // 设置进度条的宽度 bar.style.width = result; // 将百分比显示在进度条中 bar.innerHTML = result; } // 发送ajax请求 xhr.send(formData); // 监听服务器端响应给客户端的数据 xhr.onload = function () { // 如果服务器端返回的http状态码为200 // 说明请求是成功的 if (xhr.status == 200) { // 将服务器端返回的数据显示在控制台中 var result = JSON.parse(xhr.responseText); // 动态创建img标签 var img = document.createElement('img'); // 给图片标签设置src属性 img.src = result.path; // 当图片加载完成以后 img.onload = function () { // 将图片显示在页面中 box.appendChild(img); } } } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 服务端app.js代码 // 引入express框架 const express = require('express'); // 路径处理模块 const path = require('path'); const formidable = require('formidable'); // 创建web服务器 const app = express(); // 静态资源访问服务功能 app.use(express.static(path.join(__dirname, 'public'))); // 实现文件上传的路由 app.post('/upload', (req, res) =&gt; { // 创建formidable表单解析对象 const form = new formidable.IncomingForm(); // 设置客户端上传文件的存储路径 form.uploadDir = path.join(__dirname, 'public', 'uploads'); // 保留上传文件的后缀名字 form.keepExtensions = true; // 解析客户端传递过来的FormData对象 form.parse(req, (err, fields, files) =&gt; { // 将客户端传递过来的文件地址响应到客户端 res.send({ path: files.attrName.path.split('public')[1] }); }); }); // 监听端口 app.listen(3000); // 控制台提示输出 console.log('服务器启动成功'); 二. Ajax请求限制注意：以下代码均在下面s1与s2文件结构中，public下的文件为html页面，app.js为服务器端代码 2.1 同源政策如果两个页面拥有相同的协议、域名和端口，那么这两个页面就属于同一个源，其中只要有一个不相同，就是不同源。 http://www.example.com/dir/page.html http://www.example.com/dir2/other.html：同源 http://example.com/dir/other.html：不同源（域名不同） http://v2.www.example.com/dir/other.html：不同源（域名不同） http://www.example.com:81/dir/other.html：不同源（端口不同） https://www.example.com/dir/page.html：不同源（协议不同） 同源政策是为了保证用户信息的安全，防止恶意的网站窃取数据。最初的同源政策是指 A 网站在客户端设置的 Cookie，B网站是不能访问的。随着互联网的发展，同源政策也越来越严格，在不同源的情况下，其中有一项规定就是无法向非同源地址发送Ajax 请求，如果请求，浏览器就会报错。 现在有一个A网站、有一个B网站，A网站中的 HTML 文件只能向A网站服务器中发送 Ajax 请求，B网站中的 HTML 文件只能向 B 网站中发送 Ajax 请求，但是 A 网站是不能向 B 网站发送 Ajax请求的，同理，B 网站也不能向 A 网站发送 Ajax请求。那么如何解决这个问题呢？ 2.2 JSONP（方法一）jsonp 是 json with padding 的缩写，它不属于 Ajax 请求，但它可以模拟 Ajax 请求。 将不同源的服务器端请求地址写在 script 标签的 src 属性中 &lt;script src=\"www.example.com\"&gt;&lt;/script&gt; 服务器端响应数据必须是一个函数的调用，真正要发送给客户端的数据需要作为函数调用的参数。 const data = 'fn({name: \"张三\", age: \"20\"})'; res.send(data); 在客户端全局作用域下定义函数 fn function fn (data) { } 在 fn 函数内部对服务器端返回的数据进行处理 function fn (data) { console.log(data); } 这里使用nodejs创建两个服务器，分别为s1和s2，把两个服务器都打开 s1的app.js // 引入express框架 const express = require('express'); // 路径处理模块 const path = require('path'); // 向其他服务器端请求数据的模块 const request = require('request'); // 创建web服务器 const app = express(); // 静态资源访问服务功能 app.use(express.static(path.join(__dirname, 'public'))); app.get('/server', (req, res) =&gt; { request('http://localhost:3001/cross', (err, response, body) =&gt; { res.send(body); }) }); // 监听端口 app.listen(3000); // 控制台提示输出 console.log('服务器启动成功'); s2的app.js // 引入express框架 const express = require('express'); // 路径处理模块 const path = require('path'); // 接收post请求参数 const formidable = require('formidable'); // 实现session功能 var session = require('express-session'); // 创建web服务器 const app = express(); // 接收post请求参数 // 实现session功能 app.use(session({ secret: 'keyboard cat', resave: false, saveUninitialized: false })); // 静态资源访问服务功能 app.use(express.static(path.join(__dirname, 'public'))); app.get('/better', (req, res) =&gt; { // 接收客户端传递过来的函数的名称 //const fnName = req.query.callback; // 将函数名称对应的函数调用代码返回给客户端 //const data = JSON.stringify({name: \"张三\"}); //const result = fnName + '('+ data +')'; // setTimeout(() =&gt; { // res.send(result); // }, 1000) res.jsonp({name: 'lisi', age: 20}); }); // 监听端口 app.listen(3001); // 控制台提示输出 console.log('服务器启动成功'); 在s1的public文件夹下面创建使用jsonp向非同源服务器端请求数据.html，添加以下代码 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=\"btn\"&gt;点我发送请求&lt;/button&gt; &lt;script&gt; function fn2 (data) { console.log('客户端的fn函数被调用了') console.log(data); } &lt;/script&gt; &lt;script type=\"text/javascript\"&gt; // 获取按钮 var btn = document.getElementById('btn'); // 为按钮添加点击事件 btn.onclick = function () { // 创建script标签 var script = document.createElement('script'); // 设置src属性 script.src = 'http://localhost:3001/better?callback=fn2'; // 将script标签追加到页面中 document.body.appendChild(script); // 为script标签添加onload事件 script.onload = function () { // 将body中的script标签删除掉 document.body.removeChild(script); } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 2.3 JSONP封装function jsonp (options) { // 动态创建script标签 var script = document.createElement('script'); // 拼接字符串的变量 var params = ''; for (var attr in options.data) { params += '&amp;' + attr + '=' + options.data[attr]; } // myJsonp0124741 var fnName = 'myJsonp' + Math.random().toString().replace('.', ''); // 它已经不是一个全局函数了 // 我们要想办法将它变成全局函数 window[fnName] = options.success; // 为script标签添加src属性 script.src = options.url + '?callback=' + fnName + params; // 将script标签追加到页面中 document.body.appendChild(script); // 为script标签添加onload事件 script.onload = function () { document.body.removeChild(script); } } 2.4 CORS 跨域资源共享（方法二）CORS：全称为 Cross-origin resource sharing，即跨域资源共享，它允许浏览器向跨域服务器发送 Ajax 请求，克服了 Ajax 只能同源使用的限制。 只需要在s2的app.js中设置CORS即可实现s1的服务器能发起请求，并得到响应 // 拦截所有请求 app.use((req, res, next) =&gt; { // 1.允许哪些客户端访问我 // * 代表允许所有的客户端访问我 // 注意：如果跨域请求中涉及到cookie信息传递，值不可以为*号 比如是具体的域名信息 res.header('Access-Control-Allow-Origin', 'http://localhost:3000') // 2.允许客户端使用哪些请求方法访问我 res.header('Access-Control-Allow-Methods', 'get,post') // 允许客户端发送跨域请求时携带cookie信息 res.header('Access-Control-Allow-Credentials', true); next(); }); 2.5 服务器端解决（方法三）同源政策是浏览器给予Ajax技术的限制，服务器端是不存在同源政策限制。服务端可通过request模块访问其他服务端 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=\"btn\"&gt;点我发送请求&lt;/button&gt; &lt;script src=\"/js/ajax.js\"&gt;&lt;/script&gt; &lt;script&gt; // 获取按钮 var btn = document.getElementById('btn'); // 为按钮添加点击事件 btn.onclick = function () { ajax({ type: 'get', url: 'http://localhost:3000/server', success: function (data) { console.log(data); } }) }; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 服务端s1的app.js // 引入express框架 const express = require('express'); // 路径处理模块 const path = require('path'); // 向其他服务器端请求数据的模块 const request = require('request'); // 创建web服务器 const app = express(); // 静态资源访问服务功能 app.use(express.static(path.join(__dirname, 'public'))); app.get('/server', (req, res) =&gt; { request('http://localhost:3001/cross', (err, response, body) =&gt; { res.send(body); }) }); // 监听端口 app.listen(3000); // 控制台提示输出 console.log('服务器启动成功'); 服务端s2的app.js // 引入express框架 const express = require('express'); // 路径处理模块 const path = require('path'); // 接收post请求参数 const formidable = require('formidable'); // 创建web服务器 const app = express(); // 接收post请求参数 // 静态资源访问服务功能 app.use(express.static(path.join(__dirname, 'public'))); app.get('/cross', (req, res) =&gt; { res.send('ok') }); // 监听端口 app.listen(3001); // 控制台提示输出 console.log('服务器启动成功'); 2.6 实现跨域登录功能在s1的public下新建实现跨域登录功能.html &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;实现跨域功能&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"/assets/bootstrap/dist/css/bootstrap.min.css\"&gt; &lt;style type=\"text/css\"&gt; .container { padding-top: 60px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"container\"&gt; &lt;form id=\"loginForm\"&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;用户名&lt;/label&gt; &lt;input type=\"text\" name=\"username\" class=\"form-control\" placeholder=\"请输入用户名\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;密码&lt;/label&gt; &lt;input type=\"password\" name=\"password\" class=\"form-control\" placeholder=\"请输入用密码\"&gt; &lt;/div&gt; &lt;input type=\"button\" class=\"btn btn-default\" value=\"登录\" id=\"loginBtn\"&gt; &lt;input type=\"button\" class=\"btn btn-default\" value=\"检测用户登录状态\" id=\"checkLogin\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; // 获取登录按钮 var loginBtn = document.getElementById('loginBtn'); // 获取检测登录状态按钮 var checkLogin = document.getElementById('checkLogin'); // 获取登录表单 var loginForm = document.getElementById('loginForm'); // 为登录按钮添加点击事件 loginBtn.onclick = function () { // 将html表单转换为formData表单对象 var formData = new FormData(loginForm); // 创建ajax对象 var xhr = new XMLHttpRequest(); // 对ajax对象进行配置 xhr.open('post', 'http://localhost:3001/login'); // 当发送跨域请求时，携带cookie信息 xhr.withCredentials = true; // 发送请求并传递请求参数 xhr.send(formData); // 监听服务器端给予的响应内容 xhr.onload = function () { console.log(xhr.responseText); } } // 当检测用户状态按钮被点击时 checkLogin.onclick = function () { // 创建ajax对象 var xhr = new XMLHttpRequest(); // 对ajax对象进行配置 xhr.open('get', 'http://localhost:3001/checkLogin'); // 当发送跨域请求时，携带cookie信息 xhr.withCredentials = true; // 发送请求并传递请求参数 xhr.send(); // 监听服务器端给予的响应内容 xhr.onload = function () { console.log(xhr.responseText); } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; s2服务端的的app.js // 引入express框架 const express = require('express'); // 路径处理模块 const path = require('path'); // 接收post请求参数 const formidable = require('formidable'); // 实现session功能 var session = require('express-session'); // 创建web服务器 const app = express(); // 接收post请求参数 // 实现session功能 app.use(session({ secret: 'keyboard cat', resave: false, saveUninitialized: false })); // 静态资源访问服务功能 app.use(express.static(path.join(__dirname, 'public'))); // 拦截所有请求 app.use((req, res, next) =&gt; { // 1.允许哪些客户端访问我 // * 代表允许所有的客户端访问我 // 注意：如果跨域请求中涉及到cookie信息传递，值不可以为*号 比如是具体的域名信息 res.header('Access-Control-Allow-Origin', 'http://localhost:3000') // 2.允许客户端使用哪些请求方法访问我 res.header('Access-Control-Allow-Methods', 'get,post') // 允许客户端发送跨域请求时携带cookie信息 res.header('Access-Control-Allow-Credentials', true); next(); }); app.post('/login', (req, res) =&gt; { // 创建表单解析对象 var form = formidable.IncomingForm(); // 解析表单 form.parse(req, (err, fields, file) =&gt; { // 接收客户端传递过来的用户名和密码 const { username, password } = fields; // 用户名密码比对 if (username == 'itheima' &amp;&amp; password == '123456') { // 设置session req.session.isLogin = true; res.send({message: '登录成功'}); } else { res.send({message: '登录失败, 用户名或密码错误'}); } }) }); app.get('/checkLogin', (req, res) =&gt; { // 判断用户是否处于登录状态 if (req.session.isLogin) { res.send({message: '处于登录状态'}) } else { res.send({message: '处于未登录状态'}) } }); // 监听端口 app.listen(3001); // 控制台提示输出 console.log('服务器启动成功'); 三. JQuery中的Ajax3.1 $.ajax()方法JQuery的$.ajax()方法完成了ajax的封装， $.ajax({ //请求方式 type: 'get', //请求地址 url: 'http://www.example.com', // 向服务器端发送的请求参数,如果是json data: { name: 'zhangsan', age: '20' }, contentType: 'application/json', ', // 向服务器端发送的请求参数,如果是key=value&amp;key=value //data: 'name=zhangsan&amp;age=100', //contentType: 'application/x-www-form-urlencoded', beforeSend: function () { return false }, // 请求成功以后函数被调用 success: function (response) { // response为服务器端返回的数据 // 方法内部会自动将json字符串转换为json对象 console.log(response); }, // 请求失败以后函数被调用 error: function (xhr) {} }); 注意：如果是json对象var params = {name: 'wangwu', age: 300}不能直接赋给data，必须通过JSON.stringify()方法转换为json字符串，如 var params = {name: 'wangwu', age: 300} $.ajax({ // 请求方式 type: 'post', // 请求地址 url: '/user', // 向服务器端发送的请求参数 data: JSON.stringify(params), // 指定参数的格式类型 contentType: 'application/json', // 请求成功以后函数被调用 success: function (response) { // response为服务器端返回的数据 // 方法内部会自动将json字符串转换为json对象 console.log(response); } }) 如果想要在发起请求前做点事情，可通过beforeSend设置，下面设置阻止发起请求。 // 在请求发送之前调用 beforeSend: function () { alert('请求不会被发送') // 请求不会被发送 return false; }, 3.2 serialize方法通过serialize方法可将表单中的数据自动拼接成字符串类型的参数进行传递 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;serialize方法说明&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form id=\"form\"&gt; &lt;input type=\"text\" name=\"username\"&gt; &lt;input type=\"password\" name=\"password\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; &lt;script src=\"/js/jquery.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $('#form').on('submit', function () { // 将表单内容拼接成字符串类型的参数 var params = $('#form').serialize(); console.log(params) return false; }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 但是这样显得不够灵活，不能对各个参数进行操作，为此我们可以自己封装一个函数，在返回一个json对象进行参数传递 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;serialize方法说明&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form id=\"form\"&gt; &lt;input type=\"text\" name=\"username\"&gt; &lt;input type=\"password\" name=\"password\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; &lt;script src=\"/js/jquery.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $('#form').on('submit', function () { let data=serializeObject($(this)); console.log(data); }); // 将表单中用户输入的内容转换为对象类型 function serializeObject (obj) { // 处理结果对象 var result = {}; // [{name: 'username', value: '用户输入的内容'}, {name: 'password', value: '123456'}] var params = obj.serializeArray(); // 循环数组 将数组转换为对象类型 $.each(params, function (index, value) { result[value.name] = value.value; }) // 将处理的结果返回到函数外部 return result; } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 3.3 发送jsonp请求使用$.ajax()可直接发送json请求，内部已经封装好了 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;$.ajax方法基本使用&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=\"btn\"&gt;发送请求&lt;/button&gt; &lt;script src=\"/js/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; function fn (response) { console.log(response) } $('#btn').on('click', function () { $.ajax({ url: '/jsonp', // 向服务器端传递函数名字的参数名称，不写默认是callback //jsonp: 'foo', // 向服务器端传递函数名字的参数名称,如果要使用其他函数可设置，不过不建议 jsonpCallback: 'fn', // 代表现在要发送的是jsonp请求 dataType: 'jsonp', success: function (response) { console.log(response) } }) }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 3.4 $.get(),$.post()方法相当于$.ajax()再进行简化了 $.get('http://www.example.com', {name: 'zhangsan', age: 30}, function (response) {}) $.post('http://www.example.com', {name: 'lisi', age: 22}, function (response) {}) 3.5 RESTful 风格的API当向服务端发送请求，为了规范而避免引起错误，定义了RESTful 风格的API，而在$.ajax中按这种风格进行了封装 GET： 获取数据 POST： 添加数据 PUT： 更新数据 DELETE： 删除数据 具体实现 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=\"/js/jquery.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; // 获取用户列表信息 $.ajax({ type: 'get', url: '/users', success: function (response) { console.log(response) } }) // 获取id为10的用户信息 $.ajax({ type: 'get', url: '/users/10', success: function (response) { console.log(response) } }) // 获取id为10的用户信息 $.ajax({ type: 'delete', url: '/users/10', success: function (response) { console.log(response) } }) // 获取id为10的用户信息 $.ajax({ type: 'put', url: '/users/10', success: function (response) { console.log(response) } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 四. XMLXML 的全称是 extensible markup language，代表可扩展标记语言，它的作用是传输和存储数据。在 &lt;students&gt; &lt;student&gt; &lt;sid&gt;001&lt;/sid&gt; &lt;name&gt;张三&lt;/name&gt; &lt;/student&gt; &lt;student&gt; &lt;sid&gt;002&lt;/sid&gt; &lt;name&gt;王二丫&lt;/name&gt; &lt;/student&gt; &lt;/students&gt; 在ajax中可通过XMLHttpRequest对象的responseXML属性得到服务端发送过来的xml数据 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=\"btn\"&gt;发送请求&lt;/button&gt; &lt;div id=\"container\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var btn = document.getElementById('btn'); var container = document.getElementById('container'); btn.onclick = function () { var xhr = new XMLHttpRequest(); xhr.open('get', '/xml'); xhr.send(); xhr.onload = function () { // xhr.responseXML 获取服务器端返回的xml数据 var xmlDocument = xhr.responseXML; var title = xmlDocument.getElementsByTagName('title')[0].innerHTML; container.innerHTML = title; } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 服务端 app.get('/xml', (req, res) =&gt; { res.header('content-type', 'text/xml'); res.send('&lt;message&gt;&lt;title&gt;消息标题&lt;/title&gt;&lt;content&gt;消息内容&lt;/content&gt;&lt;/message&gt;') });","categories":[{"name":"技能之树","slug":"技能之树","permalink":"https://bingshanyishu.github.io/categories/%E6%8A%80%E8%83%BD%E4%B9%8B%E6%A0%91/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://bingshanyishu.github.io/tags/Ajax/"}],"author":"Sankey"},{"title":"Ajax概述，封装以及联合模板引擎进行数据交互","slug":"Ajax概述，封装以及联合模板引擎进行数据交互","date":"2022-03-19T14:48:51.000Z","updated":"2022-03-19T14:56:26.595Z","comments":true,"path":"posts/202203192248.html","link":"","permalink":"https://bingshanyishu.github.io/posts/202203192248.html","excerpt":"","text":"Ajax概述，封装以及联合模板引擎进行数据交互博客园主页：博客园主页-冰山一树SankeyCSDN主页：CSDN主页-冰山一树Sankey 更多资料可参考Ajax 介绍篇丨慕课网教程 (imooc.com) 一. Ajax概述在网站中存在以下问题： 网速慢的情况下，页面加载时间长，用户只能等待 表单提交后，如果一项内容不合格，需要重新填写所有表单内容 页面跳转，重新加载页面，造成资源浪费，增加用户等待时间 于是Ajax诞生了，Ajax：标准读音 [ˈeɪˌdʒæks] ，中文音译：阿贾克斯 它是浏览器提供的一套方法，可以实现页面无刷新更新数据，提高用户浏览网站应用的体验。 二. Ajax运行环境及实现2.1 Ajax运行环境Ajax 相当于浏览器发送请求与接收响应的代理人，以实现在不影响用户浏览页面的情况下，局部更新页面数据，从而提高用户体验。在浏览器端与服务器端进行请求响应是不可以控制的，但使用Ajax后，开发人员人员可控制其过程。 那如何实现Ajax呢？ 创建 Ajax 对象 var xhr = new XMLHttpRequest(); 告诉 Ajax 请求地址以及请求方式 xhr.open('get', 'http://www.example.com'); 发送请求 xhr.send(); 获取服务器端给与客户端的响应数据 xhr.onload = function () { console.log(xhr.responseText); } 因为Ajax 技术需要运行在网站环境中才能生效，下面使用Node创建的服务器作为网站服务器。 手写在创建一个文件夹server，在其根目录下再创建public，使用npm安装express和body-parser，其package.jion文件如下 { \"name\": \"code\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" }, \"author\": \"\", \"license\": \"ISC\", \"dependencies\": { \"body-parser\": \"^1.18.3\", \"express\": \"^4.16.4\" } } 然后再在根目录下创建app.js文件，这里编写服务端代码 2.2 传递get请求参数在public中新建传递get请求参数.html文件 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; &lt;input type=\"text\" id=\"username\"&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=\"text\" id=\"age\"&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=\"button\" value=\"提交\" id=\"btn\"&gt; &lt;/p&gt; &lt;script type=\"text/javascript\"&gt; // 获取按钮元素 var btn = document.getElementById('btn'); // 获取姓名文本框 var username = document.getElementById('username'); // 获取年龄文本框 var age = document.getElementById('age'); // 为按钮添加点击事件 btn.onclick = function () { // 创建ajax对象 var xhr = new XMLHttpRequest(); // 获取用户在文本框中输入的值 var nameValue = username.value; var ageValue = age.value; // 拼接请求参数 var params = 'username='+ nameValue +'&amp;age=' + ageValue; // 配置ajax对象 xhr.open('get', 'http://localhost:3000/get?'+params); // 发送请求 xhr.send(); // 获取服务器端响应的数据 xhr.onload = function () { console.log(xhr.responseText) } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在服务的app.js，添加 // 引入express框架 const express = require('express'); // 路径处理模块 const path = require('path'); const bodyParser = require('body-parser'); const fs = require('fs'); // 创建web服务器 const app = express(); // 静态资源访问服务功能 app.use(express.static(path.join(__dirname, 'public'))); // 传递get请求参数 app.get('/get', (req, res) =&gt; { //req.query得到json字符串 res.send(req.query); }); 这里放在app.js的最后， // 监听端口 app.listen(3000); // 控制台提示输出 console.log('服务器启动成功'); 在server下调用命令行启动nodejs服务器，为了方便调试，可使用 nodemon app.js 然后在浏览器打开http://localhost:4000/传递get请求参数.html,输入数据后，可返回输入值。 解释下这里的过程： 用get的请求方法把输入的数据从浏览器端发送到服务端，服务端再把得到的数据再返回到浏览器端进行输出，当然这里为了测试，从服务端发送到浏览器端的数据也可以是其他内容 可以看到这里的请求的url是域名+?key=value&amp;key=value的形式以及请求方法为get 2.3 传递post请求参数传递post请求参数有两种方式，第一种格式和get相同，传递的数据格式为key=value&amp;key=value 在public中新建传递post请求参数.html文件 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; &lt;input type=\"text\" id=\"username\"&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=\"text\" id=\"age\"&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=\"button\" value=\"提交\" id=\"btn\"&gt; &lt;/p&gt; &lt;script type=\"text/javascript\"&gt; // 获取按钮元素 var btn = document.getElementById('btn'); // 获取姓名文本框 var username = document.getElementById('username'); // 获取年龄文本框 var age = document.getElementById('age'); // 为按钮添加点击事件 btn.onclick = function () { // 创建ajax对象 var xhr = new XMLHttpRequest(); // 获取用户在文本框中输入的值 var nameValue = username.value; var ageValue = age.value; // 拼接请求参数 var params = 'username='+ nameValue +'&amp;age=' + ageValue; // 配置ajax对象 xhr.open('post', 'http://localhost:3000/post'); // 设置请求参数格式的类型（post请求必须要设置） xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); // 发送请求 xhr.send(params); // 获取服务器端响应的数据 xhr.onload = function () { console.log(xhr.responseText) } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在原app.js的基础上再添加 //解析传递的post数据，格式为 const bodyParser = require('body-parser'); app.use(bodyParser.urlencoded()); // 传递post请求参数 app.post('/post', (req, res) =&gt; { res.send(req.body); }); 打开浏览器中输入http://localhost:3000/post请求参数.html, 打开浏览器调试，点击网络，输入数据后，可以得到post，请求url以及请求方法 这里的表单数据为输入的值，说明数据传递成功。 第二种传递的格式为json数据，主要区别在于xhr.setRequestHeader('Content-Type', 'application/json');，以及服务端的app.use(bodyParser.json());具体看下面的代码 注意：get 请求是不能提交 json 对象数据格式的，传统网站的表单提交也是不支持 json 对象数据格式的。 在public中新建向服务器端传递JSON格式的请求参数.html文件 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=\"text/javascript\"&gt; // 1.创建ajax对象 var xhr = new XMLHttpRequest(); // 2.告诉Ajax对象要向哪发送请求，以什么方式发送请求 // 1)请求方式 2)请求地址 xhr.open('post', 'http://localhost:3000/json'); // 通过请求头告诉服务器端客户端向服务器端传递的请求参数的格式是什么 xhr.setRequestHeader('Content-Type', 'application/json'); // JSON.stringify() 将json对象转换为json字符串 // 3.发送请求 xhr.send(JSON.stringify({name: 'lisi', age:50})); // 4.获取服务器端响应到客户端的数据 xhr.onload = function () { console.log(xhr.responseText) } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在原app.js的基础上再添加 //将app.use(bodyParser.urlencoded())改为app.use(bodyParser.json()); app.use(bodyParser.json()); //向服务器端传递JSON格式的请求参数 app.post('/json', (req, res) =&gt; { res.send(req.body); }); 注意：还需要将app.use(bodyParser.urlencoded());改为app.use(bodyParser.json()); 2.5 获取服务端响应在说明之前，先来介绍一个概念——报文 在 HTTP 请求和响应的过程中传递的数据块就叫报文，包括要传送的数据和一些附加信息，这些数据和信息要遵守规定好的格式。 上面的get与post请求，我们均是使用onload来获取服务端的报文，但也可以通过另外的方法来获取： 在创建ajax对象，配置ajax对象，发送请求，以及接收完服务器端响应报文，这个过程中的每一个步骤都会对应一个数值，这个数值就是ajax状态码。使用onreadystatechange 事件，可以检测状态码的变化，当状态码为 4 时就可以通过 xhr.responseText 获取服务器端的响应数据。 0：请求未初始化(还没有调用open()) 1：请求已经建立，但是还没有发送(还没有调用send()) 2：请求已经发送 3：请求正在处理中，通常响应中已经有部分数据可以用了 4：响应已经完成，可以获取并使用服务器的响应了 即下面方法可onload方法等效 // 当Ajax状态码发生变化时 xhr.onreadystatechange = function () { // 判断当Ajax状态码为4时 if (xhr.readyState == 4) { // 获取服务器端的响应数据 console.log(xhr.responseText); } } 2.4 Ajax错误处理 Ajax状态码: 表示Ajax请求的过程状态 ajax对象返回的 Http状态码: 表示请求的处理结果 是服务器端返回的 网络畅通，服务器端能接收到请求，服务器端返回的结果不是预期结果。 可以判断服务器端返回的状态码，分别进行处理。xhr.status 获取http状态码 网络畅通，服务器端没有接收到请求，返回404状态码。 检查请求地址是否错误。 网络畅通，服务器端能接收到请求，服务器端返回500状态码。 服务器端错误，找后端程序员进行沟通。 网络中断，请求无法发送到服务器端。 会触发xhr对象下面的onerror事件，在onerror事件处理函数中对错误进行处理。 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=\"btn\"&gt;发送Ajax请求&lt;/button&gt; &lt;script type=\"text/javascript\"&gt; var btn = document.getElementById('btn'); btn.onclick = function () { // 1.创建ajax对象 var xhr = new XMLHttpRequest(); // 2.告诉Ajax对象要向哪发送请求，以什么方式发送请求 // 1)请求方式 2)请求地址 xhr.open('get', 'http://localhost:3000/error'); // 3.发送请求 xhr.send(); // 4.获取服务器端响应到客户端的数据 xhr.onload = function (){ // xhr.status 获取http状态码 console.log(xhr.responseText); if (xhr.status == 400) { alert('请求出错') } } // 当网络中断时会触发onerrr事件 xhr.onerror = function () { alert('网络中断, 无法发送Ajax请求') } } // Ajax状态码: 表示Ajax请求的过程状态 ajax对象返回的 // Http状态码: 表示请求的处理结果 是服务器端返回的 &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 服务端app.js app.get('/error', (req, res) =&gt; { //console.log(abc); res.status(400).send('not ok'); }); 三. Ajax封装发送一次请求代码过多，发送多次请求代码冗余且重复。我们可以将请求代码封装到函数中，发请求时调用函数即可。 function ajax (options) { // 默认值 var defaults = { type: 'get', url: '', async: true, data: {}, header: { 'Content-Type': 'application/x-www-form-urlencoded' }, success: function () {}, error: function () {} } // 使用用户传递的参数替换默认值参数 Object.assign(defaults, options); // 创建ajax对象 var xhr = new XMLHttpRequest(); // 参数拼接变量 var params = ''; // 循环参数 for (var attr in defaults.data) { // 参数拼接 params += attr + '=' + defaults.data[attr] + '&amp;'; // 去掉参数中最后一个&amp; params = params.substr(0, params.length-1) } // 如果请求方式为get if (defaults.type == 'get') { // 将参数拼接在url地址的后面 defaults.url += '?' + params; } // 配置ajax请求 xhr.open(defaults.type, defaults.url, defaults.async); // 如果请求方式为post if (defaults.type == 'post') { // 设置请求头 xhr.setRequestHeader('Content-Type', defaults.header['Content-Type']); // 如果想服务器端传递的参数类型为json if (defaults.header['Content-Type'] == 'application/json') { // 将json对象转换为json字符串 xhr.send(JSON.stringify(defaults.data)) }else { // 发送请求 xhr.send(params); } } else { xhr.send(); } // 请求加载完成 xhr.onload = function () { // 获取服务器端返回数据的类型 var contentType = xhr.getResponseHeader('content-type'); // 获取服务器端返回的响应数据 var responseText = xhr.responseText; // 如果服务器端返回的数据是json数据类型 if (contentType.includes('application/json')) { // 将json字符串转换为json对象 responseText = JSON.parse(responseText); } // 如果请求成功 if (xhr.status == 200) { // 调用成功回调函数, 并且将服务器端返回的结果传递给成功回调函数 defaults.success(responseText, xhr); } else { // 调用失败回调函数并且将xhr对象传递给回调函数 defaults.error(responseText, xhr); } } // 当网络中断时 xhr.onerror = function () { // 调用失败回调函数并且将xhr对象传递给回调函数 defaults.error(xhr); } } 四. 模板引擎4.1 下载使用模板引擎提供的模板语法，可以将数据和 HTML 拼接起来。官方地址： https://aui.github.io/art-template/zh-cn/index.html 先去下载art-template文件 进入官网，点击Docs 然后点击安装，将temlate-web.js另存到本地就下载好了 4.2 使用步骤 下载 art-template 模板引擎库文件并在 HTML 页面中引入库文件 &lt;script src=\"./js/template-web.js\"&gt;&lt;/script&gt; 准备 art-template 模板 &lt;script id=\"tpl\" type=\"text/html\"&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;/script&gt; 告诉模板引擎将哪一个模板和哪个数据进行拼接 var html = template('tpl', {username: 'zhangsan', age: '20'}); 将拼接好的html字符串添加到页面中 document.getElementById('container').innerHTML = html; 通过模板语法告诉模板引擎，数据和html字符串要如何拼接 &lt;script id=\"tpl\" type=\"text/html\"&gt; &lt;div class=\"box\"&gt; {{ username }} &lt;/div&gt; &lt;/script&gt; 4.3 案例下面介绍三个案例说明如何使用模板引擎，一起利用Ajax进行数据的交互。 所有服务端均在app.js中。 // 引入express框架 const express = require('express'); // 路径处理模块 const path = require('path'); const formidable = require('formidable'); // 创建web服务器 const app = express(); // 静态资源访问服务功能 app.use(express.static(path.join(__dirname, 'public'))); // 邮箱地址验证 app.get('/verifyEmailAdress', (req, res) =&gt; { // 接收客户端传递过来的邮箱地址 const email = req.query.email; // 判断邮箱地址注册过的情况 if (email == 'itheima@itcast.cn') { // 设置http状态码并对客户端做出响应 res.status(400).send({message: '邮箱地址已经注册过了, 请更换其他邮箱地址'}); } else { // 邮箱地址可用的情况 // 对客户端做出响应 res.send({message: '恭喜, 邮箱地址可用'}); } }); // 输入框文字提示 app.get('/searchAutoPrompt', (req, res) =&gt; { // 搜索关键字 const key = req.query.key; // 提示文字列表 const list = [ '黑马程序员', '黑马程序员官网', '黑马程序员顺义校区', '黑马程序员学院报名系统', '传智播客', '传智博客前端与移动端开发', '传智播客大数据', '传智播客python', '传智播客java', '传智播客c++', '传智播客怎么样' ]; // 搜索结果 let result = list.filter(item =&gt; item.includes(key)); // 将查询结果返回给客户端 res.send(result); }); // 获取省份 app.get('/province', (req, res) =&gt; { res.json([{ id: '001', name: '黑龙江省' },{ id: '002', name: '四川省' },{ id: '003', name: '河北省' },{ id: '004', name: '江苏省' }]); }); // 根据省份id获取城市 app.get('/cities', (req, res) =&gt; { // 获取省份id const id = req.query.id; // 城市信息 const cities = { '001': [{ id: '300', name: '哈尔滨市' }, { id: '301', name: '齐齐哈尔市' }, { id: '302', name: '牡丹江市' }, { id: '303', name: '佳木斯市' }], '002': [{ id: '400', name: '成都市' }, { id: '401', name: '绵阳市' }, { id: '402', name: '德阳市' }, { id: '403', name: '攀枝花市' }], '003': [{ id: '500', name: '石家庄市' }, { id: '501', name: '唐山市' }, { id: '502', name: '秦皇岛市' }, { id: '503', name: '邯郸市' }], '004': [{ id: '600', name: '常州市' }, { id: '601', name: '徐州市' }, { id: '602', name: '南京市' }, { id: '603', name: '淮安市' }] } // 响应 res.send(cities[id]); }); // 根据城市id获取县城 app.get('/areas', (req, res) =&gt; { // 获取城市id const id = req.query.id; // 县城信息 const areas = { '300': [{ id: '20', name: '道里区', }, { id: '21', name: '南岗区' }, { id: '22', name: '平房区', }, { id: '23', name: '松北区' }], '301': [{ id: '30', name: '龙沙区' }, { id: '31', name: '铁锋区' }, { id: '32', name: '富拉尔基区' }] }; // 响应 res.send(areas[id] || []); }); // 监听端口 app.listen(3000); // 控制台提示输出 console.log('服务器启动成功'); 4.3.1 验证邮箱地址唯一性 在public文件夹下面新建验证邮箱地址唯一性.html &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;验证邮箱地址是否已经注册&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"/assets/bootstrap/dist/css/bootstrap.min.css\"&gt; &lt;style type=\"text/css\"&gt; p:not(:empty) { padding: 15px; } .container { padding-top: 100px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;邮箱地址&lt;/label&gt; &lt;input type=\"email\" class=\"form-control\" placeholder=\"请输入邮箱地址\" id=\"email\"&gt; &lt;/div&gt; &lt;!-- 错误 bg-danger 正确 bg-success --&gt; &lt;p id=\"info\"&gt;&lt;/p&gt; &lt;/div&gt; &lt;script src=\"/js/ajax.js\"&gt;&lt;/script&gt; &lt;script&gt; // 获取页面中的元素 var emailInp = document.getElementById('email'); var info = document.getElementById('info'); // 当文本框离开焦点以后 emailInp.onblur = function () { // 获取用户输入的邮箱地址 var email = this.value; // 验证邮箱地址的正则表达式 var reg = /^[A-Za-z\\d]+([-_.][A-Za-z\\d]+)*@([A-Za-z\\d]+[-.])+[A-Za-z\\d]{2,4}$/; // 如果用户输入的邮箱地址不符合规则 if (!reg.test(email)) { // 给出用户提示 info.innerHTML = '请输入符合规则的邮箱地址'; // 让提示信息显示为错误提示信息的样式 info.className = 'bg-danger'; // 阻止程序向下执行 return; } // 向服务器端发送请求 ajax({ type: 'get', url: 'http://localhost:3000/verifyEmailAdress', data: { email: email }, success: function (result) { console.log(result); info.innerHTML = result.message; info.className = 'bg-success'; }, error: function (result) { console.log(result) info.innerHTML = result.message; info.className = 'bg-danger'; } }); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 运行app.js，然后在浏览器中输入http://localhost:3000/验证邮箱地址唯一性.html 4.3.2 搜索框内容自动提示 在public文件夹下面新建搜索框内容自动提示.html &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;搜索框输入文字自动提示&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"/assets/bootstrap/dist/css/bootstrap.min.css\"&gt; &lt;style type=\"text/css\"&gt; .container { padding-top: 150px; } .list-group { display: none; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"form-group\"&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"请输入搜索关键字\" id=\"search\"&gt; &lt;ul class=\"list-group\" id=\"list-box\"&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=\"/js/ajax.js\"&gt;&lt;/script&gt; &lt;script src=\"/js/template-web.js\"&gt;&lt;/script&gt; &lt;script type=\"text/html\" id=\"tpl\"&gt; {{each result}} &lt;li class=\"list-group-item\"&gt;{{$value}}&lt;/li&gt; {{/each}} &lt;/script&gt; &lt;script&gt; // 获取搜索框 var searchInp = document.getElementById('search'); // 获取提示文字的存放容器 var listBox = document.getElementById('list-box'); // 存储定时器的变量 var timer = null; // 当用户在文本框中输入的时候触发 searchInp.oninput = function () { // 清除上一次开启的定时器 clearTimeout(timer); // 获取用户输入的内容 var key = this.value; // 如果用户没有在搜索框中输入内容 if (key.trim().length == 0) { // 将提示下拉框隐藏掉 listBox.style.display = 'none'; // 阻止程序向下执行 return; } // 开启定时器 让请求延迟发送 timer = setTimeout(function () { // 向服务器端发送请求 // 向服务器端索取和用户输入关键字相关的内容 ajax({ type: 'get', url: 'http://localhost:3000/searchAutoPrompt', data: { key: key }, success: function (result) { // 使用模板引擎拼接字符串 var html = template('tpl', {result: result}); // 将拼接好的字符串显示在页面中 listBox.innerHTML = html; // 显示ul容器 listBox.style.display = 'block'; } }) }, 800) } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 运行app.js，然后在浏览器中输入http://localhost:3000/搜索框内容自动提示.html 4.3.3 省市区联动 在public文件夹下面新建省市区联动.html &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;搜索框输入文字自动提示&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"/assets/bootstrap/dist/css/bootstrap.min.css\"&gt; &lt;style type=\"text/css\"&gt; .container { padding-top: 150px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"form-inline\"&gt; &lt;div class=\"form-group\"&gt; &lt;select class=\"form-control\" id=\"province\"&gt;&lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;select class=\"form-control\" id=\"city\"&gt; &lt;option&gt;请选择城市&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;select class=\"form-control\" id=\"area\"&gt; &lt;option&gt;请选择县城&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=\"/js/ajax.js\"&gt;&lt;/script&gt; &lt;script src=\"/js/template-web.js\"&gt;&lt;/script&gt; &lt;!-- 省份模板 --&gt; &lt;script type=\"text/html\" id=\"provinceTpl\"&gt; &lt;option&gt;请选择省份&lt;/option&gt; {{each province}} &lt;option value=\"{{$value.id}}\"&gt;{{$value.name}}&lt;/option&gt; {{/each}} &lt;/script&gt; &lt;!-- 城市模板 --&gt; &lt;script type=\"text/html\" id=\"cityTpl\"&gt; &lt;option&gt;请选择城市&lt;/option&gt; {{each city}} &lt;option value=\"{{$value.id}}\"&gt;{{$value.name}}&lt;/option&gt; {{/each}} &lt;/script&gt; &lt;!-- 县城模板 --&gt; &lt;script type=\"text/html\" id=\"areaTpl\"&gt; &lt;option&gt;请选择县城&lt;/option&gt; {{each area}} &lt;option value=\"{{$value.id}}\"&gt;{{$value.name}}&lt;/option&gt; {{/each}} &lt;/script&gt; &lt;script&gt; // 获取省市区下拉框元素 var province = document.getElementById('province'); var city = document.getElementById('city'); var area = document.getElementById('area'); // 获取省份信息 ajax({ type: 'get', url: 'http://localhost:3000/province', success: function (data) { // 将服务器端返回的数据和html进行拼接 var html = template('provinceTpl', {province: data}); // 将拼接好的html字符串显示在页面中 province.innerHTML = html; } }); // 为省份的下拉框添加值改变事件 province.onchange = function () { // 获取省份id var pid = this.value; // 清空县城下拉框中的数据 var html = template('areaTpl', {area: []}); area.innerHTML = html; // 根据省份id获取城市信息 ajax({ type: 'get', url: '/cities', data: { id: pid }, success: function (data) { var html = template('cityTpl', {city: data}); city.innerHTML = html; } }) }; // 当用户选择城市的时候 city.onchange = function () { // 获取城市id var cid = this.value; // 根据城市id获取县城信息 ajax({ type: 'get', url: 'http://localhost:3000/areas', data: { id: cid }, success: function(data) { var html = template('areaTpl', {area: data}); area.innerHTML = html; } }) } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 运行app.js，然后在浏览器中输入http://localhost:3000/省市区联动.html","categories":[{"name":"技能之树","slug":"技能之树","permalink":"https://bingshanyishu.github.io/categories/%E6%8A%80%E8%83%BD%E4%B9%8B%E6%A0%91/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://bingshanyishu.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Ajax","slug":"Ajax","permalink":"https://bingshanyishu.github.io/tags/Ajax/"}],"author":"Sankey"},{"title":"CSS3新特性——新增选择器，2D/3D转换，动画","slug":"CSS3新特性——新增选择器，2D-3D转换，动画","date":"2022-03-12T14:07:36.000Z","updated":"2022-03-12T14:15:12.979Z","comments":true,"path":"posts/202203122207.html","link":"","permalink":"https://bingshanyishu.github.io/posts/202203122207.html","excerpt":"","text":"CSS3新特性——新增选择器，2D/3D转换，动画博客园主页：博客园主页-冰山一树SankeyCSDN主页：CSDN主页-冰山一树Sankey 前端学习：学习地址：黑马程序员pink老师前端入门教程，零基础必看的h5(html5)+css3+移动，下面这些都是一些学习笔记。临渊羡鱼，不如退而结网！！愿我自己学有所成，也愿每个前端爱好者学有所成 一. CSS3选择器1.1 属性选择器属性选择器可以根据元素特定属性的来选择元素。 这样就可以不用借助于类或者id选择器。 选择符 简介 E[att] 选择具有att属性的E元素 E[att=”val”] 选择具有att属性且属性值等于val的E元素 E[att^=”val”] 匹配具有att属性且值以val开头的E元素 E[att$=”val”] 匹配具有att属性且值以val结尾的E元素 E[att*=”val”] 匹配具有att属性且值中含有val的E元素 意：类选择器、属性选择器、伪类选择器，权重为 10。 1.2 结构伪类选择器结构伪类选择器主要根据文档结构来选择器元素， 常用于根据父级选择器里面的子元素 选择符 简介 E:first-child 匹配父元素中的第一个子元素E E:last-child 匹配父元素中最后一个E元素 E:nth-child(n) 匹配父元素中的第n个子元素E E:first-of-type 指定类型E的第一个 E:last-of-type 指定类型E的最后一个 E:nth-of-type(n) 指定类型E的第n个 区别： nth-child 对父元素里面所有孩子排序选择（序号是固定的） 先找到第n个孩子，然后看看是否和E匹配 nth-of-type 对父元素里面指定子元素进行排序选择。 先去匹配E ，然后再根据E 找第n个孩子 例： &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;CSS3新增结构伪类选择器-nth-child&lt;/title&gt; &lt;style&gt; /* 1.把所有的偶数 even的孩子选出来 */ ul li:nth-child(even) { background-color: #ccc; } /* 2.把所有的奇数 odd的孩子选出来 */ ul li:nth-child(odd) { background-color: gray; } /* 3.nth-child(n) 从0开始 每次加1 往后面计算 这里面必须是n 不能是其他的字母 选择了所有的孩子*/ ol li:nth-child(n) { background-color: pink; } /* 4.nth-child(2n)母选择了所有的偶数孩子 等价于 even*/ ol li:nth-child(2n) { background-color: pink; } /* 4.nth-child(2n+1)母选择了所有的奇数孩子 等价于 odd*/ ol li:nth-child(2n+1) { background-color: skyblue; } /* 选择第三个以后的元素 */ ol li:nth-child(n+3) { background-color: pink; } /* 选择前3个 */ ol li:nth-child(-n+3) { background-color: pink; } /*选择第二个到第五个*/ ol li:nth-child(n+2):nth-child(-n+5) { background-color: pink; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;我是第1个孩子&lt;/li&gt; &lt;li&gt;我是第2个孩子&lt;/li&gt; &lt;li&gt;我是第3个孩子&lt;/li&gt; &lt;li&gt;我是第4个孩子&lt;/li&gt; &lt;li&gt;我是第5个孩子&lt;/li&gt; &lt;li&gt;我是第6个孩子&lt;/li&gt; &lt;li&gt;我是第7个孩子&lt;/li&gt; &lt;li&gt;我是第8个孩子&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li&gt;我是第1个孩子&lt;/li&gt; &lt;li&gt;我是第2个孩子&lt;/li&gt; &lt;li&gt;我是第3个孩子&lt;/li&gt; &lt;li&gt;我是第4个孩子&lt;/li&gt; &lt;li&gt;我是第5个孩子&lt;/li&gt; &lt;li&gt;我是第6个孩子&lt;/li&gt; &lt;li&gt;我是第7个孩子&lt;/li&gt; &lt;li&gt;我是第8个孩子&lt;/li&gt; &lt;/ol&gt; &lt;/body&gt; &lt;/html&gt; 1.3 伪元素选择器伪元素选择器可以帮助我们利用CSS创建新标签元素，而不需要HTML标签，从而简化HTML结构。 选择符 简介 ::before 在元素内部的前面插入内容 ::after 在元素内部的后面插入内容 注意： before 和 after 创建一个元素，但是属于行内元素 新创建的这个元素在文档树中是找不到的，所以我们称为伪元素 语法： element::before {} before 和 after 必须有 content 属性 before 在父元素内容的前面创建元素，after 在父元素内容的后面插入元素 伪元素选择器和标签选择器一样，权重为 1 1.3.1 伪元素字体图标 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;伪元素选择器使用场景-字体图标&lt;/title&gt; &lt;style&gt; @font-face { font-family: 'icomoon'; src: url('fonts/icomoon.eot?1lv3na'); src: url('fonts/icomoon.eot?1lv3na#iefix') format('embedded-opentype'), url('fonts/icomoon.ttf?1lv3na') format('truetype'), url('fonts/icomoon.woff?1lv3na') format('woff'), url('fonts/icomoon.svg?1lv3na#icomoon') format('svg'); font-weight: normal; font-style: normal; font-display: block; } div { position: relative; width: 200px; height: 35px; border: 1px solid red; } div::after { position: absolute; top: 10px; right: 10px; font-family: 'icomoon'; /* content: ''; */ content: '\\e91e'; color: red; font-size: 18px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 二. 其他特性2.1 CSS3 盒子模型CSS3 中可以通过 box-sizing 来指定盒模型，有2个值：即可指定为 content-box、border-box，这样我们计算盒子大小的方式就发生了改变。可以分成两种情况： box-sizing: content-box 盒子大小为 width + padding + border （以前默认的） box-sizing: border-box 盒子大小为 width 如果盒子模型我们改为了box-sizing: border-box ， 那padding和border就不会撑大盒子了（前提padding和border不会超过width宽度） 2.2 图片变模糊ilter CSS属性将模糊或颜色偏移等图形效果应用于元素。 filter: 函数(); 例如： filter: blur(5px); blur模糊处理 数值越大越模糊 2.3 CSS3 calc 函数calc() 此CSS函数让你在声明CSS属性值时执行一些计算。 width: calc(100% - 80px); 括号里面可以使用 + - * / 来进行计算。 2.3 CSS3 过渡（重点）**过渡（transition)**是CSS3中具有颠覆性的特征之一，我们可以在不使用 Flash 动画或JavaScript 的情况下，当元素从一种样式变换为另一种样式时为元素添加效果。 过渡动画： 是从一个状态 渐渐的过渡到另外一个状态可以让我们页面更好看，更动感十足，虽然 低版本浏览器不支持（ie9以下版本） 但是不会影响页面布局。现在经常和 :hover 一起 搭配使用。 transition: 花费时间 运动曲线 何时开始; 属性 ： 想要变化的 css 属性， 宽度高度 背景颜色 内外边距都可以 。如果想要所有的属性都变化过渡， 写一个all 就可以。 花费时间： 单位是 秒（必须写单位） 比如 0.5s 运动曲线： 默认是 ease （可以省略） 何时开始 ：单位是 秒（必须写单位）可以设置延迟触发时间 默认是 0s （可以省略） 案例： &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;CSS3过渡练习-进度条&lt;/title&gt; &lt;style&gt; .bar { width: 150px; height: 15px; border: 1px solid red; border-radius: 7px; padding: 1px; } .bar_in { width: 50%; height: 100%; background-color: red; /* 谁做过渡给谁加 */ transition: all .7s; } .bar:hover .bar_in { width: 100%; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"bar\"&gt; &lt;div class=\"bar_in\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 三. 2D转换转换（transform）是CSS3中具有颠覆性的特征之一，可以实现元素的位移、旋转、缩放等效果 移动：translate 旋转：rotate 缩放：scale 2D转换是改变标签在二维平面上的位置和形状的一种技术，在html页面中，二维坐标系是下图这个样子 3.1 移动tanslate2D移动是2D转换里面的一种功能，可以改变元素在页面中的位置，类似定位。 语法： transform: translate(x,y); 或者分开写 transform: translateX(n); transform: translateY(n); 重点： 定义 2D 转换中的移动，沿着 X 和 Y 轴移动元素 translate最大的优点：不会影响到其他元素的位置 translate中的百分比单位是相对于自身元素的 translate:(50%,50%); 对行内标签没有效果 3.1 旋转 rotate2D旋转指的是让元素在2维平面内顺时针旋转或者逆时针旋转。 语法: transform:rotate(度数) 重点： rotate里面跟度数， 单位是 deg 比如 rotate(45deg) 角度为正时，顺时针，负时，为逆时针 默认旋转的中心点是元素的中心点 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div { position: relative; width: 249px; height: 35px; border: 1px solid #000; } div::after { content: \"\"; position: absolute; top: 8px; right: 15px; width: 10px; height: 10px; border-right: 1px solid #000; border-bottom: 1px solid #000; transform: rotate(45deg); transition: all 0.2s; } /* 鼠标经过div 里面的三角旋转 */ div:hover::after { transform: rotate(225deg); } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 3.3 中心点 transform-origin语法： transform-origin: x y; 重点： 注意后面的参数 x 和 y 用空格隔开 x y 默认转换的中心点是元素的中心点 (50% 50%) 还可以给x y 设置 像素 或者 方位名词 （top bottom left right center） 案例：鼠标经过，浅红色方块旋转上来。 &lt;style&gt; div { overflow: hidden; width: 200px; height: 200px; border: 1px solid pink; margin: 10px; float: left; } div::before { content: \"黑马\"; display: block; width: 100%; height: 100%; background-color: hotpink; transform: rotate(180deg); transform-origin: left bottom; transition: all 0.4s; } /* 鼠标经过div 里面的before 复原 */ div:hover::before { transform: rotate(0deg); } &lt;/style&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt; 3.4 缩放scale缩放，顾名思义，可以放大和缩小。 只要给元素添加上了这个属性就能控制它放大还是缩小。 语法： transform:scale(x,y); 重点： 注意其中的x和y用逗号分隔 transform:scale(1,1) ：宽和高都放大一倍，相当于没有放大 transform:scale(2,2) ：宽和高都放大了2倍 transform:scale(2) ：只写一个参数，第二个参数则和第一个参数一样，相当于 scale(2,2) transform:scale(0.5,0.5)：缩小 sacle缩放最大的优势：可以设置转换中心点缩放，默认以中心点缩放的，而且不影响其他盒子 案例： &lt;style&gt; li { float: left; width: 30px; height: 30px; border: 1px solid pink; margin: 10px; text-align: center; line-height: 30px; list-style: none; border-radius: 50%; cursor: pointer; transition: all .4s; } li:hover { transform: scale(1.2); } &lt;/style&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; 3.5 2D 转换综合写法 同时使用多个转换，其格式为：transform: translate() rotate() scale() …等， 其顺序会影转换的效果。（先旋转会改变坐标轴方向） 当我们同时有位移和其他属性的时候，记得要将位移放到最前 &lt;style&gt; div { width: 200px; height: 200px; background-color: pink; transition: all .5s; } div:hover { /* transform: rotate(180deg) translate(150px, 50px); */ /* 我们同时有位移和其他属性，我们需要把位移放到最前面 */ transform: translate(150px, 50px) rotate(180deg) scale(1.2); } &lt;/style&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt; 四. 动画动画（animation）是CSS3中具有颠覆性的特征之一，可通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果。相比较过渡，动画可以实现更多变化，更多控制，连续自动播放等效果。 4.1 动画的基本使用制作动画分为两步： 先定义动画 再使用（调用）动画 4.1.1 用keyframes定义动画@keyframes 动画名称 { 0%{ width:100px; } 100%{ width:200px; } 动画序列： 0% 是动画的开始，100% 是动画的完成。这样的规则就是动画序列。 在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果。 动画是使元素从一种样式逐渐变化为另一种样式的效果。您可以改变任意多的样式任意多的次数。 请用百分比来规定变化发生的时间，或用关键词 “from” 和 “to”，等同于 0% 和 100%。 4.1.2 元素使用动画div { width: 200px; height: 200px; background-color: aqua; margin: 100px auto; /* 调用动画 */ animation-name: 动画名称; /* 持续时间 */ animation-duration: 持续时间; } 4.2 动画常用属性 属性 描述 @keyframes 规定动画。 animation 所有动画属性的简写属性,除了animation-play-state/属性。 animation-name 规定@keyframesz动画的名称。(必须的) animation-duration 规定动画完成一个周期所花费的秒或毫秒,默认是0。(必须的) animation-timing-function 规定动画的速度曲线,默认是“ease”。 animation-delay 规定动画何时开始,默认是0。 animation-iteration-count 规定动画被播放的次数,默认是1,还有infinit animation-direction 规定动画是否在下一周期逆向播放,默认是”normal”,alternate是逆播放 animation-play-state 规定动画是否正在运行或暂停。默认是”running”,有”paused”。 animation-fill-mode 规定动画结束后状态,保持forwards回到起始backwards &lt;style&gt; @keyframes move { 0% { transform: translate(0, 0); } 100% { transform: translate(1000px, 0); } } div { width: 100px; height: 100px; background-color: pink; /* 动画名称 */ animation-name: move; /* 持续时间 */ animation-duration: 2s; /* 运动曲线 */ animation-timing-function: ease; /* 何时开始 */ animation-delay: 1s; /* 重复次数 iteration 重复的 conut 次数 infinite 无限 */ animation-iteration-count: infinite; /* 是否反方向播放 默认的是 normal 如果想要反方向 就写 alternate */ animation-direction: alternate; /* 动画结束后的状态 默认的是 backwards 回到起始状态 我们可以让他停留在结束状态 forwards */ /animation-fill-mode: forwards; /* animation: name duration timing-function delay iteration-count direction fill-mode; */ animation: move 2s linear 0s 1 alternate forwards; /* 前面2个属性 name duration 一定要写 */ /* animation: move 2s linear alternate forwards; */ } div:hover { /* 鼠标经过div 让这个div 停止动画，鼠标离开就继续动画 */ animation-play-state: paused; } &lt;/style&gt; &lt;body&gt; &lt;div&gt; &lt;/div&gt; &lt;/body&gt; 4.3 动画简写属性animation：动画名称 持续时间 运动曲线 何时开始 播放次数 是否反方向 动画起始或者结束的状态; animation: myfirst 5s linear 2s infinite alternate; 简写属性里面不包含 animation-play-state 暂停动画：animation-play-state: puased; 经常和鼠标经过等其他配合使用 想要动画走回来 ，而不是直接跳回来：animation-direction ： alternate 盒子动画结束后，停在结束位置： animation-fill-mode ： forwards 案例: &lt;style&gt; body { background-color: #333; } .map { position: relative; width: 747px; height: 616px; background: url(media/map.png) no-repeat; margin: 0 auto; } .city { position: absolute; top: 227px; right: 193px; color: #fff; } .tb { top: 500px; right: 80px; } .dotted { width: 8px; height: 8px; background-color: #09f; border-radius: 50%; } .city div[class^=\"pulse\"] { /* 保证我们小波纹在父盒子里面水平垂直居中 放大之后就会中心向四周发散 */ position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 8px; height: 8px; box-shadow: 0 0 12px #009dfd; border-radius: 50%; animation: pulse 1.2s linear infinite; } .city div.pulse2 { animation-delay: 0.4s; } .city div.pulse3 { animation-delay: 0.8s; } @keyframes pulse { 0% {} 70% { /* transform: scale(5); 我们不要用scale 因为他会让 阴影变大*/ width: 40px; height: 40px; opacity: 1; } 100% { width: 70px; height: 70px; opacity: 0; } } &lt;/style&gt; &lt;body&gt; &lt;div class=\"map\"&gt; &lt;div class=\"city\"&gt; &lt;div class=\"dotted\"&gt;&lt;/div&gt; &lt;div class=\"pulse1\"&gt;&lt;/div&gt; &lt;div class=\"pulse2\"&gt;&lt;/div&gt; &lt;div class=\"pulse3\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"city tb\"&gt; &lt;div class=\"dotted\"&gt;&lt;/div&gt; &lt;div class=\"pulse1\"&gt;&lt;/div&gt; &lt;div class=\"pulse2\"&gt;&lt;/div&gt; &lt;div class=\"pulse3\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 4.4 速度曲线调节animation-timing-function：规定动画的速度曲线，默认是“ease” 值 描述 linear 动画从头到尾的速度是相同的。匀速 ease 默认。动画以低速开始,然后加快,在结束前变慢 ease-in 动画以低速开始。 ease-out 动画以低速结束。 ease-in-out 动画以低速开始和结束。 steps() 指定了时间函数中的间隔数量(步长) &lt;style&gt; body { background-color: #ccc; } div { position: absolute; width: 200px; height: 100px; background: url(media/bear.png) no-repeat; /* 元素可以添加多个动画， 用逗号分隔 */ animation: bear .4s steps(8) infinite, move 3s forwards; } @keyframes bear { 0% { background-position: 0 0; } 100% { background-position: -1600px 0; } } @keyframes move { 0% { left: 0; } 100% { left: 50%; /* margin-left: -100px; */ transform: translateX(-50%); } } &lt;/style&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt; 五. 3D转换 5.1 三维坐标系三维坐标系其实就是指立体空间，立体空间是由3个轴共同组成的。 x轴：水平向右 注意： x 右边是正值，左边是负值 y轴：垂直向下 注意： y 下面是正值，上面是负值 z轴：垂直屏幕 注意： 往外面是正值，往里面是负值 5.2 透视 perspective 在2D平面产生近大远小视觉立体，但是只是效果二维的 如果想要在网页产生3D效果需要透视（理解成3D物体投影在2D平面内）。 模拟人类的视觉位置，可认为安排一只眼睛去看 透视我们也称为视距：视距就是人的眼睛到屏幕的距离 距离视觉点越近的在电脑平面成像越大，越远成像越小 透视的单位是像素 透视写在被观察元素的父盒子上面的 d：就是视距，视距就是一个距离人的眼睛到屏幕的距离。z：就是 z轴，物体距离屏幕的距离，z轴越大（正值） 我们看到的物体就越大。 body { /* 透视写到被观察元素的父盒子上面 */ perspective: 200px; } 5.3 3D移动translate3D移动在2D移动的基础上多加了一个可以移动的方向，就是z轴方向。 translform:translateX(100px)：仅仅是在x轴上移动 translform:translateY(100px)：仅仅是在Y轴上移动 translform:translateZ(100px)：仅仅是在Z轴上移动（注意：translateZ一般用px单位） transform:translate3d(x,y,z)：其中 x、y、z 分别指要移动的轴的方向的距离 因为z轴是垂直屏幕，由里指向外面，所以默认是看不到元素在z轴的方向上移动 &lt;style&gt; body { /* 透视 */ perspective: 200px; } div { width: 200px; height: 200px; background-color: pink; /* transform: translateX(100px); transform: translateY(100px); */ /* transform: translateX(100px) translateY(100px) translateZ(100px); */ /* 1. translateZ 沿着Z轴移动 */ /* 2. translateZ 后面的单位我们一般跟px */ /* 3. translateZ(100px) 向外移动100px （向我们的眼睛来移动的） */ /* 4. 3D移动有简写的方法 */ /* transform: translate3d(x,y,z); */ /* transform: translate3d(100px, 100px, 100px); */ /* 5. xyz是不能省略的，如果没有就写0 */ transform: translate3d(400px, 100px, 100px); } &lt;/style&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt; 5.4 3D旋转rotate3d3D旋转指可以让元素在三维平面内沿着 x轴，y轴，z轴或者自定义轴进行旋转。 语法： transform:rotateX(45deg)：沿着x轴正方向旋转 45度 transform:rotateY(45deg) ：沿着y轴正方向旋转 45deg transform:rotateZ(45deg) ：沿着Z轴正方向旋转 45deg transform:rotate3d(x,y,z,deg)： 沿着自定义轴旋转 deg为角度（了解即可） 5.4.1 正方向判断 X轴 Y轴 5.4.2 自定义轴旋转transform:rotate3d(x,y,z,deg)： 沿着自定义轴旋转 deg为角度（了解即可） xyz是表示旋转轴的矢量，是标示你是否希望沿着该轴旋转，最后一个标示旋转的角度。 transform:rotate3d(1,0,0,45deg) 就是沿着x轴旋转 45deg transform:rotate3d(1,1,0,45deg) 就是沿着对角线旋转 45deg 5.5 3D呈现 transfrom-style 控制子元素是否开启三维立体环境。 transform-style: flat 子元素不开启3d立体空间 默认的。 transform-style: preserve-3d; 子元素开启立体空间。 代码写给父级，但是影响的是子盒子。 这个属性很重要，后面必用。 &lt;style&gt; body { perspective: 400px; } .box { position: relative; width: 300px; height: 300px; margin: 100px auto; transition: all .4s; /* 让背面的紫色盒子保留立体空间 给父级添加的 */ transform-style: preserve-3d; } .box:hover { transform: rotateY(180deg); } .front, .back { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border-radius: 50%; font-size: 30px; color: #fff; text-align: center; line-height: 300px; } .front { background-color: pink; z-index: 1; } .back { background-color: purple; /* 像手机一样 背靠背 旋转 */ transform: rotateY(180deg); } /style&gt; &lt;body&gt; &lt;div class=\"box\"&gt; &lt;div class=\"front\"&gt;黑马程序员&lt;/div&gt; &lt;div class=\"back\"&gt;pink老师这里等你&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 5.6 综合案例5.6.1 3D导航栏 &lt;style&gt; * { margin: 0; padding: 0; } ul { margin: 100px; } ul li { width: 120px; height: 35px; list-style: none; perspective: 400px; } .box { position: relative; width: 100%; height: 100%; transform-style: preserve-3d; transition: all 0.5s; } .box:hover { transform: rotateX(90deg); } .front, .back { position: absolute; left: 0; top: 0; width: 100%; height: 100%; line-height: 35px; text-align: center; } .front { background-color: skyblue; z-index: 1; transform: translateZ(50%); } .back { background-color: yellow; /* transform: translateY(50%) rotateX(-90deg); */ transform: rotateX(-90deg) translateZ(17.5px); } &lt;/style&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt; &lt;div class=\"box\"&gt; &lt;div class=\"front\"&gt;你好&lt;/div&gt; &lt;div class=\"back\"&gt;明天&lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; 5.6.2 旋转木马 &lt;style&gt; body { perspective: 1000px; } section { position: relative; width: 300px; height: 200px; margin: 150px auto; transform-style: preserve-3d; /* 添加动画效果 */ animation: rotate 10s linear infinite; background: url(media/pig.jpg) no-repeat; } section:hover { /* 鼠标放入section 停止动画 */ animation-play-state: paused; } @keyframes rotate { 0% { transform: rotateY(0); } 100% { transform: rotateY(360deg); } } section div { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: url(media/dog.jpg) no-repeat; } section div:nth-child(1) { transform: rotateY(0) translateZ(300px); } section div:nth-child(2) { /* 先旋转好了再 移动距离 */ transform:rotateY(60deg) translateZ(300px); } section div:nth-child(3) { /* 先旋转好了再 移动距离 */ transform: rotateY(120deg) translateZ(300px); } section div:nth-child(4) { /* 先旋转好了再 移动距离 */ transform: rotateY(180deg) translateZ(300px); } section div:nth-child(5) { /* 先旋转好了再 移动距离 */ transform: rotateY(240deg) translateZ(300px); } section div:nth-child(6) { /* 先旋转好了再 移动距离 */ transform: rotateY(300deg) translateZ(300px); } &lt;/style&gt; &lt;body&gt; &lt;section&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/section&gt; &lt;/body&gt;","categories":[{"name":"技能之树","slug":"技能之树","permalink":"https://bingshanyishu.github.io/categories/%E6%8A%80%E8%83%BD%E4%B9%8B%E6%A0%91/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://bingshanyishu.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"CSS3","slug":"CSS3","permalink":"https://bingshanyishu.github.io/tags/CSS3/"}],"author":"Sankey"},{"title":"CSS高级技巧——精灵图，字体图标，三角形等","slug":"CSS高级技巧——精灵图，字体图标，三角形等","date":"2022-03-12T13:54:54.000Z","updated":"2022-03-12T13:57:59.864Z","comments":true,"path":"posts/202203122154.html","link":"","permalink":"https://bingshanyishu.github.io/posts/202203122154.html","excerpt":"","text":"CSS高级技巧——精灵图，字体图标，三角形等博客园主页：博客园主页-冰山一树SankeyCSDN主页：CSDN主页-冰山一树Sankey 前端学习：学习地址：黑马程序员pink老师前端入门教程，零基础必看的h5(html5)+css3+移动，下面这些都是一些学习笔记。临渊羡鱼，不如退而结网！！愿我自己学有所成，也愿每个前端爱好者学有所成 一. 精灵图1.1 为什么需要精灵图 一个网页中往往会应用很多小的背景图像作为修饰，当网页中的图像过多时，服务器就会频繁地接收和发送请求图片，造成服务器请求压力过大，这将大大降低页面的加载速度。因此，为了有效地减少服务器接收和发送请求的次数，提高页面的加载速度，出现了 CSS 精灵技术（也称CSS Sprites、CSS 雪碧）。核心原理：将网页中的一些小背景图像整合到一张大图中 ，这样服务器只需要一次请求就可以了。 1.2 精灵图（sprites）的使用使用精灵图核心： 精灵技术主要针对于背景图片使用。就是把多个小背景图片整合到一张大图片中。 这个大图片也称为 sprites 精灵图 或者 雪碧图 移动背景图片位置， 此时可以使用 background-position 。 移动的距离就是这个目标图片的 x 和 y 坐标。注意网页中的坐标有所不同 因为一般情况下都是往上往左移动，所以数值是负值。 使用精灵图的时候需要精确测量，每个小背景图片的大小和位置。 1.3 案例这是一张精灵图图片，拼出单词pink &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;利用精灵图拼出pink&lt;/title&gt; &lt;style&gt; span { display: inline-block; background: url(images/abcd.jpg) no-repeat; } .p { width: 100px; height: 112px; /* background-color: pink; */ background-position: -493px -276px; } .i { width: 60px; height: 108px; /* background-color: pink; */ background-position: -327px -142px; } .n { width: 108px; height: 109px; /* background-color: pink; */ background-position: -215px -141px; } .k { width: 105px; height: 114px; /* background-color: pink; */ background-position: -495px -142px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;span class=\"p\"&gt;&lt;/span&gt; &lt;span class=\"i\"&gt;&lt;/span&gt; &lt;span class=\"n\"&gt;&lt;/span&gt; &lt;span class=\"k\"&gt;&lt;/span&gt; &lt;/body&gt; &lt;/html&gt; 二. 字体图标2.1 字体图标的产生字体图标使用场景： 主要用于显示网页中通用、常用的一些小图标 精灵图是有诸多优点的，但是缺点很明显。 图片文件还是比较大的。 图片本身放大和缩小会失真。 一旦图片制作完毕想要更换非常复杂。 此时，有一种技术的出现很好的解决了以上问题，就是字体图标 iconfont。字体图标可以为前端工程师提供一种方便高效的图标使用方式，展示的是图标，本质属于字体。 2.2 字体图标的优点 轻量级：一个图标字体要比一系列的图像要小。一旦字体加载了，图标就会马上渲染出来，减少了服务器请求 灵活性：本质其实是文字，可以很随意的改变颜色、产生阴影、透明效果、旋转等 兼容性：几乎支持所有的浏览器，请放心使用 注意： 字体图标不能替代精灵技术，只是对工作中图标部分技术的提升和优化。 2.3 字体图标的下载 icomoon 字库 http://icomoon.io 推荐指数 ★★★★★ IcoMoon 成立于 2011 年，推出了第一个自定义图标字体生成器，它允许用户选择所需要的图标，使它们成一字型。该字库内容种类繁多，非常全面，唯一的遗憾是国外服务器，打开网速较慢。 阿里 iconfont 字库 http://www.iconfont.cn/ 推荐指数 ★★★★★ 这个是阿里 M2UX 的一个 iconfont 字体图标字库，包含了淘宝图标库和阿里图标库。可以使用 AI制作图标上传生成。 重点是，免费！ Font Awesomehttps://fa5.dashgame.com/#/推荐指数 ★★★★★ Font Awesome已经发展到拥有5000多个图标，并持续添加最受欢迎和最迫切需要的图标。不用再没有头绪的寻找你需要的图标，也不用自己拼凑，更不用从不知名的角落里寻找品牌商标。使用也及其简单，只需要引入样式文件即可直接使用 2.4 字体文件格式不同浏览器所支持的字体格式是不一样的，字体图标之所以兼容，就是因为包含了主流浏览器支持的字体文件。 TureType**(.ttf)**格式.ttf字体是Windows和Mac的最常见的字体，支持这种字体的浏览器有IE9+、Firefox3.5+、 Chrome4+、Safari3+、Opera10+、iOS Mobile、Safari4.2+； Web Open Font Format**(.woff)**格式woff字体，支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome6+、Safari3.6+、Opera11.1+； Embedded Open Type**(.eot)**格式.eot字体是IE专用字体，支持这种字体的浏览器有IE4+； SVG**(.svg)**格式.svg字体是基于SVG字体渲染的一种格式，支持这种字体的浏览器有Chrome4+、Safari3.1+、Opera10.0+、iOS Mobile Safari3.2+； 2.5 字体图标的引入这里介绍icomoon 字体图标的引入 下载完毕之后，注意原先的文件不要删，后面会用。 把下载包里面的 fonts 文件夹放入页面根目录下 在 CSS 样式中全局声明字体： 简单理解把这些字体文件通过css引入到我们页面中。 一定注意字体文件路径的问题。 @font-face { font-family: 'icomoon'; src: url('fonts/icomoon.eot?7kkyc2'); src: url('fonts/icomoon.eot?7kkyc2#iefix') format('embedded-opentype'), url('fonts/icomoon.ttf?7kkyc2') format('truetype'), url('fonts/icomoon.woff?7kkyc2') format('woff'), url('fonts/icomoon.svg?7kkyc2#icomoon') format('svg'); font-weight: normal; font-style: normal; } 注：这里代码这可直接到下载的文件的style.css中粘贴 html 标签内添加小图标。 这里得到图表的代码， &lt;span&gt;\"\\e902\"&lt;/span&gt; 给标签定义字体。 span { font-family: \"icomoon\"; } 务必保证 这个字体和上面@font-face里面的字体保持一致 2.6 字体图标的追加如果工作中，原来的字体图标不够用了，我们需要添加新的字体图标到原来的字体文件中。把压缩包里面的 selection.json 从新上传，然后选中自己想要新的图标，从新下载压缩包，并替换原来的文件即可。 三. CSS三角3.1 等腰直角三角形网页中常见一些三角形，使用 CSS 直接画出来就可以，不必做成图片或者字体图标。 原理就是将宽度和高度设置为0.然后边框，就会生成下图的形状，如果只需要一个三角形，那么就把其他边框变成透明，设置一个边框，如下面box1所示 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;CSS 三角制作&lt;/title&gt; &lt;style&gt; /*上面的四彩正方形*/ .box1 { width: 0; height: 0; /* border: 10px solid pink; */ border-top: 50px solid pink; border-right: 50px solid red; border-bottom: 50px solid blue; border-left: 50px solid green; } /*三角形*/ .box2 { width: 0; height: 0; border: 50px solid transparent; border-left-color: pink; margin: 100px auto; } /*京东代码*/ .jd { position: relative; width: 120px; height: 249px; background-color: pink; } .jd span { position: absolute; right: 15px; top: -10px; width: 0; height: 0; /* 为了照顾兼容性 */ line-height: 0; font-size: 0; border: 5px solid transparent; border-bottom-color: pink; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"box1\"&gt;&lt;/div&gt; &lt;div class=\"box2\"&gt;&lt;/div&gt; &lt;div class=\"jd\"&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 如上面代码box2的三角形 京东样式代码 3.2 直角三角形（不等腰）.box1 { width: 0; height: 0; /* 把上边框宽度调大 */ border-top: 100px solid transparent; border-right: 50px solid skyblue; /* 左边和下边的边框宽度设置为0，或者直接不设置 */ border-bottom: 0 solid transparent; border-left: 0 solid transparent; } 也可以连写 .box1 { /* 1.只保留右边的边框有颜色 */ border-color: transparent red transparent transparent; /* 2. 样式都是solid */ border-style: solid; /* 3. 上边框宽度要大， 右边框 宽度稍小， 其余的边框该为 0 */ border-width: 100px 50px 0 0 ; } 3.3 京东价格图 关键代码： width: 0; height: 0; border-color: transparent red transparent transparent; border-style: solid; border-width: 22px 8px 0 0; 全部代码： &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;CSS三角强化的巧妙运用&lt;/title&gt; &lt;style&gt; .price { width: 160px; height: 24px; line-height: 24px; border: 1px solid red; margin: 0 auto; } .miaosha { position: relative; float: left; width: 90px; height: 100%; background-color:red; text-align: center; color: #fff; font-weight: 700; margin-right: 8px; } .miaosha i { position: absolute; right: 0; top: 0; width: 0; height: 0; border-color: transparent #fff transparent transparent; border-style: solid; border-width: 24px 10px 0 0; } .origin { font-size: 12px; color: gray; text-decoration: line-through; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"price\"&gt; &lt;span class=\"miaosha\"&gt; ¥1650 &lt;i&gt;&lt;/i&gt; &lt;/span&gt; &lt;span class=\"origin\"&gt;¥5650&lt;/span&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 四. CSS 用户界面样式所谓的界面样式，就是更改一些用户操作样式，以便提高更好的用户体验。 更改用户的鼠标样式 表单轮廓 防止表单域拖拽 4.1 鼠标样式 cursorli {cursor: pointer; } 置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。 属性值 描述 default 小白默认 pointer 小手 move 移动 text 禁止 not-allowed 禁止 4.2 轮廓线给表单添加 outline: 0; 或者 outline: none; 样式之后，就可以去掉默认的蓝色边框。 input {outline: none; } 4.3 防止拖拽文本域 resize实际开发中，我们文本域右下角是不可以拖拽的。不然会影响一些布局 textarea{ resize: none;} 五. vertical-align 属性应用5.1 使用场景CSS 的 vertical-align 属性使用场景： 经常用于设置图片或者表单(行内块元素）和文字垂直对齐。官方解释： 用于设置一个元素的垂直对齐方式，但是它只针对于行内元素或者行内块元素有效。 语法： vertical-align : baseline | top | middle | bottom 值 描述 baseline 默认。元素放置在父元素的基线上。 top 把元素的顶端与行中最高元素的顶端对齐 middle 把此元素放置在父元素的中部。 bottom 把元素的顶端与行中最低的元素的顶端对齐。 5.2 图片、表单和文字对齐图片、表单都属于行内块元素，默认的 vertical-align 是基线对齐。 此时可以给图片、表单这些行内块元素的 vertical-align 属性设置为 middle 就可以让文字和图片垂直居中对齐了。 5.3 解决图片底部默认空白缝隙问题bug：图片底侧会有一个空白缝隙，原因是行内块元素会和文字的基线对齐。主要解决方法有两种： 给图片添加 vertical-align:middle | top| bottom 等。 （提倡使用的） 把图片转换为块级元素 display: block; 六. 溢出的文字省略号显示6.1 单行文本溢出显示省略号 单行文本溢出显示省略号–必须满足三个条件 /*1. 先强制一行内显示文本*/ white-space: nowrap; （ 默认 normal 自动换行） /*2. 超出的部分隐藏*/ overflow: hidden; /*3. 文字用省略号替代超出的部分*/ text-overflow: ellipsis; 6.2 多行文本溢出显示省略号多行文本溢出显示省略号，有较大兼容性问题， 适合于webKit浏览器或移动端（移动端大部分是webkit内核）推荐后端人员来做。 overflow: hidden; text-overflow: ellipsis; /* 弹性伸缩盒子模型显示 */ display: -webkit-box; /* 限制在一个块元素显示的文本的行数 */ -webkit-line-clamp: 2; /* 设置或检索伸缩盒对象的子元素的排列方式 */ -webkit-box-orient: vertical; 七. 常见布局技巧7.1 margin负值运用加边框的时候会有中间两个盒子边框合并的问题：1px+1px=2px 让每个盒子margin 往左侧移动 -1px 正好压住相邻盒子边框 鼠标经过某个盒子的时候，提高当前盒子的层级即可（如果没有有定位，则加相对定位（保留位置），如果有定位，则加z-index） 这里建议使用margin-right &lt;style&gt; /* * { margin: 0; padding: 0; } */ ul li { position: relative;/*如果没有可让鼠标经过加相对定位，否则提高层级 float: left; list-style: none; width: 150px; height: 200px; border: 1px solid red; margin-right:-1px; } /* ul li:hover { 1. 如果盒子没有定位，则鼠标经过添加相对定位即可 position: relative; border: 1px solid blue; } */ ul li:hover { /* 2.如果li都有定位，则利用 z-index提高层级 */ z-index: 1; border: 1px solid blue; } &lt;/style&gt; 7.2 文字围绕浮动元素 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;文字围绕浮动元素的妙用&lt;/title&gt; &lt;style&gt; * { margin: 0; padding: 0; } .box { width: 300px; height: 70px; background-color: pink; margin: 0 auto; padding: 5px; } .pic { float: left; width: 120px; height: 60px; margin-right: 5px; } .pic img { width: 100%; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"box\"&gt; &lt;div class=\"pic\"&gt; &lt;img src=\"images/img.png\" alt=\"\"&gt; &lt;/div&gt; &lt;p&gt;【集锦】热身赛-巴西0-1秘鲁 内马尔替补两人血染赛场&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 7.3 行内块巧妙运用 页码在页面中间显示: 把这些链接盒子转换为行内块， 之后给父级指定 text-align:center; 利用行内块元素中间有缝隙，并且给父级添加 text-align:center; 行内块元素会水平会居中 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;行内块的巧妙运用&lt;/title&gt; &lt;style&gt; * { margin: 0; padding: 0; } .box { /* text-align: center; */ } .box a { display: inline-block; width: 36px; height: 36px; background-color: #f7f7f7; border: 1px solid #ccc; text-align: center; line-height: 36px; text-decoration: none; color: #333; font-size: 14px; } .box .prev, .box .next { width: 85px; } .box .current, .box .elp { background-color: #fff; border: none; } .box input { height: 36px; width: 45px; border: 1px solid #ccc; outline: none; } .box button { width: 60px; height: 36px; background-color: #f7f7f7; border: 1px solid #ccc; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"box\"&gt; &lt;a href=\"#\" class=\"prev\"&gt;&amp;lt;&amp;lt;上一页&lt;/a&gt; &lt;a href=\"#\" class=\"current\"&gt;2&lt;/a&gt; &lt;a href=\"#\"&gt;3&lt;/a&gt; &lt;a href=\"#\"&gt;4&lt;/a&gt; &lt;a href=\"#\"&gt;5&lt;/a&gt; &lt;a href=\"#\"&gt;6&lt;/a&gt; &lt;a href=\"#\" class=\"elp\"&gt;...&lt;/a&gt; &lt;a href=\"#\" class=\"next\"&gt;&amp;gt;&amp;gt;下一页&lt;/a&gt; 到第 &lt;input type=\"text\"&gt; 页 &lt;button&gt;确定&lt;/button&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 八. CSS页面初始化不同浏览器对有些标签的默认值是不同的，为了消除不同浏览器对HTML文本呈现的差异，照顾浏览器的兼容，我们需要对CSS 初始化简单理解： CSS初始化是指重设浏览器的样式。 (也称为CSS reset）每个网页都必须首先进行 CSS初始化。这里我们以 京东CSS初始化代码为例。Unicode编码字体：把中文字体的名称用相应的Unicode编码来代替，这样就可以有效的避免浏览器解释CSS代码时候出现乱码的问题。比如： 黑体 \\9ED1\\4F53 宋体 \\5B8B\\4F53 微软雅黑 \\5FAE\\8F6F\\96C5\\9ED1 /* 把我们所有标签的内外边距清零 */ * { margin: 0; padding: 0 } /* em 和 i 斜体的文字不倾斜 */ em, i { font-style: normal } /* 去掉li 的小圆点 */ li { list-style: none } img { /* border 0 照顾低版本浏览器 如果 图片外面包含了链接会有边框的问题 */ border: 0; /* 取消图片底侧有空白缝隙的问题 */ vertical-align: middle } button { /* 当我们鼠标经过button 按钮的时候，鼠标变成小手 */ cursor: pointer } a { color: #666; text-decoration: none } a:hover { color: #c81623 } button, input { /* \"\\5B8B\\4F53\" 就是宋体的意思 这样浏览器兼容性比较好 */ font-family: Microsoft YaHei, Heiti SC, tahoma, arial, Hiragino Sans GB, \"\\5B8B\\4F53\", sans-serif } body { /* CSS3 抗锯齿形 让文字显示的更加清晰 */ -webkit-font-smoothing: antialiased; background-color: #fff; font: 12px/1.5 Microsoft YaHei, Heiti SC, tahoma, arial, Hiragino Sans GB, \"\\5B8B\\4F53\", sans-serif; color: #666 } .hide, .none { display: none } /* 清除浮动 */ .clearfix:after { visibility: hidden; clear: both; display: block; content: \".\"; height: 0 } .clearfix { *zoom: 1 }","categories":[{"name":"技能之树","slug":"技能之树","permalink":"https://bingshanyishu.github.io/categories/%E6%8A%80%E8%83%BD%E4%B9%8B%E6%A0%91/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://bingshanyishu.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"CSS","permalink":"https://bingshanyishu.github.io/tags/CSS/"}],"author":"Sankey"},{"title":"定位是什么，元素怎么显示隐藏","slug":"定位是什么，元素怎么显示隐藏","date":"2022-03-12T13:39:15.000Z","updated":"2022-03-12T13:48:58.809Z","comments":true,"path":"posts/202203122139.html","link":"","permalink":"https://bingshanyishu.github.io/posts/202203122139.html","excerpt":"","text":"定位是什么，元素怎么显示隐藏博客园主页：博客园主页-冰山一树SankeyCSDN主页：CSDN主页-冰山一树Sankey 前端学习：学习地址：黑马程序员pink老师前端入门教程，零基础必看的h5(html5)+css3+移动，下面这些都是一些学习笔记。临渊羡鱼，不如退而结网！！愿我自己学有所成，也愿每个前端爱好者学有所成 一. 定位1.1 为什么需要定位提问： 以下情况使用标准流或者浮动能实现吗？ 某个元素可以自由的在一个盒子内移动位置，并且压住其他盒子. 当我们滚动窗口的时候，盒子是固定屏幕某个位置的。 以上效果，标准流或浮动都无法快速实现，此时需要定位来实现。浮动与定位区别： 浮动可以让多个块级盒子一行没有缝隙排列显示， 经常用于横向排列盒子。 定位则是可以让盒子自由的在某个盒子内移动位置或者固定屏幕中某个位置，并且可以压住其他盒子。 1.2 定位组成定位：将盒子定在某一个位置，所以定位也是在摆放盒子， 按照定位的方式移动盒子。定位 = 定位模式 + 边偏移 。定位模式用于指定一个元素在文档中的定位方式。边偏移则决定了该元素的最终位置。 定位模式： 定位模式决定元素的定位方式 ，它通过 CSS 的 position 属性来设置，其值可以分为四个： 值 语义 static 静态定位 relative 相对定位 absolute 绝对定位 fixed 固定定位 边偏移： 边偏移就是定位的盒子移动到最终位置。有 top、bottom、left 和 right 4 个属性。 边偏移属性 示例 描述 top top:80px 顶端偏移量,定义元素相对于其父元素上边线的距离。 bottom bottom:80px 底部偏移量,定义元素相对于其父元素下边线的距离。 left left:80px 左侧偏移量,定义元素相对于其父元素左边线的距离。 right right:80px 右侧偏移量,定义元素相对于其父元素右边线的距离 1.3 静态定位静态定位是元素的默认定位方式，无定位的意思。语法： 选择器 { position: static; } 静态定位按照标准流特性摆放位置，它没有边偏移 静态定位在布局时很少用到 1.4 相对定位相对定位是元素在移动位置的时候，是相对于它原来的位置来说的。 语法： 选择器 { position: relative; } 相对定位的特点： 它是相对于自己原来的位置来移动的（移动位置的时候参照点是自己原来的位置）。 原来在标准流的位置继续占有，后面的盒子仍然以标准流的方式对待它。因此，相对定位并没有脱标。它最典型的应用是给绝对定位当爹的。。。 1.5 绝对定位绝对定位是元素在移动位置的时候，是相对于它祖先元素来说的（拼爹型）。 语法： 选择器 { position: absolute; } 绝对定位的特点： 如果没有祖先元素或者祖先元素没有定位，则以浏览器为准定位（Document 文档）。 如果祖先元素有定位（相对、绝对、固定定位），则以最近一级的有定位祖先元素为参考点移动位置。 绝对定位不再占有原先的位置。所以绝对定位是脱离标准流的。 1.6 子绝父相“子绝父相”是定位中最常用的一种方式，这句话的意思是：子级是绝对定位的话，父级要用相对定位。 子级绝对定位，不会占有位置，可以放到父盒子里面的任何一个地方，不会影响其他的兄弟盒子。 父盒子需要加定位限制子盒子在父盒子内显示。 父盒子布局时，需要占有位置，因此父亲只能是相对定位。 总结： 因为父级需要占有位置，因此是相对定位， 子盒子不需要占有位置，则是绝对定位当然，子绝父相不是永远不变的，如果父元素不需要占有位置，子绝父绝也会遇到。 1.7 固定定位固定定位是元素固定于浏览器可视区的位置。主要使用场景： 可以在浏览器页面滚动时元素的位置不会改变。 语法： 选择器 { position: fixed; } 固定定位的特点： 以浏览器的可视窗口为参照点移动元素。 跟父元素没有任何关系 不随滚动条滚动。 固定定位不在占有原先的位置。 固定定位也是脱标的，其实固定定位也可以看做是一种特殊的绝对定位。 固定定位小技巧： 固定在版心右侧位置。 小算法： 让固定定位的盒子 left: 50%. 走到浏览器可视区（也可以看做版心） 的一半位置。 让固定定位的盒子 margin-left: 版心宽度的一半距离。 多走 版心宽度的一半位置 就可以让固定定位的盒子贴着版心右侧对齐了。 position: fixed; /* 1. 走浏览器宽度的一半 */ left: 50%; /* 2. 利用margin 走版心盒子宽度的一半距离 */ margin-left: 405px; 1.8 粘性定位粘性定位可以被认为是相对定位和固定定位的混合。 Sticky 粘性的语法： 选择器 { position: sticky; top: 10px; } 粘性定位的特点： 以浏览器的可视窗口为参照点移动元素（固定定位特点） 粘性定位占有原先的位置（相对定位特点） 必须添加 top 、left、right、bottom 其中一个才有效跟页面滚动搭配使用。 兼容性较差，IE 不支持。 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;粘性定位&lt;/title&gt; &lt;style&gt; body { height: 3000px; } .nav { /* 粘性定位 */ position: sticky; top: 0; width: 800px; height: 50px; background-color: pink; margin: 100px auto; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"nav\"&gt;我是导航栏&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 当滑动页面到当这个盒子TOP=0后，变成固定定位，保持也页面上方 定位总结 1.9 定位叠放次序 z-index在使用定位布局时，可能会出现盒子重叠的情况。此时，可以使用 z-index 来控制盒子的前后次序 (z轴) 语法： 选择器 { z-index: 1; } 数值可以是正整数、负整数或 0, 默认是 auto，数值越大，盒子越靠上 如果属性值相同，则按照书写顺序，后来居上 数字后面不能加单位 只有定位的盒子才有 z-index 属性 二. 定位的拓展2.1 绝对定位的盒子居中 加了绝对定位的盒子不能通过 margin:0 auto; 水平居中，但是可以通过以下计算方法实现水平和垂直居中。 ① left: 50%;：让盒子的左侧移动到父级元素的水平中心位置。② margin-left: -100px;：让盒子向左移动自身宽度的一半。 .box { position: absolute; /* 1. left 走 50% 父容器宽度的一半 */ left: 50%; /* 2. margin 负值 往左边走 自己盒子宽度的一半 */ margin-left: -100px; /*垂直居中 top: 50%; margin-top: -100px; width: 200px; height: 200px; background-color: pink; /* margin: auto; */ } 2.2. 定位特殊特性绝对定位和固定定位也和浮动类似。 行内元素添加绝对或者固定定位，可以直接设置高度和宽度。 块级元素添加绝对或者固定定位，如果不给宽度或者高度，默认大小是内容的大小 浮动元素、绝对定位(固定定位）元素的都不会触发外边距合并(外边距塌陷 )的问题。 2.3 绝对定位（固定定位）会完全压住盒子浮动元素不同，只会压住它下面标准流的盒子，但是不会压住下面标准流盒子里面的文字（图片）但是绝对定位（固定定位） 会压住下面标准流所有的内容。浮动之所以不会压住文字，因为浮动产生的目的最初是为了做文字环绕效果的。 文字会围绕浮动元素 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;定位会完全压住标准流盒子内容&lt;/title&gt; &lt;style&gt; .box { /* 1.浮动的元素不会压住下面标准流的文字 */ /* float: left; */ /* 2. 绝对定位（固定定位） 会压住下面标准流所有的内容。 */ position: absolute; width: 150px; height: 150px; background-color: pink; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;p&gt;阁下何不同风起，扶摇直上九万里&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 总结通过盒子模型，清楚知道大部分html标签是一个盒子。 通过CSS浮动、定位 可以让每个盒子排列成为网页。 一个完整的网页，是标准流、浮动、定位一起完成布局的，每个都有自己的专门用法。 标准流可以让盒子上下排列或者左右排列，垂直的块级盒子显示就用标准流布局。 浮动可以让多个块级元素一行显示或者左右对齐盒子，多个块级盒子水平显示就用浮动布局。 定位定位最大的特点是有层叠的概念，就是可以让多个盒子前后叠压来显示。如果元素自由在某个盒子内移动就用定位布局。 三. 元素的显示与隐藏类似网站广告，当我们点击关闭就不见了，但是我们重新刷新页面，会重新出现！本质：让一个元素在页面中隐藏或者显示出来。 display 显示隐藏 visibility 显示隐藏 overflow 溢出显示隐藏 3.1 display 属性display 属性用于设置一个元素应如何显示。 display: none ；隐藏对象 display：block ；除了转换为块级元素之外，同时还有显示元素的意思 display 隐藏元素后，不再占有原来的位置。后面应用及其广泛，搭配 JS 可以做很多的网页特效。 3.2 visibility 可见性visibility 属性用于指定一个元素应可见还是隐藏。 visibility：visible ; 元素可视 visibility：hidden; 元素隐藏 visibility 隐藏元素后，继续占有原来的位置。如果隐藏元素想要原来位置， 就用 visibility：hidden如果隐藏元素不想要原来位置， 就用 display：none (用处更多 重点） 3.3 overflow 溢出overflow 属性指定了如果内容溢出一个元素的框（超过其指定高度及宽度） 时，会发生什么。 属性值 描述 visible 不剪切内容也不添加滚动条 hidden 不显示超过对象尺寸的内容,超出的部分隐藏掉 scroll 不管超出内容否,总是显示滚动条 auto 超出自动显示滚动条,不超出不显示滚动条 一般情况下，我们都不想让溢出的内容显示出来，因为溢出的部分会影响布局。 但是如果有定位的盒子， 请慎用overflow:hidden 因为它会隐藏多余的部分。 3.4 土豆网鼠标经过显示遮罩 土豆网鼠标经过显示遮罩 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;仿土豆网显示隐藏遮罩案例&lt;/title&gt; &lt;style&gt; .tudou { position: relative; width: 444px; height: 320px; background-color: pink; margin: 30px auto; } .tudou img { width: 100%; height: 100%; } .mask { /* 隐藏遮罩层 */ display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, .4) url(images/arr.png) no-repeat center; } /* 当我们鼠标经过了 土豆这个盒子，就让里面遮罩层显示出来 */ .tudou:hover .mask { /* 而是显示元素 */ display: block; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"tudou\"&gt; &lt;div class=\"mask\"&gt;&lt;/div&gt; &lt;img src=\"images/tudou.jpg\" alt=\"\"&gt; &lt;/div&gt; &lt;div class=\"tudou\"&gt; &lt;div class=\"mask\"&gt;&lt;/div&gt; &lt;img src=\"images/tudou.jpg\" alt=\"\"&gt; &lt;/div&gt; &lt;div class=\"tudou\"&gt; &lt;div class=\"mask\"&gt;&lt;/div&gt; &lt;img src=\"images/tudou.jpg\" alt=\"\"&gt; &lt;/div&gt; &lt;div class=\"tudou\"&gt; &lt;div class=\"mask\"&gt;&lt;/div&gt; &lt;img src=\"images/tudou.jpg\" alt=\"\"&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;","categories":[{"name":"技能之树","slug":"技能之树","permalink":"https://bingshanyishu.github.io/categories/%E6%8A%80%E8%83%BD%E4%B9%8B%E6%A0%91/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://bingshanyishu.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"布局","slug":"布局","permalink":"https://bingshanyishu.github.io/tags/%E5%B8%83%E5%B1%80/"},{"name":"CSS","slug":"CSS","permalink":"https://bingshanyishu.github.io/tags/CSS/"}],"author":"Sankey"},{"title":"浮动布局，以及如何清除浮动","slug":"浮动布局，以及如何清除浮动","date":"2022-03-11T14:29:15.000Z","updated":"2022-03-11T14:38:10.560Z","comments":true,"path":"posts/202203112229.html","link":"","permalink":"https://bingshanyishu.github.io/posts/202203112229.html","excerpt":"","text":"浮动布局，以及如何清除浮动博客园主页：博客园主页-冰山一树SankeyCSDN主页：CSDN主页-冰山一树Sankey 前端学习：学习地址：黑马程序员pink老师前端入门教程，零基础必看的h5(html5)+css3+移动，下面这些都是一些学习笔记。临渊羡鱼，不如退而结网！！愿我自己学有所成，也愿每个前端爱好者学有所成 一. 浮动1.1 传统网页布局的三种方式网页布局的本质——用 CSS 来摆放盒子。 把盒子摆放到相应位置.CSS 提供了三种传统布局方式(简单说,就是盒子如何进行排列顺序)： 普通流（标准流） 浮动 定位 1.2 标准流所谓的标准流: 就是标签按照规定好默认方式排列 块级元素会独占一行，从上向下顺序排列。 常用元素：div、hr、p、h1~h6、ul、ol、dl、form、table 行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行。 常用元素：span、a、i、em 等 以上都是标准流布局，标准流是最基本的布局方式。这三种布局方式都是用来摆放盒子的，盒子摆放到合适位置，布局自然就完成了。注意：实际开发中，一个页面基本都包含了这三种布局方式（不过移动端有新的布局方式） 。 1.3 为什么需要浮动总结： 有很多的布局效果，标准流没有办法完成，此时就可以利用浮动完成布局。 因为浮动可以改变元素标签默认的排列方式.浮动最典型的应用：可以让多个块级元素一行内排列显示。网页布局第一准则：多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动。 1.4 什么是浮动float 属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘触及包含块或另一个浮动框的边缘。语法： 选择器 { float: 属性值; } 属性值 描述 none 元素不浮动(默认值) left 元素向左浮动 right 元素向右浮动 1.5 浮动特性1.5.1 脱标设置了浮动（float）的元素最重要特性： 脱离标准普通流的控制（浮） 移动到指定位置（动）, （俗称脱标） 浮动的盒子不再保留原先的位置 1.5.2 对齐排列如果多个盒子都设置了浮动，则它们会按照属性值一行内显示并且顶端对齐排列。 注意： 浮动的元素是互相贴靠在一起的（不会有缝隙），如果父级宽度装不下这些浮动的盒子， 多出的盒子会另起一行对齐。 1.5.3 行内块特性浮动元素会具有行内块元素特性。 任何元素都可以浮动。不管原先是什么模式的元素，添加浮动之后具有行内块元素相似的特性。 如果块级盒子没有设置宽度，默认宽度和父级一样宽，但是添加浮动后，它的大小根据内容来决定 浮动的盒子中间是没有缝隙的，是紧挨着一起的 行内元素同理 1.6 浮动元素和标准流父级搭配使用为了约束浮动元素位置, 我们网页布局一般采取的策略是: 先用标准流的父元素排列上下位置, 之后内部子元素采取浮动排列左右位置. 符合网页布局第一准侧. 二. 清除浮动 2.1 为什么清除浮动由于父级盒子很多情况下，不方便给高度，但是子盒子浮动又不占有位置，最后父级盒子高度为 0 时，就会影响下面的标准流盒子。 清除浮动本质 清除浮动的本质是清除浮动元素造成的影响 如果父盒子本身有高度，则不需要清除浮动 清除浮动之后，父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了 2.2 清除浮动 额外标签法也称为隔墙法，是 W3C 推荐的做法。 父级添加 overflow 属性 父级添加after伪元素 父级添加双伪元素 2.2.1 额外标签法额外标签法也称为隔墙法，是 W3C 推荐的做法。额外标签法会在浮动元素末尾添加一个空的标签。例如 &lt;div style=\"clear:both\"&gt;&lt;/div&gt;，或者其他标签（如&lt;br/&gt;等）。 选择器{clear:属性值;} 属性值 描述 left 不允许左侧有浮动元素(清除左侧浮动的影响) right 不允许右侧有浮动元素(清除右侧浮动的影响) both 同时清除左右两侧浮动的影响 优点： 通俗易懂，书写方便 缺点： 添加许多无意义的标签，结构化较差 注意： 要求这个新的空标签必须是块级元素。 2.2.2 父级添加overflow可以给父级添加 overflow 属性，将其属性值设置为 hidden、 auto 或 scroll 。子不教,父之过,注意是给父元素添加代码 优点：代码简洁 缺点：无法显示溢出的部分 2.2.3 :after 伪元素法:after 方式是额外标签法的升级版。也是给父元素添加 .clearfix:after { content: \"\"; display: block; height: 0; clear: both; visibility: hidden; } .clearfix { /* IE6、7 专有 */ *zoom: 1; } 添加这个代码，然后给主盒子添加class名clearfix 优点：没有增加标签，结构更简单 缺点：照顾低版本浏览器 代表网站： 百度、淘宝网、网易等 2.2.4 双伪元素清除浮动也是给给父元素添加 .clearfix:before,.clearfix:after { content:\"\"; display:table; } .clearfix:after { clear:both; } .clearfix { *zoom:1; } 优点：代码更简洁 缺点：照顾低版本浏览器 代表网站：小米、腾讯等 三. 常见网页布局 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;常见网页布局&lt;/title&gt; &lt;style&gt; * { margin: 0; padding: 0; } li { list-style: none; } .top { height: 50px; background-color: gray; } .banner { width: 980px; height: 150px; background-color: gray; margin: 10px auto; } .box { width: 980px; margin: 0 auto; height: 300px; background-color: pink; } .box li { float: left; width: 237px; height: 300px; background-color: gray; margin-right: 10px; } .box .last { margin-right: 0; } /* 只要是通栏的盒子(和浏览器一样宽) 不需要指定宽度 */ .footer { height: 200px; background-color: gray; margin-top: 10px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"top\"&gt;top&lt;/div&gt; &lt;div class=\"banner\"&gt;banner&lt;/div&gt; &lt;div class=\"box\"&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li class=\"last\"&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt;footer&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 常见布局注意点 浮动和标准流的父盒子搭配。 先用标准流的父元素排列上下位置, 之后内部子元素采取浮动排列左右位置 一个元素浮动了，理论上其余的兄弟元素也要浮动。 一个盒子里面有多个子盒子，如果其中一个盒子浮动了，那么其他兄弟也应该浮动，以防止引起问题。 浮动的盒子只会影响浮动盒子后面的标准流,不会影响前面的标准流. 四. CSS 属性书写顺序建议遵循以下顺序（书写优先级由上到下）： 属性类型 具体属性 布局定位属性 display / position / float / clear / visibility / overflow（建议 display 第一个写，毕竟关系到模式） 自身属性 width / height / margin / padding / border / background 文本属性 color / font / text-decoration / text-align / vertical-align / white- space / break-word 其他属性（CSS3） content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient …","categories":[{"name":"技能之树","slug":"技能之树","permalink":"https://bingshanyishu.github.io/categories/%E6%8A%80%E8%83%BD%E4%B9%8B%E6%A0%91/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://bingshanyishu.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"布局","slug":"布局","permalink":"https://bingshanyishu.github.io/tags/%E5%B8%83%E5%B1%80/"},{"name":"CSS","slug":"CSS","permalink":"https://bingshanyishu.github.io/tags/CSS/"}],"author":"Sankey"},{"title":"网页的盒子模型是什么？怎么设置盒子样式","slug":"网页的盒子模型是什么？怎么设置盒子样式","date":"2022-03-11T14:18:11.000Z","updated":"2022-03-11T14:38:19.793Z","comments":true,"path":"posts/202203112218.html","link":"","permalink":"https://bingshanyishu.github.io/posts/202203112218.html","excerpt":"","text":"网页的盒子模型是什么？怎么设置盒子样式博客园主页：博客园主页-冰山一树SankeyCSDN主页：CSDN主页-冰山一树Sankey 前端学习：学习地址：黑马程序员pink老师前端入门教程，零基础必看的h5(html5)+css3+移动，下面这些都是一些学习笔记。临渊羡鱼，不如退而结网！！愿我自己学有所成，也愿每个前端爱好者学有所成 一. CSS三大特性 层叠性 继承性 优先级 具体可参考CSS 三大特性 二. 盒子模型页面布局要学习三大核心, 盒子模型, 浮动 和 定位. 学习好盒子模型能非常好的帮助我们布局页面 2.1 看透网页组成的本质网页布局的核心本质： 就是利用 CSS 摆盒子。 网页布局过程： 先准备好相关的网页元素，网页元素基本都是盒子 Box 。 利用 CSS 设置好盒子样式，然后摆放到相应位置。 往盒子里面装内容. 2.2 盒子模型组成所谓 盒子模型：就是把 HTML 页面中的布局元素看作是一个矩形的盒子，也就是一个盛装内容的容器。 CSS 盒子模型本质上是一个盒子，封装周围的 HTML 元素，它包括：边框、外边距、内边距、和 实际内容 2.3 边框 border可以设置元素的边框。边框有三部分组成:边框宽度(粗细) 边框样式 边框颜色 border : border-width || border-style || border-color 属性 作用 border-width 定义边框粗细,单位是px border-style 边框的样式 border-color 边框颜色 边框样式 border-style 可以设置如下值： none：没有边框即忽略所有边框的宽度（默认值） solid：边框为单实线(最为常用的) dashed：边框为虚线 dotted：边框为点线 边框简写： border: 1px solid red; 没有顺序 边框分开写法： border-top: 1px solid red; /* 只设定上边框， 其余同理 */ border-collapse 属性控制浏览器绘制表格边框的方式。它控制相邻单元格的边框。 语法： border-collapse:collapse; collapse 单词是合并的意思 border-collapse: collapse; 表示相邻边框合并在一起 注意：边框会额外增加盒子的实际大小。有两种方案解决: 测量盒子大小的时候,不量边框. 如果测量的时候包含了边框,则需要 width/height 减去边框宽度 2.4 内边距padding 属性用于设置内边距，即边框与内容之间的距离。 属性 作用 padding-left 左内边距 padding-right 右内边距 padding-top 上内边距 padding-bottom 下内边距 padding 属性（简写属性）可以有一到四个值。 值的个数 表达意思 padding:5px; 1个值,代表上下左右都有5像素内边距; padding:5px 10px; 2个值,代表上下内边距是5像素左右内边距是10像素; padding:5px 10px 20px; 3个值,代表上内边距5像素左右内边距10像素下内边距20像素; padding:5px 10px 20px 30px; 4个值,上是5像素右10像素下20像素左是30像素 顺时针 注意： 当我们给盒子指定 padding 值之后： 内容和边框有了距离，添加了内边距。 padding影响了盒子实际大小。 也就是说，如果盒子已经有了宽度和高度，此时再指定内边框，会撑大盒子。 如果盒子本身没有指定width/height属性, 则此时padding不会撑开盒子大小. 解决方案： 如果保证盒子跟效果图大小保持一致，则让 width/height 减去多出来的内边距大小即可。 案例 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;新浪导航&lt;/title&gt; &lt;style&gt; .nav { height: 41px; border-top: 3px solid #ff8500; border-bottom: 1px solid #edeef0; background-color: #fcfcfc; line-height: 41px; } .nav a { /* a属于行内元素 此时必须要转换 行内块元素 */ display: inline-block; height: 41px; padding: 0 20px; font-size: 12px; color: #4c4c4c; text-decoration: none; } .nav a:hover { background-color: #eee; color: #ff8500; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"nav\"&gt; &lt;a href=\"#\"&gt;新浪导航&lt;/a&gt; &lt;a href=\"#\"&gt;手机新浪网&lt;/a&gt; &lt;a href=\"#\"&gt;移动客户端&lt;/a&gt; &lt;a href=\"#\"&gt;微博&lt;/a&gt; &lt;a href=\"#\"&gt;三个字&lt;/a&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 2.5 外边距margin 属性用于设置外边距，即控制盒子和盒子之间的距离。 属性 作用 margin-left 左外边距 margin-right 右外边距 margin-top 上外边距 margin-bottom 下外边距 2.6 块盒子水平居中外边距可以让块级盒子水平居中，但是必须满足两个条件： 盒子必须指定了宽度（width）。 盒子左右的外边距都设置为 auto 。 .header{ width:960px; margin:0 auto; } 常见的写法，以下三种都可以： margin-left: auto; margin-right: auto; margin: auto; margin: 0 auto; 注意：以上方法是让块级元素水平居中，行内元素或者行内块元素水平居中给其父元素添加 text-align:center 即可。 2.7 外边距合并2.7.1 相邻块元素垂直外边距的合并当上下相邻的两个块元素（兄弟关系）相遇时，如果上面的元素有下外边距 margin-bottom，下面的元素有上外边距 margin-top ，则他们之间的垂直间距不是 margin-bottom 与 margin-top 之和。取两个值中的较大者这种现象被称为相邻块元素垂直外边距的合并。 解决方案：尽量只给一个盒子添加 margin 值。 2.7.2 嵌套块元素垂直外边距的塌陷对于两个嵌套关系（父子关系）的块元素，父元素有上外边距同时子元素也有上外边距，此时父元素会塌陷较大的外边距值。 解决方案： 可以为父元素定义上边框。 可以为父元素定义上内边距。 可以为父元素添加 overflow:hidden。 还有其他方法，比如浮动、固定，绝对定位的盒子不会有塌陷问题。后续会有讲解 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;外边距合并-嵌套块级元素垂直外边距塌陷&lt;/title&gt; &lt;style&gt; .father { width: 400px; height: 400px; background-color: purple; /* 可修改margin-top值进行观察 */ margin-top: 150px; /* border: 1px solid red; */ /* border: 1px solid transparent; */ /* padding: 1px; */ overflow: hidden; } .son { width: 200px; height: 200px; background-color: pink; margin-top: 100px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"father\"&gt; &lt;div class=\"son\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 2.7 清除内外边距网页元素很多都带有默认的内外边距，而且不同浏览器默认的也不一致。因此我们在布局前，首先要清除下网页元素的内外边距。 * { padding:0; /* 清除内边距 */ margin:0; /* 清除外边距 */ } 注意：行内元素为了照顾兼容性，尽量只设置左右内外边距，不要设置上下内外边距。但是转换为块级和行内块元素就可以了 2.8 综合案例和总结 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;综合案例-产品模块&lt;/title&gt; &lt;style&gt; * { margin: 0; padding: 0; } body { background-color: #f5f5f5; } a { color: #333; text-decoration: none; } .box { width: 298px; height: 415px; background-color:#fff; /* 让块级的盒子水平居中对齐 */ margin: 100px auto; } .box img { /* 图片的宽度和父亲一样宽 */ width: 100%; } .review { height: 70px; font-size: 14px; /* 因为这个段落没有 width属性 所有 padding不会撑开盒子的宽度 */ padding: 0 28px; margin-top: 30px; } .appraise { font-size: 12px; color: #b0b0b0; margin-top: 20px; padding: 0 28px; } .info { font-size: 14px; margin-top: 15px; padding: 0 28px; } .info h4 { display: inline-block; font-weight: 400; } .info span { color: #ff6700; } .info em { font-style: normal; color: #ebe4e0; margin: 0 6px 0 15px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"box\"&gt; &lt;img src=\"images/img.jpg\" alt=\"\"&gt; &lt;p class=\"review\"&gt;快递牛，整体不错蓝牙可以说秒连。红米给力&lt;/p&gt; &lt;div class=\"appraise\"&gt;来自于 117384232 的评价&lt;/div&gt; &lt;div class=\"info\"&gt; &lt;h4&gt; &lt;a href=\"#\"&gt;Redmi AirDots真无线蓝...&lt;/a&gt;&lt;/h4&gt; &lt;em&gt;|&lt;/em&gt; &lt;span&gt; 99.9元&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 一些问题： 布局为啥用不同盒子,我只想用div？ 标签都是有语义的, 合理的地方用合理的标签。比如产品标题 就用 h, 大量文字段落就用p 为啥用辣么多类名？ 类名就是给每个盒子起了一个名字,可以更好的找到这个盒子, 选取盒子更容易,后期维护也方便。 到底用 margin 还是 padding？ 大部分情况两个可以混用，两者各有优缺点，但是根据实际情况，总是有更简单的方法实现。 自己做没有思路？ 布局有很多种实现方式，同学们可以开始先模仿我的写法，然后再做出自己的风格。 最后同学们一定多运用辅助工具,比如屏幕画笔,ps等等 三. 盒子其他样式3.1 圆角边框在 CSS3 中，新增了圆角边框样式。 border-radius 属性用于设置元素的外边框圆角。 border-radius:length; 参数值可以为数值或百分比的形式 如果是正方形，想要设置为一个圆，把数值修改为高度或者宽度的一半即可，或者直接写为 50% 该属性是一个简写属性，可以跟四个值，分别代表左上角、右上角、右下角、左下角 也可以跟四个值，分别代表两个对角线 分开写：border-top-left-radius、border-top-right-radius、border-bottom-right-radius 和 border-bottom-left-radius 兼容性 ie9+ 浏览器支持, 但是不会影响页面布局,可以放心使用. 3.2 盒子阴影CSS3 中新增了盒子阴影，我们可以使用 box-shadow 属性为盒子添加阴影 box-shadow: h-shadow v-shadow blur spread color inset; 值 描述 h-shadow 必需。水平阴影的位置。允许负值。 v-shadow 必需。垂直阴影的位置。允许负值。 blur 可选。模糊距离。 spread 可选。阴影的尺寸。 color 可选。阴影的颜色。请参阅CSS颜色值。 inset 可选。将外部阴影(outset)改为内部阴影。 注意： 默认的是外阴影(outset), 但是不可以写这个单词,否则造成阴影无效 盒子阴影不占用空间，不会影响其他盒子排列。 3.3 文字阴影在 CSS3 中，我们可以使用 text-shadow 属性将阴影应用于文本。语法： text-shadow: h-shadow v-shadow blur color; 值 描述 h-shadow 必需。水平阴影的位置。允许负值。 v-shadow 必需。垂直阴影的位置。允许负值。 blur 可选。模糊距离。 color 可选。阴影的颜色。请参阅CSS颜色值。","categories":[{"name":"技能之树","slug":"技能之树","permalink":"https://bingshanyishu.github.io/categories/%E6%8A%80%E8%83%BD%E4%B9%8B%E6%A0%91/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://bingshanyishu.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"CSS","permalink":"https://bingshanyishu.github.io/tags/CSS/"}],"author":"Sankey"},{"title":"CSS复合选择器，元素的显示模式，CSS背景设置","slug":"CSS复合选择器，元素的显示模式，CSS背景设置","date":"2022-03-11T08:33:43.000Z","updated":"2022-03-11T14:14:02.257Z","comments":true,"path":"posts/20220311163343.html","link":"","permalink":"https://bingshanyishu.github.io/posts/20220311163343.html","excerpt":"","text":"CSS复合选择器，元素的显示模式，CSS背景设置博客园主页：博客园主页-冰山一树SankeyCSDN主页：CSDN主页-冰山一树Sankey 前端学习：学习地址：黑马程序员pink老师前端入门教程，零基础必看的h5(html5)+css3+移动，下面这些都是一些学习笔记。临渊羡鱼，不如退而结网！！愿我自己学有所成，也愿每个前端爱好者学有所成 一. Emmet语法Emmet语法前身是Zen coding,它使用缩写来提高html/css的编写速度，Vscode内部已经集成该语法。 快速生成HTML/CSS结构语法： 生成标签，直接输入标签名按tab键即可比如div 然后tab键，就可以生成&lt;div&gt;&lt;/div&gt; 如果想要生成多个相同标签加上*就可以了 比如 div*3就可以快速生成3个div 如果有父子级关系的标签，可以用&gt;比如 ul&gt;li就可以了 如果有兄弟关系的标签，用+就可以了比如div+p 如果生成带有类名或者id名字的，直接写.dema 或者 #two tab键就可以了 如果生成的div类名是有顺序的，可以用自增符号$ 如果想要在生成的标签内部写内容可以用{}表示 二. 复合选择器在 CSS 中，可以根据选择器的类型把选择器分为基础选择器和复合选择器，复合选择器是建立在基础选择器之上，对基本选择器进行组合形成的。 复合选择器可以更准确、更高效的选择目标元素（标签） 复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的 常用的复合选择器包括：后代选择器、子选择器、并集选择器、伪类选择器等等 2.1 后代选择器后代选择器又称为包含选择器，可以选择父元素里面子元素。其写法就是把外层标签写在前面，内层标签写在 后面，中间用空格分隔。当标签发生嵌套时，内层标签就成为外层标签的后代。 元素1 元素2 { 样式声明 } 上述语法表示选择元素 1 里面的所有元素 2 (后代元素)。 /* 选择 ul 里面所有的 li标签元素 */ ul li { 样式声明 } 元素1 和 元素2 中间用空格隔开 元素1 是父级，元素2 是子级，最终选择的是元素2 元素2 可以是儿子，也可以是孙子等，只要是元素1 的后代即可 元素1 和 元素2 可以是任意基础选择器 2.2 子选择器子元素选择器（子选择器）只能选择作为某元素的最近一级子元素。简单理解就是选亲儿子元素 元素1 &gt; 元素2 { 样式声明 } 上述语法表示选择元素1 里面的所有直接后代(子元素) 元素2。 /* 选择 div 里面所有最近一级 p 标签元素 */ div &gt; p { 样式声明 } 元素1 和 元素2 中间用 大于号 隔开 元素1 是父级，元素2 是子级，最终选择的是元素2 元素2 必须是亲儿子，其孙子、重孙之类都不归他管. 你也可以叫他 亲儿子选择器 将下面的链接文字修改为红色。 &lt;div class=\"nav\"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;百度&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;百度&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;style&gt; .nav ul li a { color: red; } &lt;/style&gt; 将下面的大肘子文字修改为红色。 &lt;div class=\"hot\"&gt; &lt;a href=\"#\"&gt;大肘子&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;猪头&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;猪尾巴&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;style&gt; .hot&gt;a { color: red; } &lt;/style&gt; 2.3 并集选择器并集选择器可以选择多组标签, 同时为他们定义相同的样式。通常用于集体声明.并集选择器是各选择器通过英文逗号（,）连接而成，任何形式的选择器都可以作为并集选择器的一部分。 元素1,元素2 { 样式声明 } 上述语法表示选择元素1 和 元素2。 /* 选择 ul 和 div标签元素 */ ul,div { 样式声明 } 元素1 和 元素2 中间用逗号隔开 逗号可以理解为和的意思 并集选择器通常用于集体声明 2.4 伪类选择器伪类选择器用于向某些选择器添加特殊的效果，比如给链接添加特殊效果，或选择第1个，第n个元素。伪类选择器书写最大的特点是用冒号（:）表示，比如 :hover 、 :first-child 。因为伪类选择器很多，比如有链接伪类、结构伪类等，所以这里先给大家讲解常用的链接伪类选择器。 2.4.1 链接伪类选择器&lt;style&gt; /* 1.未访问的链接 a:link 把没有点击过的(访问过的)链接选出来 */ a:link { color: #333; text-decoration: none; } /*2. a:visited 选择点击过的(访问过的)链接 */ a:visited { color: orange; } /*3. a:hover 选择鼠标经过的那个链接 */ a:hover { color: skyblue; } /* 4. a:active 选择的是我们鼠标正在按下还没有弹起鼠标的那个链接 */ a:active { color: green; } &lt;/style&gt; 链接伪类选择器注意事项 为了确保生效，请按照 LVHA 的循顺序声明 :link－:visited－:hover－:active。 记忆法：love hate 或者 lv 包包 hao 。 因为 a 链接在浏览器中具有默认样式，所以我们实际工作中都需要给链接单独指定样式。 2.4.2 :focus伪类选择器:focus 伪类选择器用于选取获得焦点的表单元素。焦点就是光标，一般情况 &lt;input&gt; 类表单元素才能获取，因此这个选择器也主要针对于表单元素来说。 input:focus { background-color:yellow; } 三. 元素的显示模式3.1 什么是元素显示模式网页的标签非常多，在不同地方会用到不同类型的标签，了解他们的特点可以更好的布局我们的网页。 元素显示模式就是元素（标签）以什么方式进行显示，比如&lt;div&gt;自己占一行，比如一行可以放多个&lt;span&gt;。 HTML 元素一般分为块元素和行内元素两种类型 元素模式 元素排列 设置样式 默认宽度 包含 块级元素 一行只能放一个块级元素 可以设置宽度高度 容器的100% 容器级可以包含任何标签 行内元素 一行可以放多个行内元素 不可以直接设置宽度和高度 它本身内容的宽容 容纳文本或则其他行内元素 行内块元素 一行放多个行内块元素 可以设置宽度和高度 它本身内容的宽容 3.2 块元素常见的块元素有&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;等，其中 &lt;div&gt; 标签是最典型的块元素。 块级元素的特点： 比较霸道，自己独占一行。 高度，宽度、外边距以及内边距都可以控制。 宽度默认是容器（父级宽度）的100%。 是一个容器及盒子，里面可以放行内或者块级元素。 注意： 文字类的元素内不能使用块级元素 &lt;p&gt; 标签主要用于存放文字，因此 &lt;p&gt; 里面不能放块级元素，特别是不能放&lt;div&gt; 同理， &lt;h1&gt;~&lt;h6&gt;等都是文字类块级标签，里面也不能放其他块级元素 3.3 行内元素常见的行内元素有 &lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt;等，其中&lt;span&gt; 标签是最典型的行内元素。有的地方也将行内元素称为内联元素。 行内元素的特点： 相邻行内元素在一行上，一行可以显示多个。 高、宽直接设置是无效的。 默认宽度就是它本身内容的宽度。 行内元素只能容纳文本或其他行内元素。 注意： 链接里面不能再放链接 特殊情况链接 &lt;a&gt; 里面可以放块级元素，但是给 &lt;a&gt; 转换一下块级模式最安全 3.4 行内块元素在行内元素中有几个特殊的标签 —— &lt;img/&gt;、&lt;input/&gt;、&lt;td&gt;，它们同时具有块元素和行内元素的特点。有些资料称它们为行内块元素。 行内块元素的特点： 和相邻行内元素（行内块）在一行上，但是他们之间会有空白缝隙。一行可以显示多个（行内元素特点）。 默认宽度就是它本身内容的宽度（行内元素特点）。 高度，行高、外边距以及内边距都可以控制（块级元素特点） 3.5 元素显示模式转换特殊情况下，我们需要元素模式的转换，简单理解: 一个模式的元素需要另外一种模式的特性比如想要增加链接 &lt;a&gt; 的触发范围。 转换为块元素：display:block; 转换为行内元素：display:inline; 转换为行内块：display: inline-block; 案例： &lt;style&gt; /* 1. 把a转换为块级元素 */ a { display: block; width: 230px; height: 40px; background-color: #55585a; font-size: 14px; color: #fff; text-decoration: none; text-indent: 2em; line-height: 40px; } /* 2 鼠标经过链接变换背景颜色 */ a:hover { background-color: #ff6700; } &lt;/style&gt; &lt;body&gt; &lt;a href=\"#\"&gt;手机 电话卡&lt;/a&gt; &lt;a href=\"#\"&gt;电视 盒子&lt;/a&gt; &lt;a href=\"#\"&gt;笔记本 平板&lt;/a&gt; &lt;a href=\"#\"&gt;出行 穿戴&lt;/a&gt; &lt;a href=\"#\"&gt;智能 路由器&lt;/a&gt; &lt;a href=\"#\"&gt;健康 儿童&lt;/a&gt; &lt;a href=\"#\"&gt;耳机 音响&lt;/a&gt; &lt;/body&gt; 3.5 单行文字垂直居中CSS 没有提供文字垂直居中的代码. 但可以使用一个小技巧来实现.解决方案: 让文字的行高等于盒子的高度 就可以让文字在当前盒子内垂直居中 垂直居中的原理： line-height: 40px; 四. CSS的背景通过 CSS 背景属性，可以给页面元素添加背景样式。背景属性可以设置背景颜色、背景图片、背景平铺、背景图片位置、背景图像固定等。 属性 作用 值 background-color 背景颜色 预定义的颜色值/十六进制/RGB代码 background-image 背景图片 url(图片路径) background-repeat 是否平铺 repeat/no-repeat/repeat-x/repeat-y background-position 背景位置 length/position分别是x和y坐标 background-attachment 背景附着 scroll(背景滚动)fxed(背景固定) 背景颜色半透明 背景颜色半透明 background:rgba(0,0,0,0.3):后面必须是4个值 背景简写 书写更简单 背景颜色 背景图片地址 背景平铺 背景滚动 背景位置; 中间空格隔开 接下来我们看看具体怎么使用 4.1 背景颜色background-color 属性定义了元素的背景颜色。 background-color:颜色值; 一般情况下元素背景颜色默认值是 transparent（透明），我们也可以手动指定背景颜色为透明色。 background-color:transparent; 4.2 背景图片background-image 属性描述了元素的背景图像。实际开发常见于 logo 或者一些装饰性的小图片或者是超大的背景图片, 优点是非常便于控制位置. (精灵图也是一种运用场景) background-image : none | url (url) 参数值 作用 none 无背景图(默认的) url 使用绝对或相对地址指定背景图像 注意： 路径必须加引号 路径还必须是相对路径，绝对路径无法加载图片。 4.3 背景平铺如果需要在 HTML 页面上对背景图像进行平铺，可以使用 background-repeat 属性。 background-repeat: repeat | no-repeat | repeat-x | repeat-y 参数值 作用 repeat 背景图像在纵向和横向上平铺(默认的) no-repeat 背景图像不平铺 repeat-x 背景图像在横向上平铺 repeat-y 背景图像在纵向平铺 4.4 背景图片位置装饰性图片不要插入图片，不好调节位置，使用背景图片 利用 background-position 属性可以改变图片在背景中的位置。 background-position: x y; background-position：top bottom 参数代表的意思是：x 坐标和 y 坐标。 可以使用 方位名词 或者 精确单位 参数值 说明 length 百分数 | 由浮点数字和单位标识符组成的长度值 position top | center | bottom | left | center | right方位名词 参数是方位名词 如果指定的两个值都是方位名词，则两个值前后顺序无关，比如 left top 和 top left 效果一致 如果只指定了一个方位名词，另一个值省略，则第二个值默认居中对齐 参数是精确单位 如果参数值是精确坐标，那么第一个肯定是 x 坐标，第二个一定是 y 坐标 如果只指定一个数值，那该数值一定是 x 坐标，另一个默认垂直居中 参数是混合单位 如果指定的两个值是精确单位和方位名词混合使用，则第一个值是 x 坐标，第二个值是 y 坐标 屏幕显示不完的超大图片，可使用center top来使图片最重要位置保持在最中间 4.5 背景图像固定background-attachment 属性设置背景图像是否固定或者随着页面的其余部分滚动。 background-attachment 后期可以制作视差滚动的效果。 background-attachment : scroll | fixed 参数 作用 scroll 背景图像是随对象内容滚动 fixed 背景图像固定 4.6 背景复合写法为了简化背景属性的代码，我们可以将这些属性合并简写在同一个属性 background 中。从而节约代码量.当使用简写属性时，没有特定的书写顺序,一般习惯约定顺序为：background: 背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置; 这是实际开发中，更提倡的写法。 background: transparent url(image.jpg) repeat-y fixed top ; 4.7 背景色半透明CSS3 为我们提供了背景颜色半透明的效果。 background: rgba(0, 0, 0, 0.3); 最后一个参数是 alpha 透明度，取值范围在 0~1之间 我们习惯把 0.3 的 0 省略掉，写为 background: rgba(0, 0, 0, .3); 注意：背景半透明是指盒子背景半透明，盒子里面的内容不受影响 CSS3 新增属性，是 IE9+ 版本浏览器才支持的 但是现在实际开发,我们不太关注兼容性写法了,可以放心使用 五. 综合案例 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;综合案例-五彩导航&lt;/title&gt; &lt;style&gt; .nav a { display: inline-block; width: 120px; height: 58px; background-color: pink; text-align: center; line-height: 48px; color: #fff; text-decoration: none; } .nav .bg1 { background: url(images/bg1.png) no-repeat; } .nav .bg1:hover { background-image: url(images/bg11.png); } .nav .bg2 { background: url(images/bg2.png) no-repeat; } .nav .bg2:hover { background-image: url(images/bg22.png); } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"nav\"&gt; &lt;a href=\"#\" class=\"bg1\"&gt;五彩导航&lt;/a&gt; &lt;a href=\"#\" class=\"bg2\"&gt;五彩导航&lt;/a&gt; &lt;a href=\"#\"&gt;五彩导航&lt;/a&gt; &lt;a href=\"#\"&gt;五彩导航&lt;/a&gt; &lt;a href=\"#\"&gt;五彩导航&lt;/a&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;","categories":[{"name":"技能之树","slug":"技能之树","permalink":"https://bingshanyishu.github.io/categories/%E6%8A%80%E8%83%BD%E4%B9%8B%E6%A0%91/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://bingshanyishu.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"CSS","permalink":"https://bingshanyishu.github.io/tags/CSS/"}],"author":"Sankey"},{"title":"CSS简介，基础选择器，字体属性，文本属性","slug":"CSS简介，基础选择器，字体属性，文本属性","date":"2022-03-11T08:15:23.000Z","updated":"2022-03-11T08:17:22.635Z","comments":true,"path":"posts/202203111615.html","link":"","permalink":"https://bingshanyishu.github.io/posts/202203111615.html","excerpt":"","text":"CSS简介，基础选择器，字体属性，文本属性博客园主页：博客园主页-冰山一树SankeyCSDN主页：CSDN主页-冰山一树Sankey 前端学习：学习地址：黑马程序员pink老师前端入门教程，零基础必看的h5(html5)+css3+移动，下面这些都是一些学习笔记。临渊羡鱼，不如退而结网！！愿我自己学有所成，也愿每个前端爱好者学有所成 一. CSS简介1.1 HTML的局限性 1.2 CSS—网页的美容师 CSS 是层叠样式表 ( Cascading Style Sheets ) 的简称.有时我们也会称之为 CSS 样式表或级联样式表。 CSS 是也是一种标记语言 CSS 主要用于设置 HTML 页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、 边距等）以及版面的布局和外观显示样式。 CSS 让我们的网页更加丰富多彩，布局更加灵活自如。简单理解：CSS 可以美化 HTML , 让 HTML 更漂亮， 让页面布局更简单。 总结: HTML 主要做结构,显示元素内容. CSS 美化 HTML ,布局网页. CSS 最大价值: 由 HTML 专注去做结构呈现，样式交给 CSS，即 结构 ( HTML ) 与样式( CSS ) 相分离 1.3 CSS语法规范使用 HTML 时，需要遵从一定的规范，CSS 也是如此。要想熟练地使用 CSS 对网页进行修饰，首先需要了解CSS 样式规则。CSS 规则由两个主要的部分构成：选择器以及一条或多条声明。 选择器是用于指定 CSS 样式的 HTML 标签，花括号内是对该对象设置的具体样式 属性和属性值以“键值对”的形式出现 属性是对指定的对象设置的样式属性，例如字体大小、文本颜色等 属性和属性值之间用英文“:”分开 多个“键值对”之间用英文“;”进行区分 所有的样式，都包含在 &lt;style&gt; 标签内，表示是样式表。&lt;style&gt; 一般写到 &lt;/head&gt; 上方。 &lt;head&gt; &lt;style&gt; h4 { color: blue; font-size: 100px; } &lt;/style&gt; &lt;/head&gt; 二. CSS代码风格以下代码书写风格不是强制规范,而是符合实际开发书写方式 2.1 样式格式书写1.紧凑格式 h3 { color: deeppink;font-size: 20px;} 2.展开格式 h3 { color: pink; font-size: 20px; } 强烈推荐第二种格式， 因为更直观。 2.2 样式大小写h3 { color: pink; } H3 { COLOR: PINK; } 强烈推荐样式选择器，属性名，属性值关键字全部使用小写字母，特殊情况除外。 2.2 样式空格风格h3 { color: pink; } ① 属性值前面，冒号后面，保留一个空格 ② 选择器（标签）和大括号中间保留空格 三. CSS基础选择器2.1 CSS选择器的作用选择器(选择符)就是根据不同需求把不同的标签选出来这就是选择器的作用。 简单来说，就是选择标签用的。 以上 CSS 做了两件事： 找到所有的 h1 标签。 选择器（选对人）。 设置这些标签的样式，比如颜色为红色（做对事）。 2.2 选择器的分类选择器分为基础选择器和复合选择器两个大类，我们这里先讲解一下基础选择器。 基础选择器是由单个选择器组成的 基础选择器又包括：标签选择器、类选择器、id 选择器和通配符选择器 基础选择器 作用 特点 使用情况 用法 标签选择器 可以选出所有相同的标签，比如p 不能差异化选择 较多 p {color: red;} 类选择器 可以选出1个或者多个标签 可以根据需求选择 非常多 .nav {color: red;} id选择器 一次只能选择1个标签 ID属性只能在每个HTML文档中出现一次 一般和js搭配 #nav {color: red;} 通配符选择器 选择所有的标签 选择的太多，有部分不需要 特殊情况使用 * {color: red;} 2.3 标签选择器标签选择器（元素选择器）是指用 HTML 标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的 CSS 样式。 标签名{ 属性1: 属性值1; 属性2: 属性值2; 属性3: 属性值3; ... } 作用标签选择器可以把某一类标签全部选择出来，比如所有的 标签和所有的 标签。优点能快速为页面中同类型的标签统一设置样式。缺点不能设计差异化样式，只能选择全部的当前标签。 2.4 类选择器2.4.1 语法如果想要差异化选择不同的标签，单独选一个或者某几个标签，可以使用类选择器. 语法 .类名 { 属性1: 属性值1; ... } 例如，将所有拥有 red 类的 HTML 元素均为红色。 .red { color: red; } 注意： 类选择器使用“.”（英文点号）进行标识，后面紧跟类名（自定义，我们自己命名的）。 可以理解为给这个标签起了一个名字，来表示。 长名称或词组可以使用中横线来为选择器命名。 不要使用纯数字、中文等命名，尽量使用英文字母来表示。 命名要有意义，尽量使别人一眼就知道这个类名的目的。 命名规范：见附件（ Web 前端开发规范手册.doc） 小案例： &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;画盒子&lt;/title&gt; &lt;style&gt; .red { width: 100px; height: 100px; background-color: red; } .green { width: 100px; height: 100px; background-color: green; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"red\"&gt;&lt;/div&gt; &lt;div class=\"green\"&gt;&lt;/div&gt; &lt;div class=\"red\"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 2.4.2 多类名我们可以给一个标签指定多个类名，从而达到更多的选择目的。 这些类名都可以选出这个标签. 简单理解就是一个标签有多个名字. 多类名使用方式 &lt;div class=\"red font20\"&gt;亚瑟&lt;/div&gt; 在标签class 属性中写 多个类名 多个类名中间必须用空格分开 这个标签就可以分别具有这些类名的样式 多类名开发中使用场景 可以把一些标签元素相同的样式(共同的部分)放到一个类里面. 这些标签都可以调用这个公共的类,然后再调用自己独有的类. 从而节省CSS代码,统一修改也非常方便 2.5 id选择器id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。HTML 元素以 id 属性来设置 id 选择器，CSS 中 id 选择器以“#” 来定义。 语法： #id名 { 属性1: 属性值1; ... } 例如，将 id 为 nav 元素中的内容设置为红色。 #nav { color:red; } id 选择器和类选择器的区别 类选择器（class）好比人的名字，一个人可以有多个名字，同时一个名字也可以被多个人使用。 id 选择器好比人的身份证号码，全中国是唯一的，不得重复。 id 选择器和类选择器最大的不同在于使用次数上。 类选择器在修改样式中用的最多，id 选择器一般用于页面唯一性的元素上，经常和 JavaScript 搭配使用。 2.6 通配符选择器在 CSS 中，通配符选择器使用“*****”定义，它表示选取页面中所有元素（标签）。 * { 属性1: 属性值1; ... } * { margin: 0; padding: 0; } 通配符选择器不需要调用， 自动就给所有的元素使用样式 特殊情况才使用，后面讲解使用场景(以下是清除所有的元素标签的内外边距,后期讲) * { margin: 0; padding: 0; } 四. CSS字体属性CSS Fonts (字体)属性用于定义字体系列、大小、粗细、和文字样式（如斜体）。 4.1 字体系列CSS 使用 font-family 属性定义文本的字体系列。 p { font-family:\"微软雅黑\";} div {font-family: Arial,\"Microsoft Yahei\", \"微软雅黑\";} body {font-family: 'Microsoft YaHei',tahoma,arial,'Hiragino Sans GB'; } 各种字体之间必须使用英文状态下的逗号隔开 一般情况下,如果有空格隔开的多个单词组成的字体,加引号. 尽量使用系统默认自带字体，保证在任何用户的浏览器中都能正确显示 最常见的几个字体：body {font-family: ‘Microsoft YaHei’,tahoma,arial,’Hiragino Sans GB’; } 4.2 字体大小CSS 使用 font-size 属性定义字体大小。 p { font-size: 20px; } px（像素）大小是我们网页的最常用的单位 谷歌浏览器默认的文字大小为16px 不同浏览器可能默认显示的字号大小不一致，我们尽量给一个明确值大小，不要默认大小 可以给 body 指定整个页面文字的大小 4.3 字体粗细CSS 使用 font-weight 属性设置文本字体的粗细。 p { font-weight: bold; } 属性值 描述 normal 默认值（不加粗的） bold 定义粗体（加粗的） 100－900 400等同于normal，而700等同于bold 注意这个数字后面不跟单位 可实现让加粗标签（比如 h 和 strong 等) 不加粗，或者其他标签加粗 实际开发时，更喜欢用数字表示粗细 4.4 文字样式CSS 使用 font-style 属性设置文本的风格。 p { font-style: normal; } 属性值 作用 normal 默认值，浏览器会显示标准的字体样式font－style：normal； italic 浏览器会显示斜体的字体样式。 注意： 平时很少给文字加斜体，反而要给斜体标签（em，i）改为不倾斜字体。 4.5 复合属性字体属性可以把以上文字样式综合来写, 这样可以更节约代码: body { font: font-style font-weight font-size/line-height font-family; } 使用 font 属性时，必须按上面语法格式中的顺序书写，不能更换顺序，并且各个属性间以空格隔开 不需要设置的属性可以省略（取默认值），但必须保留 font-size 和 font-family 属性，否则 font 属性将不起作用 &lt;style&gt; /* 想要div文字变倾斜 加粗 字号设置为16像素 并且 是微软雅黑 */ div { /* font-style: italic; font-weight: 700; font-size: 16px; font-family: 'Microsoft yahei'; */ /* 复合属性: 简写的方式 节约代码 */ /* font: font-style font-weight font-size/line-height font-family; */ /* font: italic 700 16px 'Microsoft yahei'; */ font: 20px '黑体'; } &lt;/style&gt; 五. CSS文本属性CSS Text（文本）属性可定义文本的外观，比如文本的颜色、对齐文本、装饰文本、文本缩进、行间距等。 5.1 文本颜色color 属性用于定义文本的颜色。 div { color: red; } 表示 属性值 预定义的颜色值 red，green，blue等等 十六进制 ＃FF0000，＃FF6600，＃29D794 RGB代码 rgb(255,0,0)或rgb(100％,0％,0％） 5.2 对齐文本text-align 属性用于设置元素内文本内容的水平对齐方式。 div { text-align: center; } 属性值 解释 left 左对齐（默认值） right 右对齐 center 居中对齐 5.3 装饰文本text-decoration 属性规定添加到文本的修饰。可以给文本添加下划线、删除线、上划线等。 div { text-decoration：underline； } 属性值 描述 none 默认。没有装饰线（最常用） underline 下划线。链接a自带下划线（常用） overline 上划线。（几乎不用） line－through 删除线。（不常用） 5.4 文本缩进text-indent 属性用来指定文本的第一行的缩进，通常是将段落的首行缩进。 div { text-indent: 10px; } 通过设置该属性，所有元素的第一行都可以缩进一个给定的长度，甚至该长度可以是负值。 p { text-indent: 2em; } em 是一个相对单位，就是当前元素font-size 1 个文字的大小, 如果当前元素没有设置大小，则会按照父元素的 1 个文字大小。 5.5 行间距 line-height 属性用于设置行间的距离（行高）。可以控制文字行与行之间的距离.一般可用于文字垂直居中显示 p { line-height: 26px; } 六. CSS的引入方式按照 CSS 样式书写的位置（或者引入的方式），CSS 样式表可以分为三大类： 行内样式表（行内式） 内部样式表（嵌入式） 外部样式表（链接式） 6.1 内部样式表内部样式表（内嵌样式表）是写到html页面内部. 是将所有的 CSS 代码抽取出来，单独放到一个 &lt;style&gt; 标签中。 &lt;style&gt; div { color: red; font-size: 12px; } &lt;/style&gt; &lt;style&gt; 标签理论上可以放在 HTML 文档的任何地方，但一般会放在文档的&lt;head&gt;标签中 通过此种方式，可以方便控制当前整个页面中的元素样式设置 代码结构清晰，但是并没有实现结构与样式完全分离 使用内部样式表设定 CSS，通常也被称为嵌入式引入，这种方式是我们练习时常用的方式 6.2 行内样式表行内样式表（内联样式表）是在元素标签内部的 style 属性中设定 CSS 样式。适合于修改简单样式. &lt;div style=\"color: red; font-size: 12px;\"&gt;青春不常在，抓紧谈恋爱&lt;/div&gt; style 其实就是标签的属性 在双引号中间，写法要符合 CSS 规范 可以控制当前的标签设置样式 由于书写繁琐，并且没有体现出结构与样式相分离的思想，所以不推荐大量使用，只有对当前元素添加简 单样式的时候，可以考虑使用 使用行内样式表设定 CSS，通常也被称为行内式引入 6.3 外部样式表实际开发都是外部样式表. 适合于样式比较多的情况. 核心是:样式单独写到CSS 文件中，之后把CSS文件引入到 HTML 页面中使用，通常也被称为外链式或链接式引入。 引入外部样式表分为两步： 新建一个后缀名为 .css 的样式文件，把所有 CSS 代码都放入此文件中。 在 HTML 页面中，使用&lt;link&gt; 标签引入这个文件。 &lt;link rel=\"stylesheet\" href=\"css文件路径\"&gt; 属性 作用 rel 定义当前文档与被链接文档之间的关系,在这里需要指定为”stylesheet’”,表示被链接的文档是一个样式表文件。 href 定义所链接外部样式表文件的UL,可以是相对路径,也可以是绝对路径。 七. 综合案例制作一个新闻页 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body { font: 16px/28px 'Microsoft YaHei'; } h1 { /* 文字不加粗 */ font-weight: 400; /* 让h1里面的文字水平居中对齐 */ text-align: center; } a { text-decoration: none; } .gray { color: #888888; font-size: 12px; text-align: center; } .search { color: #666; /* #666666 #666 #ff00ff #f0f */ width: 170px; } .btn { font-weight: 700; } p { /* 首行缩进2个字的距离 */ text-indent: 2em; } .pic { /* 想要图片居中对齐,则是让它的父亲 p标签添加 水平居中的代码 */ text-align: center; } .footer { color: #888888; font-size: 12px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt; 北方高温明日达鼎盛 京津冀多地地表温度将超60℃&lt;/h1&gt; &lt;div class=\"gray\"&gt; 2019-07-03 16:31:47 来源: &lt;a href=\"#\"&gt;中国天气网&lt;/a&gt; &lt;input type=\"text\" value=\"请输入查询条件...\" class=\"search\"&gt; &lt;button class=\"btn\"&gt;搜索&lt;/button&gt; &lt;/div&gt; &lt;hr&gt; &lt;p&gt;中国天气网讯 今天（3日），华北、黄淮多地出现高温天气，截至下午2点，北京、天津、郑州等地气温突破35℃。预报显示，今后三天（3-5日），这一带的高温天气将继续发酵，高温范围以及强度将在4日达到鼎盛，预计北京、天津、石家庄、济南等地明天的最高气温有望突破38℃，其中北京和石家庄的最高气温还有望创今年以来的新高。&lt;/p&gt; &lt;h4&gt;气温41.4℃！地温66.5！北京强势迎七月首个高温日&lt;/h4&gt; &lt;p class=\"pic\"&gt; &lt;img src=\"images/pic.jpeg\" alt=\"\"&gt; &lt;/p&gt; &lt;p&gt;今天，华北、黄淮一带的高温持续发酵，截至今天下午2点，陕西北部、山西西南部、河北南部、北京、天津、山东西部、河南北部最高气温已普遍超过35℃。大城市中，北京、天津、郑州均迎来高温日。&lt;/p&gt; &lt;p&gt;在阳光暴晒下，地表温度也逐渐走高。今天下午2点，华北黄淮大部地区的地表温度都在50℃以上，部分地区地表温度甚至超过60℃。其中，河北衡水地表温度高达68.3℃，天津站和北京站附近的地表温度分别高达66.6℃和66.5℃。&lt;/p&gt; &lt;h4&gt;明日热度再升级！京津冀携手冲击38℃+&lt;/h4&gt; &lt;p&gt;中国天气网气象分析师王伟跃介绍，明天（4日），华北、黄淮地区35℃以上的高温天气还将继续升级，并进入鼎盛阶段，高温强度和范围都将发展到最强。 明天，北京南部、天津大部、河北中部和南部、山东中部和西部、山西南部局地、河南北部、东北部分地区的最高气温都将达到或超过35℃。&lt;/p&gt; &lt;p&gt; 不过，专家提醒，济南被雨水天气完美绕开，因此未来一周，当地的高温还会天天上岗。在此提醒当地居民注意防暑降温，防范持续高温带来的各种不利影响。（文/张慧 数据支持/王伟跃 胡啸 审核/刘文静 张方丽）&lt;/p&gt; &lt;p class=\"footer\"&gt; 本文来源：中国天气网 责任编辑：刘京_NO5631&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;","categories":[{"name":"技能之树","slug":"技能之树","permalink":"https://bingshanyishu.github.io/categories/%E6%8A%80%E8%83%BD%E4%B9%8B%E6%A0%91/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://bingshanyishu.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"CSS","permalink":"https://bingshanyishu.github.io/tags/CSS/"}],"author":"Sankey"},{"title":"HTML的表格标签，列表标签，表单标签，HTML5有哪些新特性","slug":"HTML的表格标签，列表标签，表单标签，HTML5有哪些新特性","date":"2022-03-11T08:13:10.000Z","updated":"2022-03-11T08:14:46.618Z","comments":true,"path":"posts/202203111613.html","link":"","permalink":"https://bingshanyishu.github.io/posts/202203111613.html","excerpt":"","text":"HTML的表格标签，列表标签，表单标签，HTML5有哪些新特性博客园主页：博客园主页-冰山一树SankeyCSDN主页：CSDN主页-冰山一树Sankey 前端学习：学习地址：黑马程序员pink老师前端入门教程，零基础必看的h5(html5)+css3+移动，下面这些都是一些学习笔记。临渊羡鱼，不如退而结网！！愿我自己学有所成，也愿每个前端爱好者学有所成 一. 表格标签1.1 表格的主要作用表格主要用于显示、展示数据，因为它可以让数据显示的非常的规整，可读性非常好。特别是后台展示数据的时候，能够熟练运用表格就显得很重要。一个清爽简约的表格能够把繁杂的数据表现得很有条理。 总结：表格不是用来布局页面的,而是用来展示数据的. 1.2 表格的基本语法&lt;table&gt; &lt;tr&gt; &lt;td&gt;单元格内的文字&lt;/td&gt; ... &lt;/tr&gt; ... &lt;/table&gt; &lt;table&gt; &lt;/table&gt; 是用于定义表格的标签。 &lt;tr&gt; &lt;/tr&gt; 标签用于定义表格中的行，必须嵌套在 &lt;table&gt; &lt;/table&gt;标签中。 &lt;td&gt; &lt;/td&gt; 用于定义表格中的单元格，必须嵌套在&lt;tr&gt;&lt;/tr&gt;标签中。 &lt;table&gt; &lt;tr&gt;&lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;性别&lt;/td&gt;&lt;td&gt;年龄&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;刘德华&lt;/td&gt; &lt;td&gt;男&lt;/td&gt;&lt;td&gt;30&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;pink&lt;/td&gt; &lt;td&gt;男&lt;/td&gt;&lt;td&gt;21&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;gff&lt;/td&gt; &lt;td&gt;男&lt;/td&gt;&lt;td&gt;21&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;piwwecnk&lt;/td&gt; &lt;td&gt;男&lt;/td&gt;&lt;td&gt;21&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; 1.3 表头单元格标签一般表头单元格位于表格的第一行或第一列，表头单元格里面的文本内容加粗居中显示, 突出重要性&lt;th&gt; 标签表示 HTML 表格的表头部分(table head 的缩写) 语法： &lt;table&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; ... &lt;/tr&gt; ... &lt;/table&gt; 1.4 表格属性表格标签这部分属性实际开发不常用，后面通过 CSS 来设置.了解目的: 记住这些英语单词,后面 CSS 会使用. 直观感受表格的外观形态 1.5 案例分析小说排行榜 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;今日小说排行榜&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table align=\"center\" width=\"500\" height=\"249\" border=\"1\" cellspacing=\"0\" &gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;排名&lt;/th&gt; &lt;th&gt;关键词&lt;/th&gt; &lt;th&gt;趋势&lt;/th&gt; &lt;th&gt;进入搜索&lt;/th&gt; &lt;th&gt;最近七日&lt;/th&gt; &lt;th&gt;相关链接&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;鬼吹灯&lt;/td&gt; &lt;td&gt;&lt;img src=\"down.jpg\"&gt;&lt;/td&gt; &lt;td&gt;456&lt;/td&gt; &lt;td&gt;123&lt;/td&gt; &lt;td&gt; &lt;a href=\"#\"&gt;贴吧&lt;/a&gt; &lt;a href=\"#\"&gt;图片&lt;/a&gt; &lt;a href=\"#\"&gt;百科&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;鬼吹灯&lt;/td&gt; &lt;td&gt;&lt;img src=\"down.jpg\"&gt;&lt;/td&gt; &lt;td&gt;456&lt;/td&gt; &lt;td&gt;123&lt;/td&gt; &lt;td&gt; &lt;a href=\"#\"&gt;贴吧&lt;/a&gt; &lt;a href=\"#\"&gt;图片&lt;/a&gt; &lt;a href=\"#\"&gt;百科&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;西游记&lt;/td&gt; &lt;td&gt;&lt;img src=\"up.jpg\"&gt;&lt;/td&gt; &lt;td&gt;456&lt;/td&gt; &lt;td&gt;123&lt;/td&gt; &lt;td&gt; &lt;a href=\"#\"&gt;贴吧&lt;/a&gt; &lt;a href=\"#\"&gt;图片&lt;/a&gt; &lt;a href=\"#\"&gt;百科&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;鬼吹灯&lt;/td&gt; &lt;td&gt;&lt;img src=\"down.jpg\"&gt;&lt;/td&gt; &lt;td&gt;456&lt;/td&gt; &lt;td&gt;123&lt;/td&gt; &lt;td&gt; &lt;a href=\"#\"&gt;贴吧&lt;/a&gt; &lt;a href=\"#\"&gt;图片&lt;/a&gt; &lt;a href=\"#\"&gt;百科&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;鬼吹灯&lt;/td&gt; &lt;td&gt;&lt;img src=\"down.jpg\"&gt;&lt;/td&gt; &lt;td&gt;456&lt;/td&gt; &lt;td&gt;123&lt;/td&gt; &lt;td&gt; &lt;a href=\"#\"&gt;贴吧&lt;/a&gt; &lt;a href=\"#\"&gt;图片&lt;/a&gt; &lt;a href=\"#\"&gt;百科&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;鬼吹灯&lt;/td&gt; &lt;td&gt;&lt;img src=\"down.jpg\"&gt;&lt;/td&gt; &lt;td&gt;456&lt;/td&gt; &lt;td&gt;123&lt;/td&gt; &lt;td&gt; &lt;a href=\"#\"&gt;贴吧&lt;/a&gt; &lt;a href=\"#\"&gt;图片&lt;/a&gt; &lt;a href=\"#\"&gt;百科&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 1.6 表格结构标签使用场景:因为表格可能很长,为了更好的表示表格的语义，可以将表格分割成 表格头部和表格主体两大部分.在表格标签中，分别用：&lt;thead&gt;标签 表格的头部区域、&lt;tbody&gt;标签 表格的主体区域. 这样可以更好的分清表格结构。 &lt;thead&gt;&lt;/thead&gt;：用于定义表格的头部。 内部必须拥有 标签。 一般是位于第一行。 &lt;tbody&gt;&lt;/tbody&gt;：用于定义表格的主体，主要用于放数据本体 。 以上标签都是放在 &lt;table&gt;&lt;/table&gt; 标签中。 1.7 合并单元格特殊情况下,可以把多个单元格合并为一个单元格。 跨行合并：rowspan＝”合并单元格的个数” 跨列合并：colspan＝”合并单元格的个数” 目标单元格：（写合并代码） 跨行：最上侧单元格为目标单元格，写合并代码 跨列：最左侧单元格为目标单元格，写合并代码 合并单元格三步曲： 先确定是跨行还是跨列合并。 找到目标单元格. 写上合并方式 = 合并的单元格数量。比如：&lt;td colspan=\"2\"&gt;&lt;/td&gt;。 删除多余的单元格。 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;合并单元格&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table width=\"500\" height=\"249\" border=\"1\" cellspacing=\"0\"&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td colspan=\"2\"&gt;&lt;/td&gt; &lt;--&gt;原来单元格&lt;/--&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspan=\"2\"&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;--&gt;原来单元格&lt;/--&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 二. 列表标签表格是用来显示数据的，那么列表就是用来布局的。列表最大的特点就是整齐、整洁、有序，它作为布局会更加自由和方便。根据使用情景不同，列表可以分为三大类：无序列表、有序列表和自定义列表。 标签名 定义 说明 &lt;ul&gt;&lt;/ul&gt; 无序标签 里面只能包含li，设有顺序，使用较多。li里面可以包含任何标签 &lt;li&gt;&lt;/li&gt; 有序标签 里面只能包含li，有顺序，使用相对较少。li里面可以包含任何标签 &lt;dl&gt;&lt;dl&gt; 自定义列表 里面只能包含dt和dd。dt和dd里面可以放任何标签 2.1 无序列表&lt;ul&gt; 标签表示 HTML 页面中项目的无序列表，一般会以项目符号呈现列表项，而列表项使用 &lt;li&gt; 标签定义。无序列表的基本语法格式如下： &lt;ul&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ... &lt;/ul&gt; &lt;ul&gt; &lt;li&gt;榴莲&lt;/li&gt; &lt;li&gt;臭豆腐&lt;/li&gt; &lt;li&gt;鲱鱼罐头&lt;/li&gt; &lt;/ul&gt; 注意： 无序列表的各个列表项之间没有顺序级别之分，是并列的。 &lt;ul&gt;\\&lt;/ul&gt; 中只能嵌套 &lt;li&gt;\\&lt;/li&gt;，直接在 &lt;ul&gt;\\&lt;/ul&gt; 标签中输入其他标签或者文字的做法是不被允许的 &lt;li&gt; 与 &lt;/li&gt; 之间相当于一个容器，可以容纳所有元素。 无序列表会带有自己的样式属性，但在实际使用时，我们会使用 CSS 来设置。 2.2 有序列表有序列表即为有排列顺序的列表，其各个列表项会按照一定的顺序排列定义。在 HTML 标签中，&lt;ol&gt; 标签用于定义有序列表，列表排序以数字来显示，并且使用 &lt;li&gt; 标签来定义列表项。有序列表的基本语法格式如下： &lt;ol&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ... &lt;/ol&gt; &lt;ol&gt;\\&lt;/ol&gt;中只能嵌套&lt;li&gt;\\&lt;/li&gt;，直接在&lt;ol&gt;\\&lt;/ol&gt;标签中输入其他标签或者文字的做法是不被允许的。 &lt;li&gt; 与 &lt;/li&gt;之间相当于一个容器，可以容纳所有元素。 有序列表会带有自己样式属性，但在实际使用时，我们会使用 CSS 来设置。 2.3 自定义列表自定义列表的使用场景:自定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。 在 HTML 标签中，&lt;dl&gt; 标签用于定义描述列表（或定义列表），该标签会与 &lt;dt&gt;（定义项目/名字）和&lt;dd&gt;（描述每一个项目/名字）一起使用。其基本语法如下： &lt;dl&gt; &lt;dt&gt;名词1&lt;/dt&gt; &lt;dd&gt;名词1解释1&lt;/dd&gt; &lt;dd&gt;名词1解释2&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt;&lt;/dl&gt; 里面只能包含 &lt;dt&gt; 和 &lt;dd&gt;。 &lt;dt&gt; 和 &lt;dd&gt;个数没有限制，经常是一个&lt;dt&gt; 对应多个&lt;dd&gt;。 三. 表单标签使用表单目的是为了收集用户信息。 在我们网页中， 我们也需要跟用户进行交互，收集用户资料，此时就需要表单。 网页中的表单展示 3.1 表单的组成在 HTML 中，一个完整的表单通常由表单域、表单控件（也称为表单元素）和 提示信息3个部分构成。 3.2 表单域表单域是一个包含表单元素的区域。在 HTML 标签中， &lt;form&gt;&lt;/form&gt; 标签用于定义表单域，以实现用户信息的收集和传递。 &lt;form&gt; 会把它范围内的表单元素信息提交给服务器 &lt;form action=“url地址” method=“提交方式” name=“表单域名称\"&gt; 各种表单元素控件 &lt;/form&gt; 常用属性: 属性 属性值 作用 action url地址 用于指定接收并处理表单数据的服务器程序的url地址。 method get／post 用于设置表单数据的提交方式，其取值为get或post。 name 名称 用于指定表单的名称，以区分同一个页面中的多个表单域。 3.3 表单控件3.3.1 &lt;input&gt;标签在英文单词中，input 是输入的意思，而在表单元素中 &lt;input/&gt; 标签用于收集用户信息。在 &lt;input/&gt; 标签中，包含一个 type 属性，根据不同的 type 属性值，输入字段拥有很多种形式（可以是文本、字段、复选框、掩码后的文本控件、单选按钮、按钮等）。 input type=\"属性值\" /&gt; &lt;input/&gt; 标签为单标签 type 属性设置不同的属性值用来指定不同的控件类型 type 属性的属性值及其描述如下： 属性值 描述 button 定义可点击按钮（多数情况下，用于通过JavaScript启动脚本） checkbox 定义复选框。 file 定义输入字段和＂浏览＂按钮，供文件上传。 hidden 定义隐藏的输入字段。 image 定义图像形式的提交按钮。 password 定义密码字段。该字段中的字符被掩码。 radio 定义单选按钮。 reset 定义重置按钮。重置按钮会清除表单中的所有数据。 submit 定义提交按钮。提交按钮会把表单数据发送到服务器。 text 定义单行的输入字段，用户可在其中输入文本。默认宽度为20个字符。 除 type 属性外，&lt;input&gt;标签还有其他很多属性，其常用属性如下： 属性 属性值 描述 name 由用户自定义 定义input元素的名称。 value 由用户自定义 规定input元素的值。 checked checked 规定此input元素首次加载时应当被选中。 maxlength 正整数 规定输入字段中的字符的最大长度。 name 和value 是每个表单元素都有的属性值,主要给后台人员使用. name 表单元素的名字, 要求 单选按钮和复选框要有相同的name值. checked属性主要针对于单选按钮和复选框, 主要作用一打开页面,就要可以默认选中某个表单元素. maxlength 是用户可以在表单元素输入的最大字符数, 一般较少使用. 小问答： 有些表单元素想刚打开页面就默认显示几个文字怎么做? 用户名: &lt;input type=\"text\" value=\"请输入用户名\" /&gt; 答: 可以给这些表单元素设置 value 属性=“值” 页面中的表单元素很多，如何区别不同的表单元素? 用户名: &lt;input type=\"text\" value=\"请输入用户名\" name=\"username\" /&gt; 答: name 属性：当前 input 表单的名字，后台可以通过这个 name 属性找到这个表单。页面中的表单很多，name 的主要作用就是用于区别不同的表单。 name 属性后面的值，是自定义的 radio (或者checkbox）如果是一组，必须给他们命名相同的名字 &lt;input type=\"radio\" name=\"sex\" /&gt;男 &lt;input type=\"radio\" name=\"sex\" /&gt;女 . 如果页面一打开就让某个单选按钮或者复选框是选中状态? 答: checked 属性：表示默认选中状态。用于单选按钮和复选按钮 性 别: &lt;input type=\"radio\" name=\"sex\" value=\"男\" checked=\"checked\" /&gt;男 &lt;input type=\"radio\" name=\"sex\" value=\"女\" /&gt;女 如何让input表单元素展示不同的形态? 比如单选按钮或者文本框 答: type属性：type属性可以让input表单元素设置不同的形态 &lt;input type=\"radio\" name=\"sex\" value=\"男\" checked=\"checked\" /&gt;男 &lt;input type=\"text\" value=“请输入用户名”&gt; 总结： &lt;form action=\"xxx.php\" method=\"get\"&gt; &lt;!-- text 文本框 用户可以里面输入任何文字 --&gt; 用户名: &lt;input type=\"text\" name=\"username\" value=\"请输入用户名\" maxlength=\"6\"&gt; &lt;br&gt; &lt;!-- password 密码框 用户看不见输入的密码 --&gt; 密码: &lt;input type=\"password\" name=\"pwd\" &gt; &lt;br&gt; &lt;!-- radio 单选按钮 可以实现多选一 --&gt; &lt;!-- name 是表单元素名字 这里性别单选按钮必须有相同的名字name 才可以实现多选1 --&gt; &lt;!-- 单选按钮和复选框可以设置checked 属性, 当页面打开的时候就可以默认选中这个按钮 --&gt; 性别: 男 &lt;input type=\"radio\" name=\"sex\" value=\"男\"&gt; 女 &lt;input type=\"radio\" name=\"sex\" value=\"女\" checked=\"checked\"&gt; 人妖 &lt;input type=\"radio\" name=\"sex\" value=\"人妖\"&gt; &lt;br&gt; &lt;!-- checkbox 复选框 可以实现多选 --&gt; 爱好: 吃饭 &lt;input type=\"checkbox\" name=\"hobby\" value=\"吃饭\"&gt; 睡觉 &lt;input type=\"checkbox\" name=\"hobby\"&gt; 打豆豆 &lt;input type=\"checkbox\" name=\"hobby\" checked=\"checked\"&gt; &lt;br&gt; &lt;!-- 点击了提交按钮,可以把 表单域 form 里面的表单元素 里面的值 提交给后台服务器 --&gt; &lt;input type=\"submit\" value=\"免费注册\"&gt; &lt;!-- 重置按钮可以还原表单元素初始的默认状态 --&gt; &lt;input type=\"reset\" value=\"重新填写\"&gt; &lt;!-- 普通按钮 button 后期结合js 搭配使用--&gt; &lt;input type=\"button\" value=\"获取短信验证码\"&gt; &lt;br&gt; &lt;!-- 文件域 使用场景 上传文件使用的 --&gt; 上传头像: &lt;input type=\"file\" &gt; &lt;/form&gt; 3.3.2 &lt;label&gt;标签&lt;label&gt; 标签为 input 元素定义标注（标签）。&lt;label&gt; 标签用于绑定一个表单元素, 当点击&lt;label&gt; 标签内的文本时，浏览器就会自动将焦点(光标)转到或者选择对应的表单元素上,增加选取范围，用来增加用户体验.语法： &lt;label for=\"sex\"&gt;男&lt;/label&gt; &lt;input type=\"radio\" name=\"sex\" id=\"sex\" /&gt; 核心： 标签的 for 属性应当与相关元素的 id 属性相同。 3.3.3 &lt;select&gt;标签使用场景: 在页面中，如果有多个选项让用户选择，并且想要节约页面空间时，我们可以使用&lt;select&gt;标签控件定义下拉列表。 在页面中，如果有多个选项让用户选择，并且想要节约页面空间时，我们可以使用&lt;select&gt;标签控件定义下拉列表 语法： &lt;select&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option&gt;选项2&lt;/option&gt; &lt;option&gt;选项3&lt;/option&gt; ... &lt;/select&gt; &lt;select&gt; 中至少包含一对&lt;option&gt; 。 在&lt;option&gt; 中定义 selected =“ selected \" 时，当前项即为默认选中项。 3.3.4 &lt;textarea&gt;标签 当用户输入内容较多的情况下，我们就不能使用文本框表单了，此时我们可以使用 &lt;textarea&gt; 标签。在表单元素中，&lt;textarea&gt; 标签是用于定义多行文本输入的控件。 使用多行文本输入控件，可以输入更多的文字，该控件常见于留言板，评论。 语法： &lt;textarea rows=\"3\" cols=\"20\"&gt; 文本内容 &lt;/textarea&gt; 通过 &lt;textarea&gt; 标签可以轻松地创建多行文本输入框。 cols=“每行中的字符数” ，rows=“显示的行数”，我们在实际开发中不会使用，都是用 CSS 来改变大小。 表格，列表，表单综合案例 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;综合案例-注册页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h4&gt;青春不常在，抓紧谈恋爱&lt;/h4&gt; &lt;table width=\"600\" &gt; &lt;!-- 第一行 --&gt; &lt;tr&gt; &lt;td&gt;性别:&lt;/td&gt; &lt;td&gt; &lt;input type=\"radio\" name=\"sex\" id=\"nan\"&gt; &lt;label for=\"nan\"&gt; &lt;img src=\"images/man.jpg\" &gt; 男 &lt;/label&gt; &lt;input type=\"radio\" name=\"sex\" id=\"nv\"&gt; &lt;label for=\"nv\"&gt;&lt;img src=\"images/women.jpg\" &gt; 女&lt;/label&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第二行 --&gt; &lt;tr&gt; &lt;td&gt;生日:&lt;/td&gt; &lt;td&gt; &lt;select&gt; &lt;option&gt;--请选择年份--&lt;/option&gt; &lt;option&gt;2001&lt;/option&gt; &lt;option&gt;2002&lt;/option&gt; &lt;option&gt;2003&lt;/option&gt; &lt;/select&gt; &lt;select&gt; &lt;option&gt;--请选择月份--&lt;/option&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;/select&gt; &lt;select&gt; &lt;option&gt;--请选择日--&lt;/option&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第三行 --&gt; &lt;tr&gt; &lt;td&gt;所在地区&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" value=\"北京思密达\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!-- 第四行 --&gt; &lt;tr&gt; &lt;td&gt;婚姻状况:&lt;/td&gt; &lt;td&gt; &lt;input type=\"radio\" name=\"marry\" checked=\"checked\"&gt;未婚 &lt;input type=\"radio\" name=\"marry\"&gt; 已婚 &lt;input type=\"radio\" name=\"marry\"&gt; 离婚 &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第五行 --&gt; &lt;tr&gt; &lt;td&gt;学历:&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" value=\"博士后\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!-- 第六行 --&gt; &lt;tr&gt; &lt;td&gt;喜欢的类型:&lt;/td&gt; &lt;td&gt; &lt;input type=\"checkbox\" name=\"love\" &gt; 妩媚的 &lt;input type=\"checkbox\" name=\"love\" &gt; 可爱的 &lt;input type=\"checkbox\" name=\"love\" &gt; 小鲜肉 &lt;input type=\"checkbox\" name=\"love\" &gt; 老腊肉 &lt;input type=\"checkbox\" name=\"love\" checked=\"checked\"&gt; 都喜欢 &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第七行 --&gt; &lt;tr&gt; &lt;td&gt;个人介绍&lt;/td&gt; &lt;td&gt; &lt;textarea&gt;个人简介&lt;/textarea&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第八行 --&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt; &lt;input type=\"submit\" value=\"免费注册\" &gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt; &lt;input type=\"checkbox\" checked=\"checked\"&gt; 我同意注册条款和会员加入标准 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt; &lt;a href=\"#\" &gt; 我是会员，立即登录&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt; &lt;h5&gt;我承诺&lt;/h5&gt; &lt;ul&gt; &lt;li&gt;年满18岁、单身&lt;/li&gt; &lt;li&gt;抱着严肃的态度&lt;/li&gt; &lt;li&gt;真诚寻找另一半&lt;/li&gt; &lt;/ul&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 四. HTML5新特性HTML5 的新增特性主要是针对于以前的不足，增加了一些新的标签、新的表单和新的表单属性等。这些新特性都有兼容性问题，基本是 IE9+ 以上版本的浏览器才支持，如果不考虑兼容性问题，可以大量使用这些新特性。声明： 新特性增加了很多，但是我们专注于开发常用的新特性。 基础班我们讲解部分新特性，到了就业班还会继续讲解其他新特性。 1.1 新增的语义化标签以前布局，基本用 div 来做。div 对于搜索引擎来说，是没有语义的。 &lt;div class=“header”&gt; &lt;/div&gt; &lt;div class=“nav”&gt; &lt;/div&gt; &lt;div class=“content”&gt; &lt;/div&gt; &lt;div class=“footer”&gt; &lt;/div&gt; 1.2 新增video标签HTML5 在不使用插件的情况下，也可以原生的支持视频格式文件的播放，当然，支持的格式是有限的。 语法： &lt;video src=\"文件地址\" controls=\"controls\"&gt;&lt;/video&gt; &lt;video controls=\"controls\" width=\"300\"&gt; &lt;source src=\"move.ogg\" type=\"video/ogg\" &gt; &lt;source src=\"move.mp4\" type=\"video/mp4\" &gt; 您的浏览器暂不支持 &lt;video&gt; 标签播放视频 &lt;/ video &gt; 常见属性： 属性 值 描述 autoplay autoplay 视频就堵自动幅放(谷欧刘览器需要添加muted来解决自动插放问题) controls controls 向用户显示播放控件 width pixels(像素) 设置播放器宽度 height pixels(像素) 设置播放器高度 loop loop 插放完是香继续插放该视频,循环插放 preload aut0(预先加载视频)none(不应加载视频) 规定是否预加载视须如果有了autoplay就忽略该属性) src url 视频ur地址 poster Imgurl 加载等待的画面图片 muted muted 静音播放 1.3 新增audio标签 浏贷器 MP3 Wav Ogg Intemet Explorer YES NO NO Chrome YES YES YES Firefox YES YES YES Safari YES YES NO Opera YES YES YES 语法： &lt;audio src=\"文件地址\" controls=\"controls\"&gt;&lt;/audio&gt; &lt;source src=\"happy.mp3\" type=\"audio/mpeg\" &gt; &lt;source src=\"happy.ogg\" type=\"audio/ogg\" &gt; 您的浏览器暂不支持 &lt;audio&gt; 标签。 &lt;/ audio&gt; 常见属性 属性 值 描述 autoplay autoplay 如果出现该属性,则音频在就绪后马上播放。 controls controls 如果出现该属性,则向用户显示控件,比如播放按钮。 loop loop 如果出现该属性,则每当音频结束时重新开始插放。 src url 要播放的音频的URL, 谷歌浏览器把音频和视频自动播放都禁止了。 总结： 音频标签和视频标签使用方式基本一致 浏览器支持情况不同 谷歌浏览器把音频和视频自动播放禁止了 我们可以给视频标签添加 muted 属性来静音播放视频，音频不可以（可以通过JavaScript解决） 视频标签是重点，我们经常设置自动播放，不使用 controls 控件，循环和设置大小属性 1.4 新增的 input 类型 属性值 说明 type=”email” 限制用户输入必须为Email类型 type=”url” 限制用户输入必须为URL类型 type=”date” 限制用户输入必须为日期类型 type=”time” 限制用户输入必须为时间类型 type=”month” 限制用户输入必须为月类型 type=”week” 限制用户输入必须为周类型 type=”number” 限制用户输入必须为数字类型 type=”tel” 手机号码 type=”search” 搜索框 type=”color” 生成一个颜色选择表单 1.5 新增表单属性 属性 值 说明 required required 表单拥有该属性表示其内容不能为空,必填 placeholder 提示文本 表单的提示信息,存在默认值将不显示 autofocus autofocus 自动聚焦属性,页面加载完成自动聚焦到指定表单 autocomplete off /on 当用户在字段开始键入时,浏览器基于之前键入过的值,应该显示出在字段中填写的选项。默认已经打开,如autocomplete=”on”,关闭autocomplete=”off 需要放在表单内,同时加上name属性,同时成功提交 multiple multiple 可以多选文件提交 可以通过以下设置方式修改placeholder里面的字体颜色: input:placeholder{ color:pink; }","categories":[{"name":"技能之树","slug":"技能之树","permalink":"https://bingshanyishu.github.io/categories/%E6%8A%80%E8%83%BD%E4%B9%8B%E6%A0%91/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://bingshanyishu.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"HTML","slug":"HTML","permalink":"https://bingshanyishu.github.io/tags/HTML/"}],"author":"Sankey"},{"title":"关于Web的一些知识，Web怎么构成？","slug":"关于Web的一些知识，Web怎么构成？","date":"2022-03-09T10:29:01.000Z","updated":"2022-03-09T10:40:25.577Z","comments":true,"path":"posts/202203091829.html","link":"","permalink":"https://bingshanyishu.github.io/posts/202203091829.html","excerpt":"","text":"关于Web的一些知识，Web怎么构成？ 前端学习：学习地址：黑马程序员pink老师前端入门教程，零基础必看的h5(html5)+css3+移动，下面这些都是一些学习笔记。临渊羡鱼，不如退而结网！！愿我自己学有所成，也愿每个前端爱好者学有所成 一. 网页1.1 什么是网页 网站是指在因特网上根据一定的规则，使用 HTML 等制作的用于展示特定内容相关的网页集合。 网页是网站中的一“页”，通常是 HTML 格式的文件，它要通过浏览器来阅读。 网页是构成网站的基本元素，它通常由图片、链接、文字、声音、视频等元素组成。通常我们看到的网页， 常见.html 后缀结尾的文件，因此将其俗称为 HTML 文件。 1.2 什么是HTMLHTML 指的是超文本标记语言 (Hyper Text Markup Language) ，它是用来描述网页的一种语言。 HTML 不是一种编程语言，而是一种标记语言 (markup language)。 标记语言是一套标记标签 (markup tag)。 所谓超文本，有 2 层含义： 它可以加入图片、声音、动画、多媒体等内容（超越了文本限制 ）。 它还可以从一个文件跳转到另一个文件，与世界各地主机的文件连接（超级链接文本 ）。 1.3 网页的形成网页是由网页元素组成的，这些元素是利用 html 标签描述出来，然后通过浏览器解析来显示给用户的。 二. 浏览器2.1 常用浏览器浏览器是网页显示、运行的平台。常用的浏览器有 IE、火狐（Firefox）、谷歌（Chrome）、Safari和Opera等。平时称为五大浏览器。 2.2 浏览器内核浏览器内核（渲染引擎）： 负责读取网页内容，整理讯息，计算网页的显示方式并显示页面。 2.3 浏览器私有前缀 三. Web标准Web 标准是由 W3C 组织和其他标准化组织制定的一系列标准的集合。W3C（万维网联盟）是国际最著名的标准化组织。 3.1 为什么需要web标准 遵循 Web 标准除了可以让不同的开发人员写出的页面更标准、更统一外，还有以下优点： 让 Web 的发展前景更广阔。 内容能被更广泛的设备访问。 更容易被搜寻引擎搜索。 降低网站流量费用。 使网站更易于维护。 提高页面浏览速度。 3.2 Web标准的构成主要包括结构（Structure） 、表现（Presentation）和行为（Behavior）三个方面。 标准 解释 结构 结构用于对网页元素进行整理和分类，现阶段主要学HTML 表现 表现用于设置网页元素的版式、颜色、大小等外观形式，主要是指CSS 行为 行为是指网页模型的定义及交互的编写，现阶段主要学的是JavaScript Web 标准提出的最佳体验方案：结构、样式、行为相分离。 简单理解： 结构写到 HTML 文件中， 表现写到 CSS 文件中， 行为写到 JavaScript 文件中。 四. 查阅文档经常查阅文档是个非常好的习惯 推荐的网址： 百度：http://www.baidu.com W3C：http://www.w3school.com.cn/ MDN：https://developer.mozilla.org/zh-CN/ 关于HTML的知识请查看[[HTML的怎么使用，开发工具以及常用标签。]]，直接复制右上角搜索即可","categories":[{"name":"技能之树","slug":"技能之树","permalink":"https://bingshanyishu.github.io/categories/%E6%8A%80%E8%83%BD%E4%B9%8B%E6%A0%91/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://bingshanyishu.github.io/tags/%E5%89%8D%E7%AB%AF/"}],"author":"Sankey"},{"title":"HTML的怎么使用，开发工具以及常用标签。","slug":"HTML的怎么使用，开发工具以及常用标签。","date":"2022-03-09T07:59:38.000Z","updated":"2022-03-09T10:34:06.972Z","comments":true,"path":"posts/202203091600.html","link":"","permalink":"https://bingshanyishu.github.io/posts/202203091600.html","excerpt":"","text":"HTML的怎么使用，开发工具以及常用标签。 前端学习：学习地址：黑马程序员pink老师前端入门教程，零基础必看的h5(html5)+css3+移动，下面这些都是一些学习笔记。临渊羡鱼，不如退而结网！！愿我自己学有所成，也愿每个前端爱好者学有所成 一. HTML语法规范1.1 基本语法概述 HTML 标签是由尖括号包围的关键词，例如 &lt;html&gt; HTML 标签通常是成对出现的，例如&lt;html&gt;和 &lt;/html&gt;称为双标签。标签对中的第一个标签是 开始标签，第二个标签是结束标签。 有些特殊的标签必须是单个标签（极少情况），例如&lt;br/&gt;，我们称为单标签。 1.2 标签关系双标签关系可以分为两类：包含关系和并列关系。 1.3 第一个HTML网页每个网页都会有一个基本的结构标签（也称为骨架标签），页面内容也是在这些基本标签上书写。 HTML页面也称为 HTML 文档. &lt;html&gt; &lt;head&gt; &lt;title&gt;我的第一个页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 你我皆是黑马,一飞冲天 &lt;/body&gt; &lt;/html&gt; HTML 文档的的后缀名必须是 .html 或 .htm ，浏览器的作用是读取 HTML 文档，并以网页的形式显示出它们。此时，用浏览器打开这个网页，我们就可以预览我们写的第一个 HTML 文件了。 二. 开发工具与目录路径 2.1 VSCode 双击打开软件。 新建文件（Ctrl + N ）。 保存（Ctrl + S ）, 注意移动要保存为 .html 文件 Ctrl + 加号键 ，Ctrl + 减号键 可以放大缩小视图 生成页面骨架结构。输入! 按下 Tab 键。 利用插件在浏览器中预览页面：单击鼠标右键，在弹出窗口中点击“Open In Default Browser” 2.2 VSCode 工具生成骨架标签新增代码2.2.1 文档类型声明标签&lt;!DOCTYPE&gt; 文档类型声明，作用就是告诉浏览器使用哪种HTML版本来显示网页。 &lt;!DOCTYPE html&gt; 这句代码的意思是: 当前页面采取的是 HTML5 版本来显示网页. 注意: 声明位于文档中的最前面的位置，处于 标签之前。 &lt;!DOCTYPE&gt;不是一个 HTML 标签，它就是 文档类型声明标签。 2.2.2 lang 语言用来定义当前文档显示的语言。 en定义语言为英语 zh-CN定义语言为中文 简单来说,定义为en 就是英文网页, 定义为 zh-CN 就是中文网页，其实对于文档显示来说，定义成en的文档也可以显示中文，定义成zh-CN的文档也可以显示英文。这个属性对浏览器和搜索引擎(百度.谷歌等)是有作用的， 2.2.3 charset 字符集字符集 (Character set)是多个字符的集合。以便计算机能够识别和存储各种文字。在&lt;head&gt;标签内，可以通过&lt;meta&gt; 标签的 charset 属性来规定 HTML 文档应该使用哪种字符编码。 &lt;meta charset=\" UTF-8\" /&gt; charset 常用的值有：GB2312 、BIG5 、GBK 和 UTF-8，其中 UTF-8 也被称为万国码，基本包含了全世界所有国家需要用到的字符. 注意：上面语法是必须要写的代码，否则可能引起乱码的情况。一般情况下，统一使用“UTF-8”编码，尽量统一写成标准的 “UTF-8”，不要写成 “utf8” 或 “UTF8”。 2.3 目录与路径2.3.1 目录文件夹和根目录实际工作中，我们的文件不能随便乱放，否则用起来很难快速的找到他们，因此我们需要一个文件夹来管理他们。 目录文件夹：就是普通文件夹，里面只不过存放了我们做页面所需要的相关素材，比如 html 文件、图片等。 根目录：打开目录文件夹的第一层就是根目录 2.3.2 相对路径与绝对路径页面中的图片会非常多， 通常我们会新建一个文件夹来存放这些图像文件（images），这时再查找图像，就需要采用“路径”的方式来指定图像文件的位置。路径可以分为： 相对路径 相对路径：以引用文件所在位置为参考基础，而建立出的目录路径。 相对路径就是从代码所在的这个文件出发，去寻找目标文件。 绝对路径 绝对路径：是指目录下的绝对位置，直接到达目标位置，通常是从盘符开始的路径。例如，“D:\\web\\img\\logo.gif”或完整的网络地址“http://www.baidu.com”。 四. HTML常用标签学习标签是有技巧的，重点是记住每个标签的语义。简单理解就是指标签的含义，即这个标签是用来干嘛的。根据标签的语义，在合适的地方给一个最为合理的标签，可以让页面结构更清晰。 4.1 标题标签为了使网页更具有语义化，我们经常会在页面中用到标题标签。HTML 提供了 6 个等级的网页标题，即&lt;h1&gt; -&lt;h6&gt; 单词 head 的缩写，意为头部、标题。 &lt;h1&gt;标题一共六级选,&lt;/h1&gt; &lt;h2&gt;文字加粗一行显。&lt;/h2&gt; &lt;h3&gt;由大到小依次减，&lt;/h3&gt; &lt;h4&gt;从重到轻随之变。&lt;/h4&gt; &lt;h5&gt;语法规范书写后，&lt;/h5&gt; &lt;h6&gt;具体效果刷新见。&lt;/h6&gt; 标签语义：作为标题使用，并且依据重要性递减。 特点： 加了标题的文字会变的加粗，字号也会依次变大。 一个标题独占一行。 4.2 段落标签在网页中，要把文字有条理地显示出来，就需要将这些文字分段显示。在 HTML 标签中，&lt;p&gt;标签用于定义段落，它可以将整个网页分为若干个段落。单词 paragraph [ˈpærəgræf] 的缩写，意为段落。 &lt;p&gt; 我是一个段落标签 &lt;/p&gt; 标签语义：可以把 HTML 文档分割为若干段落。 特点： 文本在一个段落中会根据浏览器窗口的大小自动换行。 段落和段落之间保有空隙 4.3 换行标签在 HTML 中，一个段落中的文字会从左到右依次排列，直到浏览器窗口的右端，然后才自动换行。如果希望某段文本强制换行显示，就需要使用换行标签 &lt;br/&gt;。单词 break 的缩写，意为打断、换行。 &lt;br/&gt; 标签语义：强制换行。 特点： &lt;br /&gt; 是个单标签。 &lt;br /&gt; 标签只是简单地开始新的一行，跟段落不一样，段落之间会插入一些垂直的间距。 以上标签小案列 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;体育新闻&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;水花61分伊戈达拉制胜抢断 西决勇士再胜开拓者总分2-0&lt;/h1&gt; &lt;h4&gt;数据统计：水花兄弟合砍61分&lt;/h4&gt; &lt;p&gt; 库里22投11中，三分14投4中，罚球11罚全中得到37分8篮板8助攻，职业生涯季后赛得分30+次数来到35次，超过哈登排名现役第3位，仅次于詹姆斯和杜兰特。&lt;/p&gt; &lt;p&gt;汤普森22投8中，三分8投4中得到24分3篮板2助攻，德拉蒙德-格林得到16分10篮板7助攻5盖帽，凯文-鲁尼得到14分7篮板2助攻，今天勇士有7名替补出场。&lt;/p&gt; &lt;h4&gt;兄弟对决升级：小库里给哥哥造成压力&lt;/h4&gt; &lt;p&gt; 库里兄弟是NBA历史上第一对在分区决赛相遇的兄弟。在西决第1场中，小库里没有给哥哥造成压力，他出场19分钟，7投1中只得到3分3篮板2助攻，在场期间输掉10分。&lt;/p&gt; &lt;p&gt;但在西决第2场中，小库里攻防两端都打出杰出的表现，全场送出4次抢断，包括直接抢断自己的哥哥库里，在防守端给库里造成了极大的困扰。&lt;/p&gt; &lt;p&gt; 作者: pink老师 &lt;br /&gt; 2019-8-8&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 4.3 文本格式化标签在网页中，有时需要为文字设置粗体、斜体 或下划线等效果，这时就需要用到 HTML 中的文本格式化标签，使文字以特殊的方式显示。标签语义: 突出重要性, 比普通文字更重要. 语义 标签 说明 加粗 &lt;strong&gt;&lt;/strong&gt;或者&lt;b&gt;&lt;\\b&gt; 更推荐使用标签&lt;strong&gt;加粗，语义更强烈 倾斜 &lt;em&gt;&lt;/em&gt;或者&lt;i&gt;&lt;/i&gt; 更推荐使用&lt;em&gt;标签倾斜，语义更强烈 删除线 &lt;del&gt;&lt;/del&gt;或者&lt;s&gt;&lt;/s&gt; 更推荐使用&lt;del&gt;标签做删除线，语义更强烈 下划线 &lt;ins&gt;&lt;/ins&gt;或者&lt;u&gt;&lt;/u&gt; 更推荐使用&lt;ins&gt;标签做下划线，语义更强烈 4.4 div&amp;span标签&lt;div&gt; 和 &lt;span&gt; 是没有语义的，它们就是一个盒子，用来装内容的，布局的。 div 是 division 的缩写，表示分割、分区。span 意为跨度、跨距。 &lt;div&gt; 这是头部 &lt;/div&gt; 独占一行 &lt;span&gt; 今日价格 &lt;/span&gt; 一行放多个，跨行显示 特点： &lt;div&gt; 标签用来布局，但是现在一行,只能放一个&lt;div&gt;。 大盒子 &lt;span&gt; 标签用来布局，一行上可以多个 &lt;span&gt;。小盒子 4.5 图像标签在 HTML 标签中，&lt;img&gt; 标签用于定义 HTML 页面中的图像。 单词 image 的缩写，意为图像。src 是&lt;img&gt;标签的必须属性，简单理解就是属于这个图像标签的特性，它用于指定图像文件的路径和文件名。 &lt;img src=\"图像路径path\" alt=\"图片\"&gt; 其他属性： 属性 属性值 说明 src 图片路径 必须属性 alt 文本 替换文本。图像不能显示的文字 title 文本 提示文本。鼠标放到图像上，显示的文字 width 像素 设置图像的宽度 height 像素 设置图像的高度 border 像素 设置图像的边框粗细 &lt;img src=\"C:\\Users\\27532\\Desktop\\设计资源\\Tableau-Server-Icon.png\" alt=\"图片\" title=\"这是title\"&gt; 图像标签属性注意点： 图像标签可以拥有多个属性，必须写在标签名的后面。 属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。 属性采取键值对的格式，即 key=“value” 的格式，属性 =“属性值”。 4.6 超链接标签在 HTML 标签中，&lt;a&gt; 标签用于定义超链接，作用是从一个页面链接到另一个页面。 4.6.1 链接的语法格式&lt;a href=\"跳转目标\" target=\"目标窗口的弹出方式\"&gt; 文本或图像（链接显示样） &lt;/a&gt; 单词 anchor [ˈæŋkə(r)] 的缩写，意为：锚。 属性 作用 href 用于指定链接目标的url地址，（必须属性）当为标签应用href属性时，它就具有了超链接的功能 target 用于指定链接页面的打开方式，其中_self为默认值，_blank为在新窗口中打开方式。 4.6.2 链接的分类 外部链接: 例如 \\&lt;a href=\"http:// www.baidu.com \"&gt; 百度&lt;/a&gt;。 内部链接:网站内部页面之间的相互链接. 直接链接内部页面名称即可，例如 \\&lt;a href=\"index.html\"&gt; 首页 &lt;/a&gt;。 空链接: 如果当时没有确定链接目标时，&lt;a href=\"#\"&gt; 首页 &lt;/a&gt; 。 下载链接: 如果 href 里面地址是一个文件或者压缩包，会下载这个文件。 网页元素链接: 在网页中的各种网页元素，如文本、图像、表格、音频、视频等都可以添加超链接. 锚点链接: 点我们点击链接,可以快速定位到页面中的某个位置. 在链接文本的 href 属性中，设置属性值为 #名字 的形式，如&lt;a href=\"#two\"&gt; 第2集 &lt;/a&gt; 找到目标位置标签，里面添加一个 **id 属性 ，如：&lt;h3 id=\"two\"&gt;第2集介绍&lt;/h3&gt; 4.7 注释如果需要在 HTML 文档中添加一些便于阅读和理解但又不需要显示在页面中的注释文字，就需要使用注释标签。HTML中的注释以“&lt;!--”开头，以“ --&gt;”结束。快捷键: ctrl + / &lt;!-- 注释语句 --&gt; 4.8 特殊字符在 HTML 页面中，一些特殊的符号很难或者不方便直接使用，此时我们就可以使用下面的字符来替代。","categories":[{"name":"技能之树","slug":"技能之树","permalink":"https://bingshanyishu.github.io/categories/%E6%8A%80%E8%83%BD%E4%B9%8B%E6%A0%91/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://bingshanyishu.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"HTML","slug":"HTML","permalink":"https://bingshanyishu.github.io/tags/HTML/"}],"author":"Sankey"},{"title":"利用Scrapy爬虫框架快速进行数据抓取","slug":"利用Scrapy爬虫框架快速进行数据抓取","date":"2022-03-08T10:31:33.000Z","updated":"2022-03-08T10:31:58.629Z","comments":true,"path":"posts/202203081831.html","link":"","permalink":"https://bingshanyishu.github.io/posts/202203081831.html","excerpt":"","text":"利用Scrapy爬虫框架快速进行数据抓取 你逆光而来，配得上世间所有的美好。 一. 基础概述Scrapy的基础概述与安装，有大佬已经写的很详细了，具体可去看看大佬的文章，下面是文章链接 Scrapy爬虫框架，入门案例（非常详细）_ck784101777的博客-CSDN博客_scrapy 我这里就加一些文章里没有的东西吧→_→ ←_← 二. 存储到MySQL在管道pipelines.py文件中添加一个新的类 #添加一个Mysql管道 class MysqlPipeline(object): #数据库初始化 def open_spider(self,spider): #连接到mysql数据库 self.db=pymysql.connect( host=MYSQL_HOST, user=MYSQL_USER, password=MYSQL_PWD, database=MYSQL_DB, charset=MYSQL_CHAR ) #创建游标操作数据库 self.cursor=self.db.cursor() #数据库的操作 def process_item(self, item, spider): ins='insert into films value(%s,%s,%s)' #插入时间，演员，上映时间 L=[item['name'],item['star'],item['time']] self.cursor.execute(ins,L) #提交数据库 self.db.commit() return item #关闭数据库 def close_spidr(self,spider): #关闭游标 self.cursor.close() #关闭数据库 self.db.close() 在settings.py中定义数据库信息，默认已经建好了数据库 #添加数据库配置信息 MYSQL_HOST='localhost' MYSQL_USER='root' MYSQL_PWD='123456' MYSQL_DB='filmsdb' MYSQL_CHAR='utf8' 将ITEM_PIPELINES取消注释，并添加Mysql管道配置 ITEM_PIPELINES = { 'Maoyan_thread.pipelines.MaoyanThreadPipeline': 300,# 400表示权重 #添加Mysql管道配置 'Maoyan_thread.pipelines.MysqlPipeline': 500,# 权重值越小，越优先执行！ } PIPELINES管道配置的一些注意事项 使用之前需要在settings中开启 pipeline在setting中键表示位置(即pipeline在项目中的位置可以自定义)，值表示距离引擎的远近，越近数据会越先经过：权重值小的优先执行 有多个pipeline的时候，process_item的方法必须return item,否则后一个pipeline取到的数据为None值 pipeline中process_item的方法必须有，否则item没有办法接受和处理 process_item方法接受item和spider，其中spider表示当前传递item过来的spider open_spider(spider) :能够在爬虫开启的时候执行一次 close_spider(spider) :能够在爬虫关闭的时候执行一次 上述俩个方法经常用于爬虫和数据库的交互，在爬虫开启的时候建立和数据库的连接，在爬虫关闭 的时候断开和数据库的连接 三. 非结构化的数据存储使用scrapy框架我们除了要下载文本，还有可能需要下载图片，scrapy提供了ImagePipeline来进行图片的下载。 这里以爬取360图片/美女为例来进行说明，话不多说，直接开始 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-GqqespVL-1646291370487)(https://gitee.com/Omnivore_zhang/cloud-image/raw/master/Spider/image-20220302195243757.png)] 先创建个scrapy项目，我命名为So，这里创建项目默认已经会了，不会的去看基础概述一 然后找到spiders文件夹下的so.py，再SoSpider类中添加下面代码 name = 'so' allowed_domains = ['image.so.com'] #注释start_urls # start_urls = ['http://image.so.com/'] url='https://image.so.com/zjl?ch=beauty&amp;sn={}' #多线程，重写start_requests方法 def start_requests(self): #爬取4页的数据 for sn in range(0,100,30): url=self.url.format(sn) yield scrapy.Request( url=url, callback=self.parse_page ) def parse_page(self, response): # 将json转换为字典 html=json.loads(response.text) print(html) #创建item对象 item=SoItem() for img in html['list']: item['img_link']=img['qhimg_url'] item['img_title']=img['title'] yield item #甩给了管道文件 在管道中添加一个类，添加以下方法 #导入ImagesPipeline from scrapy.pipelines.images import ImagesPipeline #继承管道类ImagesPipeline类 class SoPipeline(ImagesPipeline): def get_media_requests(self, item, info): print(item) yield scrapy.Request( url=item['img_link'], meta= {'title':item['img_title']} ) def file_path(self, request, response=None, info=None, *, item=None): title=request.meta['title'] filename = title + \".\" + request.url.split('.')[-1] return filename items.py文件中添加数据定义 class SoItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() img_link=scrapy.Field() img_title=scrapy.Field() settings.py中配置 #配置日志权限 LOG_LEVEL='WARNING' #配置相片路径 IMAGES_STORE='images/' #关闭机器人协议 ROBOTSTXT_OBEY = False 大概就可以了，重点就是继承ImagesPipeline类 四. scrapy shell的使用使用scrapy shell可以测试网址的url,headers,还能通过先通过xpath获取网页元素再写到代码中，减少调试次数 基本使用 http://httpbin.org/get # scrapy shell URL地址 直接在cmd中写 scrapy shell http://www.baidu.com *1、request.url : 请求URL地址 *2、request.headers ：请求头(字典) *3、reqeust.meta ：item数据传递，定义代理(字典) 4、response.text ：字符串 5、response.body ：bytes 6、response.xpath('/html/head/title/text()').get()#更真实 exit();#退出 五. 设置随机User-Agent通过改变User-Agent，可降低被爬取网址检测到的风险。 5.1 少量的User-Agent方法一： 在settings.py中设置 #取消注释，添加User-Agent USER_AGENT = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.102 Safari/537.36 Edg/98.0.1108.62' 或者设置在 DEFAULT_REQUEST_HEADERS = { 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8', 'Accept-Language': 'en', 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.102 Safari/537.36 Edg/98.0.1108.62' } 方法二: 在spider文件中的yield里面进行设置 # spider yield scrapy.Request(url,callback=函数名,headers={ 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.102 Safari/537.36 Edg/98.0.1108.62' }) 5.2 大量的User-Agentmiddlewares.py设置中间件 1、获取User-Agent # 方法1 ：新建useragents.py,存放大量User-Agent，random模块随机切换 # 方法2 ：安装fake_useragent模块(sudo pip3 install fack_useragent) from fake_useragent import UserAgent ua_obj = UserAgent() ua = ua_obj.random 2、middlewares.py新建中间件类 class RandomUseragentMiddleware(object): def process_request(self,reuqest,spider): ua = UserAgent() request.headers['User-Agent'] = ua.random 3、settings.py添加此下载器中间件 DOWNLOADER_MIDDLEWARES = { # 'Douban.middlewares.DoubanDownloaderMiddleware': 543, 'Douban.middlewares.RandomUseragentMiddleware':300 } 六. 设置随机代理1、新建一个proxies.py，定义一个列表，用于存储所有的代理IP proxies_list=[xxxx,xxxx,xxxx,xxxx,xxxx] 2、middlewares.py新建中间件类 class RandomProxyDownloaderMiddleware(object): def process_request(self,request,spider): request.meta['proxy'] = proxies_list.chioce() def process_exception(self,request,exception,spider): return request 3、settings.py添加此下载器中间件 DOWNLOADER_MIDDLEWARES = { # 'Douban.middlewares.DoubanDownloaderMiddleware': 543, 'Douban.middlewares.RandomProxyDownloaderMiddleware':300 } 七. 设置cookies有的网址需要设置cookies才能进行访问 方法一 直接在settings中设置 #取消这里的注释，让后添加cookies DEFAULT_REQUEST_HEADERS = { 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8', 'Accept-Language': 'en', 'Cookie': 'OUTFOX_SEARCH_USER_ID=-2094518326@10.110.96.159; OUTFOX_SEARCH_USER_ID_NCOO=654528686.5393351; JSESSIONID=aaabc05LV06Lq7Stpyd9x; ___rl__test__cookies=1646102934467', } 然后再取消Disable cookies的注释，注意其值必须是False才行 # Disable cookies (enabled by default) COOKIES_ENABLED = False 方法二 在spiders下面中的解析文件设置 #添加方法，返回为字典类型 def get_cookie(self): cs='OUTFOX_SEARCH_USER_ID=-2094518326@10.110.96.159; OUTFOX_SEARCH_USER_ID_NCOO=654528686.5393351; JSESSIONID=aaabc05LV06Lq7Stpyd9x; ___rl__test__cookies=1646102934467' cs_list=cs.split(';') cs_dict={} for c in cs_list: cs_dict[c.split('=')[0]]=c.split('=')[1] return cs_dict 然后yield里面直接赋值 yield scrapy.FormRequest( url=post_url, formdata=data, callback=self.parse, cookies=self.get_cookie() ) 方法三 在middlewares.py中添加类 class YoudaoCOookie(object): def get_cookie(self): cs = 'OUTFOX_SEARCH_USER_ID=-2094518326@10.110.96.159; OUTFOX_SEARCH_USER_ID_NCOO=654528686.5393351; JSESSIONID=aaabc05LV06Lq7Stpyd9x; ___rl__test__cookies=1646102934467' cs_list = cs.split(';') cs_dict = {} for c in cs_list: cs_dict[c.split('=')[0]] = c.split('=')[1] return cs_dict def process_request(self,request,spider): request.cookies=self.get_cookie() 然后在settings中设置 DOWNLOADER_MIDDLEWARES = { # 'Youdao.middlewares.YoudaoDownloaderMiddleware': 543, 'Youdao.middlewares.YoudaoCOookie':500 }","categories":[{"name":"技能之树","slug":"技能之树","permalink":"https://bingshanyishu.github.io/categories/%E6%8A%80%E8%83%BD%E4%B9%8B%E6%A0%91/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://bingshanyishu.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"scrapy","slug":"scrapy","permalink":"https://bingshanyishu.github.io/tags/scrapy/"}],"author":"Sankey"},{"title":"selenium在爬虫中的使用","slug":"selenium在爬虫中的使用","date":"2022-03-08T10:29:33.000Z","updated":"2022-03-08T10:29:52.271Z","comments":true,"path":"posts/202203081829.html","link":"","permalink":"https://bingshanyishu.github.io/posts/202203081829.html","excerpt":"","text":"selenium在爬虫中的使用一. selenium概述1.1 定义Selenium是一个Web的自动化测试工具，最初是为网站自动化测试而开发的，Selenium 可以直接调用浏览器，它支持所有主流的浏览器（包括PhantomJS这些无界面的浏览器），可以接收指令，让浏览器自动加载页面，获取需要的数据，甚至页面截屏等。我们可以使用selenium很容易完成爬虫的编写。 1.2 作用与工作原理利用浏览器原生的API，封装成一套更加面向对象的Selenium WebDriver API，直接操作浏览器页面里的元素，甚至操作浏览器本身（截屏，窗口大小，启动，关闭，安装插件，配置证书之类的） 二. selenium的安装2.1 在python中安装selenium模块pip install selenium 2.2下载webdriver(以edge浏览器为例)查看edge浏览器的版本，可以看到我这里为98.0.1108.62 webdriver不同浏览器下载地址，这里使用edge驱动 chrome驱动：http://chromedriver.storage.googleapis.com/index.html Firefox驱动：https://github.com/mozilla/geckodriver/releases/ edge驱动：https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/ 找到对应版本，点击x64即可下载 2.3 配置环境将其下载得到的msedgedriver.exe文件放在edge浏览器的目录下 将msedgedriver.exe文件所在目录的路径加到环境变量中 2.4 简单应用运用python打开浏览器，在百度中搜索python import time from selenium import webdriver #创建驱动对象 #注册环境变量的 # driver=webdriver.Edge() #没有注册的executable_path中放驱动所在的路径 driver=webdriver.Edge(executable_path='C:\\Program Files (x86)\\Microsoft\\Edge\\Application/msedgedriver.exe') driver.get('http://www.baidu.com') time.sleep(5) #在百度搜索框中搜索python driver.find_element_by_id('kw').send_keys('python') driver.find_element_by_id('su').click() time.sleep(6) driver.quit() 三. driver对象上面的例子大概有了webdriver的基本使用，下面创建一个driver对象 from selenium import webdriver #创建驱动对象 #注册环境变量的 # driver=webdriver.Edge() #没有注册的executable_path中放驱动所在的路径 driver=webdriver.Edge(executable_path='C:\\Program Files (x86)\\Microsoft\\Edge\\Application/msedgedriver.exe') 3.1 driver对象的常用属性和方法在使用selenium过程中，实例化driver对象后，driver对象有一些常用的属性和方法 driver.page_source 当前标签页浏览器渲染之后的网页源代码（不涉及到抓包源码，只需要拷贝就好了） driver.current_url 当前标签页的url（响应的） driver.close() 关闭当前标签页，如果只有一个标签页则关闭整个浏览器 driver.quit() 关闭浏览器 driver.forward() 页面前进 driver.back() 页面后退 driver.save_screenshot(img_name) 页面截图 3.2 定位标签元素在selenium中可以通过多种方式来定位标签，返回标签元素对象 find_element_by_id (返回一个元素) find_element(s)_by_class_name (根据类名获取元素列表) find_element(s)_by_name (根据标签的name属性值返回包含标签对象元素的列表) find_element(s)_by_xpath (返回一个包含元素的列表) find_element(s)_by_link_text (根据链接文本获取元素列表) find_element(s)_by_partial_link_text (根据链接包含的文本获取元素列表) find_element(s)_by_tag_name (根据标签名获取元素列表) find_element(s)_by_css_selector (根据css选择器来获取元素列表) 注意： find_element和find_elements的区别： 多了个s就返回列表，没有s就返回匹配到的第一个标签对象 find_element匹配不到就抛出异常，find_elements匹配不到就返回空列表 by_link_text和by_partial_link_text的区别：全部文本和包含某个文本 3.3 提取文本内容find_element仅仅能够获取元素，不能够直接获取其中的数据，如果需要获取数据需要使用以下方法 对元素执行点击操作 element.click() 对定位到的标签对象进行点击操作 向输入框输入数据 element.send_keys(data) 对定位到的标签对象输入数据 获取文本 element.text 通过定位获取的标签对象的 text 属性，获取文本内容 获取属性值 element.get_attribute(\"属性名\") 通过定位获取的标签对象的 get_attribute 函数，传入属性名，来获取属性的值 小栗子： 以58同城–&gt;合租为例，抓取当前页面的所有房屋名称和链接 import time from selenium import webdriver #创建驱动对象 #注册环境变量的 # driver=webdriver.Edge() #没有注册的executable_path中放驱动所在的路径 driver=webdriver.Edge(executable_path='C:\\Program Files (x86)\\Microsoft\\Edge\\Application/msedgedriver.exe') driver.get('https://hz.58.com/hezu/?utm_source=market&amp;spm=u-2d2yxv86y3v43nkddh1.BDPCPZ_BT&amp;PGTID=0d100000-0004-f0eb-30f2-60c6680bc9c2&amp;ClickID=2') a_list=driver.find_elements_by_xpath('/html/body/div[6]/div[2]/ul/li/div[2]/h2/a') for a in a_list: print(a.text,a.get_attribute('href')) driver.quit() 运行结果： 四. selenium标签页的切换4.1 网页标签页切换当selenium控制浏览器打开多个标签页时，如何控制浏览器在不同的标签页中进行切换呢？需要我们做以下两步： 获取所有标签页的窗口句柄 利用窗口句柄字切换到句柄指向的标签页 这里的窗口句柄是指：指向标签页对象的标识 具体方法 # 1. 获取当前所有的标签页的句柄构成的列表 current_windows = driver.window_handles # 2. 根据标签页句柄列表索引下标进行切换 driver.switch_to.window(current_windows[0]) 例子: 打开两个页面，并切换到第二个 import time from selenium import webdriver driver=webdriver.Edge(executable_path='C:\\Program Files (x86)\\Microsoft\\Edge\\Application/msedgedriver.exe') driver.get('http://www.baidu.com') time.sleep(3) driver.find_element_by_id('kw').send_keys('python') driver.find_element_by_id('su').click() #通过执行js，开启一个标签 js='window.open(\"https://www.sogou.com\")' # 执行js代码 driver.execute_script(js) #获取所有窗口 windows=driver.window_handles time.sleep(3) #根据窗口索引切换 driver.switch_to.window(windows[0]) time.sleep(3) driver.switch_to.window(windows[1]) time.sleep(3) driver.quit() 二级58爬取 import time from selenium import webdriver #创建驱动对象 #注册环境变量的 # driver=webdriver.Edge() #没有注册的executable_path中放驱动所在的路径 driver=webdriver.Edge(executable_path='C:\\Program Files (x86)\\Microsoft\\Edge\\Application/msedgedriver.exe') driver.get('http://www.58.com') time.sleep(1) # 点击合租链接 driver.find_element_by_xpath('/html/body/div[3]/div[1]/div[1]/div/div[1]/div[1]/span[3]/a').click() time.sleep(1) #切换窗口 driver.switch_to.window(driver.window_handles[-1]) time.sleep(1) #通过xpath找到对象列表 a_list=driver.find_elements_by_xpath('/html/body/div[6]/div[2]/ul/li/div[2]/h2/a') for a in a_list: print(a.text,a.get_attribute('href')) driver.quit() 4.2 iframe标签切换frame是html中常用的一种技术，即一个页面中嵌套了另一个网页，selenium默认是访问不了iframe中的内容的，对应的解决思路是 通过xpath找到iframe对象 frame_element（xpath也是看不到内容的） 通过driver.switch_to.frame(frame_element）就可以进入到iframe的页面了 通过id找到“账户密码登录”的连接，点击它进入“账户密码登录页面” 通过id找到账号和密码的输入框以及登录的按钮 例子：登录QQ空间 import time from selenium import webdriver #创建驱动对象 #注册环境变量的 # driver=webdriver.Edge() #没有注册的executable_path中放驱动所在的路径 driver=webdriver.Edge(executable_path='C:\\Program Files (x86)\\Microsoft\\Edge\\Application/msedgedriver.exe') driver.get('http://i.qq.com') time.sleep(1) l_iframe=driver.find_element_by_xpath('//*[@id=\"login_frame\"]') print(l_iframe) #进入ifram标签页 driver.switch_to.frame(l_iframe) driver.find_element_by_id('switcher_plogin').click() time.sleep(1) #输入账号 driver.find_element_by_id('u').send_keys('你的QQ账号') time.sleep(1) #输入密码 driver.find_element_by_id('p').send_keys('*你的密码') time.sleep(1) driver.find_element_by_id('login_button').click() time.sleep(10) #滑块标签，手动拖后再来一次 driver.find_element_by_id('login_button').click() driver.quit() 五. 获取cookies5.1 cookie概述Cookie，有时也用其复数形式Cookies，指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据(通常经过加密)。定义于RFC2109和2965都已废弃，最新取代的规范是RFC6265。 Cookie是由服务器端生成，发送给User-Agent（一般是浏览器），浏览器会将Cookie的key/value保存到某个目录下的文本文件内，下次请求同一网站时就发送该Cookie给服务器（前提是浏览器设置为启用cookie）。Cookie名称和值可以由服务器端开发自己定义，对于JSP而言也可以直接写入jsessionid，这样服务器可以知道该用户是否合法用户以及是否需要重新登录等。 用途 服务器可以利用Cookies包含信息的任意性来筛选并经常性维护这些信息，以判断在HTTP传输中的状态。Cookies最典型的应用是判定注册用户是否已经登录网站，用户可能会得到提示，是否在下一次进入此网站时保留用户信息以便简化登录手续，这些都是Cookies的功用。另一个重要应用场合是“购物车”之类处理。用户可能会在一段时间内在同一家网站的不同页面中选择不同的商品，这些信息都会写入Cookies，以便在最后付款时提取信息。 5.2 获取cookiedriver.get_cookies() 返回列表，其中包含的是完整的cookie信息！不光有name、value，还有domain等cookie其他维度的信息。所以如果想要把获取的cookie信息和requests模块配合使用的话，需要转换为name、value作为键值对的cookie字典 # 获取当前标签页的全部cookie信息 print(driver.get_cookies()) # 把cookie转化为字典 cookies_dict = {cookie[‘name’]: cookie[‘value’]} for cookie in driver.get_cookies()} 5.3 删除cookie#删除一条cookie driver.delete_cookie(\"CookieName\") # 删除所有的cookie driver.delete_all_cookies() 六. 页面等待6.1 强制等待 其实就是time.sleep() 缺点时不智能，设置的时间太短，元素还没有加载出来；设置的时间太长，则会浪费时间 6.2 隐式等待 隐式等待针对的是元素定位，隐式等待设置了一个时间，在一段时间内判断元素是否定位成功，如 果完成了，就进行下一步 在设置的时间内没有定位成功，则会报超时加载 示例代码 from selenium import webdriver driver = webdriver.Chrome() driver.implicitly_wait(10) # 隐式等待，最长等10秒 driver.get('https://www.baidu.com') driver.find_element_by_xpath() 6.3 显示等待每经过多少秒就查看一次等待条件是否达成，如果达成就停止等待，继续执行后续代码 如果没有达成就继续等待直到超过规定的时间后，报超时异常 import time from selenium import webdriver from selenium.webdriver.support.wait import WebDriverWait from selenium.webdriver.support import expected_conditions as ec from selenium.webdriver.common.by import By #创建驱动对象 #注册环境变量的 # driver=webdriver.Edge() #没有注册的executable_path中放驱动所在的路径 driver=webdriver.Edge(executable_path='C:\\Program Files (x86)\\Microsoft\\Edge\\Application/msedgedriver.exe') driver.get('http://baidu.com') WebDriverWait(driver,20,0.5).until( ec.presence_of_element_located((By.LINK_TEXT,'hao123')) ) print(driver.find_element_by_link_text('hao123').get_attribute('href')) driver.quit() 七. selenium反反爬7.1 使用代理ip使用代理ip的方法 #实例化配置对象 options = webdriver.ChromeOptions() #配置对象添加使用代理ip的命令 options.add_argument('--proxy-server=http://202.20.16.82:9527') 实例化带有配置对象的driver对象 #driver = webdriver.Edge(chrome_options=options) 7.2 替换user-agent#实例化配置对象 options = webdriver.ChromeOptions() #配置对象添加替换UA的命令 options.add_argument('--user-agent=Mozilla/5.0 HAHA') #实例化带有配置对象的driver对象 driver = webdriver.Edge(chrome_options=options) 7.3 斗鱼网爬取import time from selenium.webdriver.common.by import By from selenium import webdriver class DouYuSpider(object): def __init__(self): self.url='https://www.douyu.com/directory/all' # self.opt=webdriver.EdgeOptions().add_argument('--headless') self.driver=webdriver.Edge(executable_path='C:\\Program Files (x86)\\Microsoft\\Edge\\Application/msedgedriver.exe') def parse_data(self): time.sleep(10) #取直播间的列表 room_list=self.driver.find_elements_by_xpath('//*[@id=\"listAll\"]/section[2]/div[2]/ul/li/div') print(len(room_list)) data_list=[]#存放所有数据的列表 #遍历room_list抓取每个直播间的数据 for r in room_list: temp={} temp['title']=r.find_element_by_xpath('./a/div[2]/div[1]/h3').text temp['type']=r.find_element_by_xpath('./a/div[2]/div[1]/span').text temp['owner']=r.find_element_by_xpath('./a/div[2]/div[2]/h2/div').text temp['num']=r.find_element_by_xpath('./a/div[2]/div[2]/span').text #这里有问题,使用下面注释的无法抓取 temp['image']=self.driver.find_element_by_xpath('//*[@id=\"listAll\"]/section[2]/div[2]/ul/li/div/a/div[1]/div[1]/picture/img').get_attribute('src') # temp['image'] = r.find_element_by_xpath('./a/div[1]/div[1]/picture/img').get_attribute('src') data_list.append(temp) return data_list,len(room_list) def save_data(self,data_list): for data in data_list: print(data) def main(self): # 页数 number=0 self.driver.get(self.url) while True: data_list,num=self.parse_data() self.save_data(data_list) if num&lt;120: break try: self.driver.execute_script('scrollTo(0,1000000)') # el_text=self.driver.find_element_by_xpath('//*[@id=\"listAll\"]/section[2]/div[2]/div/ul/li[9]/span') #也可以这样写 el_text=self.driver.find_element(by=By.XPATH,value='//*[contains(text(),\"下一页\")]') el_text.click() number+=1 print(f'第{number}页') except Exception as e: print(e) break self.driver.quit() if __name__ == '__main__': spider=DouYuSpider() spider.main() 八. 无界面模式使用selenium会调用浏览器进行运行，如果不想让浏览器吊出来，可加入以下配置 实例化配置对象 options = webdriver.EdgeOptions() 配置对象添加开启无界面模式的命令 options.add_argument(\"--headless\") 一般一个就够了 配置对象添加禁用gpu的命令 options.add_argument(\"--disable-gpu\") 实例化带有配置对象的driver对象 driver = webdriver.Edge(options=options) 注意：macos中chrome浏览器59+版本，Linux中57+版本才能使用无界面模式！","categories":[{"name":"技能之树","slug":"技能之树","permalink":"https://bingshanyishu.github.io/categories/%E6%8A%80%E8%83%BD%E4%B9%8B%E6%A0%91/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://bingshanyishu.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"selenium","slug":"selenium","permalink":"https://bingshanyishu.github.io/tags/selenium/"}],"author":"Sankey"},{"title":"爬虫基本知识，如何发起请求，进行分析","slug":"爬虫基本知识，如何发起请求，进行分析","date":"2022-03-08T09:58:33.000Z","updated":"2022-03-08T10:22:42.750Z","comments":true,"path":"posts/202203081800.html","link":"","permalink":"https://bingshanyishu.github.io/posts/202203081800.html","excerpt":"","text":"爬虫基础知识 爬虫一个实战性很强的内容，下面是一些知识点，方便日后复习，具体还要去案例看看，随机应变。这是我的github爬虫仓库github-spider，欢迎大家clone进行学习和体验。 一. 网络爬虫概述定义 网络蜘蛛(spider)、网络机器人(robot)，抓取网络数据的程序 其实就是用Python程序模仿人点击浏览器并访问网站，而且模仿的越像越好，让Web站点无法发现你不是人 爬取数据的目的 1、公司项目测试数据2、公司业务部门及其他部门所需数据3、数据分析 企业获取数据方式 1、公司自有数据2、第三方数据平台购买(tushare,数据堂、贵阳大数据交易所)3、爬虫爬取数据 Python做爬虫优势 1、Python ：请求模块、解析模块丰富成熟,强大的Scrapy网络爬虫框架2、PHP ：对多线程、异步支持不太好3、JAVA：代码笨重,代码量大4、C/C++：虽然效率高,但是代码成型慢 爬虫爬取数据步骤 1、确定需要爬取的URL地址2、由请求模块向URL地址发出请求,并得到网站的响应（网页的源码）3、从响应内容中提取所需数据 1、所需数据,保存 2、页面中有其他需要继续跟进的URL地址,继续第2步去发请求，如此循环 二. 爬虫请求模块2.1 headers重构直接访问网址，网址会直接判断为爬虫程序而非真人操作，可使用下面函数进行模仿 urllib.request.Request(url,headers) 1、url：请求的URL地址 2、headers：添加请求头（爬虫和反爬虫斗争的第一步） #headers={'User-Agent':'sdfsdfsd'}#百度 User-Agent需要去网上搜索一个进行重构，不过令人高兴的是有直接获取随机User-Agent的库 1、安装fake_useragent类库2、引用fake_useragent类库3、创建对象，通过random获取随机User-Agent 使用方法 from fake_useragent import UserAgent ua=UserAgent() headers={ 'User-Agent': ua.random } 直接传给header对象即可 2.1 request获取模块名导入 1、模块名：urllib.request 2、导入方式： 1、import urllib.request 2、from urllib import request 使用方法 urllib.request.urlopen(url,timeout) 参数 1、url：需要爬取的URL地址 2、timeout: 设置等待超时时间,指定时间内未得到响应抛出超时异常 进行headers重构后 req=request.Request(url=url,headers=headers) res = request.urlopen(req) 小栗子： 向测试网站（http://httpbin.org/get）发起请求，构造请求头并从响应中确认请求头信息 from urllib import request #定义常用变量 url headers url='http://httpbin.org/get' headers={ 'User-Agent':'Opera/9.80 (Windows NT 6.1; U; zh-cn) Presto/2.9.168 Version/11.50' } #1.创建请求对象 req=request.Request(url=url,headers=headers) #2.获取请求的返回对象 res=request.urlopen(req) #3.提取响应内容 html=res.read().decode('utf-8') print(html) 补充：响应对象（response）方法 1、bytes = response.read() # read()得到结果为 bytes 数据类型 2、string = response.read().decode() # decode() 转为 string 数据类型 3、url = response.geturl() # 返回实际数据的URL地址 4、code = response.getcode() # 返回HTTP响应码 5、string.encode() # bytes -&gt; string 6、bytes.decode() # string -&gt; bytes 2.2 URL地址编码模块当需要获取其他页面就需要进行URL地址进行编码 # 模块名 urllib.parse # 导入 import urllib.parse from urllib import parse 常用方法 urllib.parse.urlencode({dict}) URL地址中一个查询参数 # 查询参数：{'wd' : '美女'} # urlencode编码后：'wd=%e7%be%8e%e5%a5%b3' # 示例代码 query_string = {'wd' : '美女'} result = urllib.parse.urlencode(query_string) # result: 'wd=%e7%be%8e%e5%a5%b3' URL地址中多个查询参数 from urllib import parse params = { 'wd' : '美女', 'pn' : '50' } params = parse.urlencode(query_string_dict) url = 'http://www.baidu.com/s?{}'.format(params) print(url) urllib.parse.quote(string)编码 from urllib import parse string = '美女' print(parse.quote(string)) # 结果: %E7%BE%8E%E5%A5%B3 #只编译中文 urllib.parse.unquote(string)解码 from urllib import parse string = '%E7%BE%8E%E5%A5%B3' result = parse.unquote(string) print(result) 四. 解析获得的html页面并没有什么用处，需要使用解析模块进行解析 4.1 正则re解析正则解析是一个很齐全的方法 #首先导入正则模块 import re #建立pattern对象 pattern = re.compile('正则表达式',re.S) #得到解析内容 r_list = pattern.findall(html) 正则表达式写法 贪婪匹配(默认) ： .* 非贪婪匹配 ： .*?，一般使用.*? 1、想要什么内容在正则表达式中加(.*?)，有空格或者不确定的地方就加.*? 2、多个分组,先按整体正则匹配,然后再提取()中数据。结果：[(),(),(),(),()] 正则表达式元字符 案例：这里以明日方舟贴吧的html进行说明 爬取html页面模块 from urllib import request from urllib import parse def get_url(wd): url='https://tieba.baidu.com/f?{}' params=parse.urlencode({'kw':wd}) url=url.format(params) return url def request_url(url,filename): headers = { 'User-Agent': 'Opera/9.80 (Windows NT 6.1; U; zh-cn) Presto/2.9.168 Version / 11.50' } req=request.Request(url=url,headers=headers) res = request.urlopen(req) # 提取响应内容 html = res.read().decode('utf-8') # 保存数据 with open(filename, 'w', encoding='utf-8') as f: f.write(html) if __name__ == '__main__': wd=input('请输入搜索内容：') url=get_url(wd) filename=wd+'.html' request_url(url,filename) 解析模块 import re # 明日方舟内容解析 with open('明日方舟.html','r',encoding='utf-8') as f: 注意re表达式的写法 pattern=re.compile('&lt;a rel=\"noopener\" href=\".*?\" title=\"(.*?)\".*?&lt;/div&gt;&lt;div class=\"threadlist_author pull_right\"&gt;.*?&lt;span class=\"tb_icon_author \".*?title=\"(.*?)\"',re.S) r_list=pattern.findall(f.read()) # print(r_list[0][1]) if r_list: for r in r_list: print(\"名字：\",r[1].replace(\"主题作者: \",\"\"),\"\\t\", \"标题：\",r[0].strip()) 4.2. xpath解析XPath即为XML路径语言，它是一种用来确定XML文档中某部分位置的语言，同样适用于HTML文档的检索 使用流程 1、导入模块 from lxml import etree 2、创建解析对象 parse_html = etree.HTML(html) 3、解析对象调用xpath r_list = parse_html.xpath('xpath表达式') 常用方法 1、contains() ：匹配属性值中包含某些字符串节点 # 查找id属性值中包含字符串 \"car_\" 的 li 节点 //li[contains(@id,\"car_\")] 2、text() ：获取节点的文本内容 # 查找所有汽车的价格 //li/p[@class=\"price\"]/text() 3.匹配多路径 xpath表达式1 | xpath表达式2 | xpath表达式3 示例 &lt;ul class=\"CarList\"&gt; &lt;li class=\"bjd\" id=\"car_001\" href=\"http://www.bjd.com/\"&gt; &lt;p class=\"name\"&gt;布加迪&lt;/p&gt; &lt;p class=\"model\"&gt;威航&lt;/p&gt; &lt;p class=\"price\"&gt;2500万&lt;/p&gt; &lt;p class=\"color\"&gt;红色&lt;/p&gt; &lt;/li&gt; &lt;li class=\"byd\" id=\"car_002\" href=\"http://www.byd.com/\"&gt; &lt;p class=\"name\"&gt;比亚迪&lt;/p&gt; &lt;p class=\"model\"&gt;秦&lt;/p&gt; &lt;p class=\"price\"&gt;15万&lt;/p&gt; &lt;p class=\"color\"&gt;白色&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; 1、查找所有的li节点 //li 2、获取所有汽车的名称 //li/p[@class='name']/text() 3、获取比亚迪的型号 //li/p[@class='model']/text() 4、获取每辆车的连接 //ul/li@href 五. 数据保存解析得到数据需要保存，一般使用csv，mysql，Mongo 5.1 保存csv文件使用流程 import csv with open('film.csv','w') as f: writer = csv.writer(f) writer.writerow([]) 示例 # 单行写入（writerow([])) import csv with open('test.csv','w',newline='') as f: writer = csv.writer(f) writer.writerow(['步惊云','36']) writer.writerow(['超哥哥','25']) # 多行写入(writerows([(),(),()] import csv #window下 需要加newline='' 否则会有空行的现象。数据都在但是 #会隔一个空行显示一条数据 with open('test.csv','w',newline='') as f: writer = csv.writer(f) writer.writerows([('聂风','36'),('秦霜','25'),('孔慈','30')]) # 存入csv文件 - writerows() def write_html(self,film_list): L = [] with open('film.csv','a') as f: # 初始化写入对象,注意参数f别忘了 writer = csv.writer(f) for film in film_list: t = ( film[0].strip(), film[1].strip(), film[2].strip()[5:15] ) L.append(t) # writerows()参数为列表 writer.writerows(L) 5.2 Mysql数据库首先需要建立一个数据库表用于存储数据 # 连接到mysql数据库 mysql -uroot -p123456 # 建库建表 create database filmsdb charset utf8; use maoyandb; create table films( name varchar(100), star varchar(300), time date )charset=utf8; 使用流程 导入pymysql import pymysql 建立连接 self.db=pymysql.connect(host='localhost',user='root',password='123456',database='filmsdb',charset='utf8') 建立游标 self.cursor=self.db.cursor() 提交单条数据 ins = 'insert into films values(%s,%s,%s)' for film in film_list: L = ( film[0].strip(), film[1].strip(), film[2].strip() ) self.cursor.execute(ins, L) # 千万别忘了提交到数据库执行 self.db.commit() 提交多条数据 # mysql - executemany([(),(),()]) 建议使用这种 def write_html(self, film_list): L = [] ins = 'insert into films values(%s,%s,%s)' for film in film_list: t = ( film[0].strip(), film[1].strip(), film[2].strip() ) L.append(t) self.cursor.executemany(ins, L) # 千万别忘了提交到数据库执行 self.db.commit() 5.3 Mongo数据库MongoDB是一个基于磁盘的菲关系型数据库（key-value）数据库，value为json串 常用命令 1.mongo #进入输入库 2.show dbs #查看所有库 3.use 库名 4.show collections #查看当前库的所有集合 5.db.集合名.find().pretty()#带格式的查询 6.db.集合名.count()#统计集合文档个数 7.db.dropDatabase()#删除数据库 使用流程 导入pymongo import pymysql 建立库 self.conn=pymongo.MongoClient('localhost',27017) self.db=self.conn['filmsdb'] 建立表名 self.myset=self.db['films'] 提交数据，注意提交格式为字典格式 def write_html(self, film_list): L = [] item={} for film in film_list: item['name']=film[0].strip(), film[1].strip(), film[2].strip() L.append(item) #添加单条数据 self.myset.insert_one(item) #添加多条数据 self.myset.insert_many(L) 六. requests获取6.1 常用方式requests相对于request对象，使用起来更加快速简洁，可相当于request加强版 # 向网站发起请求,并获取响应对象 res = requests.get(url,headers=headers) 常用方法 # print(res.encoding) # 取字符串 # print(res.text) # 取字节流 # print(res.content) # http响应码 # print(res.status_code) # 实际url # print(res.url) 6.2 URL地址编码不仅如此，对于2.3的URL地址编码，也可以直接进行赋值 import requests baseurl = 'http://tieba.baidu.com/f?' params = { 'kw' : '古力娜扎吧', 'pn' : '50' } headers = {'User-Agent' : 'Mozilla/4.0'} # 自动对params进行编码,然后自动和url进行拼接,去发请求 res = requests.get(url=baseurl,params=params,headers=headers) res.encoding = 'utf-8' print(res.text) 6.3 客户端认证-auth1、针对于需要web客户端用户名密码认证的网站 2、auth = ('username','password') 3、将auth放在requests.get()方法里面 6.3 SSL证书认证参数-verify1、适用网站: https类型网站但是没有经过 证书认证机构 认证的网站 2、适用场景: 抛出 SSLError 异常则考虑使用此参数适用网站及场景 参数类型 1、verify=True(默认) : 检查证书认证 2、verify=False（常用）: 忽略证书认证 # 示例 response = requests.get( url=url, params=params, headers=headers, verify=False ) 6.4 代理参数-proxies定义: 代替你原来的IP地址去对接网络的IP地址。作用: 隐藏自身真实IP,避免被封。 如何获取免费的代理Ip，可取下面下面网址看看，然后编写爬虫爬取并测试 89 芝麻 快代理 西刺代理 全网代理 代理精灵 import requests url='http://httpbin.org/get' headers={'User-Agent':'Mozilla/5.0'} #定义代理，在代理网站中找免费ip proxies={ 'http':'http://110.89.122.28:8080', 'https':'https://110.89.122.28:8080' } html=requests.get(url=url,proxies=proxies,headers=headers,timeout=5).text print(html) 6.5 requests.post()参数适用场景：Post类型请求的网站 response = requests.post(url,data=data,headers=headers) data参数 ：post数据（Form表单数据-字典格式） 七. 动态数据抓取7.1 爬取方法动态数据的抓取相对于静态数据来说，就是url不是网址具体的url，具体的url需要用调试工具进行调试，然后选择网络，XHR，下面的动态加载的内容就是由web后台发过来的动态数据，其格式为json格式 这里以豆瓣为例 标头里就是具体的json数据的请求url 将url用于requests.get()请求响应就会得到其数据，然后进行解析即可。 下面是具体的响应数据提取方法 7.2 json模块json.loads(json) 作用：把json格式的字符串转为Python数据类型——字典 示例：html_json = json.loads(res.text) json.dumps(python) 作用：把 python 类型 转为 json 类型 json.dump(python,f,ensure_ascii=False) 作用：将python的格式类型也就是字典，转换为json并存到文件里 json.dump(python,f,ensure_ascii=False) 第1个参数: python类型的数据(字典，列表等) 第2个参数: 文件对象 第3个参数: ensure_ascii=False # 序列化时编码 json.load(f) 作用：将json文件读取,并转为python类型 对于上面的get请求后，可通requests.get().json()获得json数据，这是最简单的方法， 也可以通过requests.get().text，然后再进行loads方法 7.3 jsonpath模块对于得到的json数据，我们可以一层一层的去提取，但是如果层数太多的化，提取就会很困难，而使用jsonpath模块就可以更加key和下标来批量提取value 安装 jsonpath是第三方模块，需要额外安装，直接使用命令pip install jsonpath即可安装使用了。 使用 from jsonpath import jsonpath #jsondata就是所取进行解析的json数据 ret = jsonpath(jsondata, 'jsonpath语法规则字符串') 这里举个使用例子,提取python import jsonpath data={'key1'：{'key2':{'key3':{'key4':{'key5':'key6':{'key7':python}}}}}} #进行提取 result=jsonpath.jsonpath(data,'$.key1.key2.key3.key4.key5.key6.key7')[0] #或者 result=jsonpath.jsonpath(data,'$..key7')[0]","categories":[{"name":"技能之树","slug":"技能之树","permalink":"https://bingshanyishu.github.io/categories/%E6%8A%80%E8%83%BD%E4%B9%8B%E6%A0%91/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://bingshanyishu.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"python","slug":"python","permalink":"https://bingshanyishu.github.io/tags/python/"}],"author":"Sankey"},{"title":"如何在hexo博客中在线阅读pdf","slug":"如何在hexo博客中在线阅读pdf","date":"2022-03-08T09:38:40.000Z","updated":"2022-03-11T14:41:56.275Z","comments":true,"path":"posts/202203081740.html","link":"","permalink":"https://bingshanyishu.github.io/posts/202203081740.html","excerpt":"","text":"前言 我这里是matery主题，其他主题的可参照相应思路进行修改关于matery的博客搭建可去参考环境搭建：[[个人知识树博客搭建一环境的安装与配置]]信息修改：[[博客搭建，修改基本信息，建立个人风格]]直接右上角点击搜素这两篇文字即可 有一些资料或者笔记是pdf版本的，如果想要放在博客中进行阅读，那么就得将其转换为markdown格式或者html格式。但是这样转换后，其原pdf的格式就会混乱了，排版将会变得很困难，不过一山更比一山高，由mozilla支持的在线pdf阅读插件就可让我们在网页中进行pdf的阅读。这是官方的示例那么我们该怎么使用呢？ 下载要使用那么最基础的就是我们要先下载，直接去官网在线pdf阅读插件下载官方已经压缩好的即可。如果去github下载源码还需要进行一些小操作。想挑战一下的可以去gihub地址跟着说明文档进行操作。这里我直接介绍去官网下载的。进入官网，点击Download点击左边那个Stable就可以下载了 使用（1）将下载到的文件解压，为了引入博客中方便直接将解压后的文件名pdfjs-2.13.216-dist改名为pdfjs。我们得到这样一个结构的文件，在该目录中创建一个文件夹，命名为data用于保存pdf文件。 ├── build/ │ ├── pdf.js - display layer │ ├── pdf.js.map - display layer's source map │ ├── pdf.worker.js - core layer │ └── pdf.worker.js.map - core layer's source map ├── web/ │ ├── cmaps/ - character maps (required by core) │ ├── compressed.tracemonkey-pldi-09.pdf - PDF file for testing purposes │ ├── debugger.js - helpful debugging features │ ├── images/ - images for the viewer and annotation icons │ ├── locale/ - translation files │ ├── viewer.css - viewer style sheet │ ├── viewer.html - viewer layout │ ├── viewer.js - viewer layer │ └── viewer.js.map - viewer layer's source map |——data/ -这是新建的data文件，用于保存pdf资源 └── LICENSE （2）然后将其放入到博客根文件下的resouce中，如下图所示，注意路径，不是主题文件的resouce （3）再在该路径下新建一个文件夹叫做pdf，pdf文件夹中新建index.md文件填入，日期随便填都可以 --- title: pdf date: 2022-03-03 16:40:27 type: \"pdf\" layout: \"pdf\" --- （4）在主题文件的layout文件D:\\HexoBlog\\themes\\hexo-theme-matery\\layout中新建一个pdf.ejs文件，这里作为pdf的一级页面，可描述多个pdf文件，当点击后就会进入相应文件的pdf阅读器中在该pdf.ejs中添加以下代码 &lt;%- partial('_partial/bg-cover') %&gt; &lt;style&gt; li { list-style: none; } .about { color: rgba(56, 51, 51, 0.6) !important; font-size: 3vw; text-align: center; font-family: 'Font Awesome 5 Free'; font-weight: 700; line-height: 3vw; } .ul { display: flex; flex-direction: column; align-items: center; max-width: 1200px; /* 对齐 */ margin: 0 auto !important; } .list { position: relative; margin-bottom: 10px; color: rgba(0, 150, 250, 0.6) !important; background-color: rgba(255, 255, 255,0.7); text-align: center; box-shadow: 2px 2px 2px rgba(255, 255, 255,0.7); } .list:hover { transform: scale(1.02,1.02); transition: all 0.5s; } .list::before { position: absolute; left: 1rem; top: 1rem; content: '📖'; transform: scale(2); } .list a .title { margin: 0; height: 4rem; font-size: 3rem !important; border-bottom: 2px solid #fff; color: rgba(0, 150, 250, 0.6) !important; line-height: 4rem; } .list a .explain { margin: 0; text-align: left; white-space:normal; line-height: 3vw; color: rgba(0, 150, 250, 0.6) !important; font-size: 1.8vw !important; } /* 手机端字体 */ @media only screen and (max-width: 601px) { .list a .title { font-size: 2.2rem !important; } .list::before { content: '📖'; transform: scale(1.5); } .about { font-size: 4vw; line-height: 4.5vw; } } &lt;/style&gt; &lt;main class=\"centent\"&gt; &lt;h2 class=\"about\"&gt;这儿是一些基于pdfjs进行阅读的书籍或者笔记！&lt;br&gt;&lt;em&gt;注意：阅读请关闭IDM&lt;/em&gt;&lt;/h2&gt; &lt;ul class=\"ul\"&gt; &lt;li class=\"list\"&gt; &lt;a href=\"/pdfjs/web/viewer.html?file=../data/css揭秘.pdf\" target=\"_Blank\"&gt; &lt;h3 class=\"title\"&gt;《css揭秘》&lt;/h3&gt; &lt;p class=\"explain\"&gt;这本书是为新一代 CSS 所写的新一代 CSS 图书。也许从前的 CSS 只会让你联想到浏览器里的各种 小把戏，但如今 CSS 已经成为一门功能强大、具备完整生态、涉及 80 多项 W3C 规范的复杂语言。在我 所知的技术专家中，没人比 Lea Verou 更能领会新一代 CSS 的精髓，没人能像她那样透彻地给出问题解决之道 &lt;/p&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/main&gt; 注意：以后pdf的介绍就放在li标签里面，参考第一个小li进行修改 （5）接着在博客根目录下的配置文件_config.yml中取消对pdfjs的渲染 （6）最后在主题配置文件D:\\HexoBlog\\themes\\hexo-theme-matery\\_config.yml中添加导航，我这里添加在Archives中作为二级导航。 Archives: icon: fas fa-archive children: - name: 时轴 url: /archives icon: fas fa-hourglass-half - name: 分类 url: /categories icon: fas fa-bookmark - name: 标签 url: /tags icon: fas fa-tag - name: PDF url: /pdf icon: fas fa-file-pdf","categories":[{"name":"项目之树","slug":"项目之树","permalink":"https://bingshanyishu.github.io/categories/%E9%A1%B9%E7%9B%AE%E4%B9%8B%E6%A0%91/"}],"tags":[{"name":"pdf","slug":"pdf","permalink":"https://bingshanyishu.github.io/tags/pdf/"},{"name":"博客","slug":"博客","permalink":"https://bingshanyishu.github.io/tags/%E5%8D%9A%E5%AE%A2/"}],"author":"Sankey"},{"title":"Tableau怎么制作专业图表图","slug":"Tableau怎么制作专业图表","date":"2022-02-04T16:13:48.000Z","updated":"2022-03-09T08:32:50.171Z","comments":true,"path":"posts/220205ba.html","link":"","permalink":"https://bingshanyishu.github.io/posts/220205ba.html","excerpt":"","text":"Tableau怎么制作专业图表一. 统计表1.1 不同种类的图表风格商业周刊的图表风格 经济学人的图表风格 华尔街日报的图表风格 其他媒体的图表风格 1.2 专业图表的特点 1.3 结论风格统一，减少无关修饰 1.4 统计表的基本架构 1.5 图表中的文字设定 注意：在图表中，文字往往处于从属地位，其格式不可喧宾夺主！ 文字的优缺点 缺点：线性阅读，理解速度较慢，量大时容易让人失去耐心 优点：信息密度大，不容易产生歧义 在图表中如何合理利用文字 利用其优点：用简短文字点明页面中心论点（标题或注解均可） 弥补其缺点 让文字变得有美感，让人亲近 通过排版等方式将文字直观、有条理地组织起来，使之更容易理解 控制文字总量，不同级别的大小有层次感 文字的样式 文字的字号 现场演示：保证最后一排观众也能看清正文最小字号 屏幕阅读：界面缩放至60％，应当保证在对角线长度距离外也能看淸楚 打印版本：应当至少使用10磅／五号字号 文字的效果 使用深色背景＋白色文字，或者浅色背景＋黑色文字，然后使用其他颜色作为强调色 尽量不要使用各种图片变色填充和文字特效 行距：1.2－1.5倍可以缓解密集文字的视觉压力 对齐：视情况使用居中对齐、两端对齐 有衬线字体（ Serif） 强调字母笔划的开始及结束，在笔画开始／结束的地方有额外的装饰，而且笔画的粗细会有所不同 突出的是整个word，而非单一字母 ·易读性较高，但排版时容易出现行／列等情况 中文字体很难按此分类严格归类 Garamond：圆润，古典优雅，非常适合显示大量文字 Times new roman：字母宽度差別小，应用范围广，不适合做标题 宋体：使用广泛的印刷体，笔画细，阅读性好，但不适合做标题 SimSun＝宋体， Mingliu＝细明体 无村线字体（ Sans serif）：随印刷业的排版需求发展而来 笔画的粗细差不多，小字体场合更容易阅读 突出的是每一个字母 无衬线字体更加端正大气，往往是商业图表的首选 Arial：平实无个性，但也不会犯错，标题和正文均可使用 黑体：最早的无衬线中文字体，很醒目，但打印效果稍差 雅黑：平实，小字可读性很好，用做标题时冲击力不足 幼圆：比雅黑更细弱一些，更适合于正文 1.6 突破默认设定文字设定 边框设定 二. 统计图2.1 统计图的信息维度 2.2 配色方案2.2.1 从调色板开始 2.2.2 颜色对比 2.2.3 取色法三色组取色 分裂互补三色组 类似取色 调整亮度取色 2.2.3 常见配色方案 纯色 素材选择受限，要求有很高的设计水平和绘图能力 单色 给人谨慎、专业的感觉，商务咨询报告和商务图表报告中常见 双色 较常见的配色方案，商业周刊的红蓝图表最经典 互补色时，冷色做主色，小范围使用暖色做强调色 更常见的是色轮上间隔120°的配色方式，这样对比仍然明显，但更和谐 多色 以四色相的居多 在韩系公司中尤为多见，看起来鲜艳活泼，但实际上重点不突出，很容易 阅读疲劳 2.3 如何定义颜色系 2.3 案例 2.4 自定义颜色 2.5 自定义边界 2.6 自定义形状 2.7 自定义图形框架 三. 仪表板3.1 版面设计四大原则 3.1.1 接近 3.1.2 对齐 3.1.3 重复 3.1.4 对比 3.2 仪表板的设计3.2.1 仪表板的作用 3.2.2 设计的要点 3.2.3 注意点 3.3 实践：冬小麦状况监测3.3.1 需求分析 3.3.2 数据展示工具分析 3.3.3 版面设计需求分析 3.3.4 仪表板需求细化","categories":[{"name":"技能之树","slug":"技能之树","permalink":"https://bingshanyishu.github.io/categories/%E6%8A%80%E8%83%BD%E4%B9%8B%E6%A0%91/"}],"tags":[{"name":"Tableau学习","slug":"Tableau学习","permalink":"https://bingshanyishu.github.io/tags/Tableau%E5%AD%A6%E4%B9%A0/"}],"author":"Sankey"},{"title":"Tableau绘制K线图、布林线、圆环图、雷达图","slug":"Tableau绘制K线图、布林线、圆环图、雷达图","date":"2022-02-02T16:38:48.000Z","updated":"2022-02-13T07:19:42.369Z","comments":true,"path":"posts/220203ab.html","link":"","permalink":"https://bingshanyishu.github.io/posts/220203ab.html","excerpt":"","text":"Tableau绘制K线图、布林线、圆环图、雷达图一. K线图 1.1 导入数据源 1.2 拖拽字段将【日期】托到列这一栏，并将其改为年/月/日类型 将【最低】拖到行这一栏。将【日期】拖到筛选，筛选字段设置为日期范围，日期大体设置为2020/6/11~~2010/9/7（参考范围，可自己设置） 1.3 创建计算字段创建计算字段，名字为高低差，公式为**[最高]-[最低]，创建之后将其拖到标记下的大小，并将将其改成甘特条形图** 1.4 编辑轴分别将【开盘】，【收盘】拖到详细信息，之后编辑轴，设定范围从2300到2800 1.5 做双图创建计算字段，将其命名为收开盘价差，公式为**[收盘]-[开盘]** 将【开盘】拖到行这一栏，将【收开盘价差】拖到标记下总和（开盘）的大小标记下 之后双轴、同步轴 1.6 修改颜色（涨跌）将总和（最低）的大小减小，之后创建计算字段， 名字为涨跌情况，公式为IIF([收盘]&gt;[开盘],’涨’,’跌’)**，将其拖拽到总和（开盘）**下的颜色标记中，并按要求设置颜色，，这里将跌设置为红色，涨设置为蓝色。 最后调整对应坐标轴，标题这些即可 二. 布林线 2.1 导入数据源 2.2 拖拽字段将【日期】拖拽到列这一栏，将其格式设置为天，将【收盘】拖拽到行这一栏，将其度量设置为平均值。将【日期】拖拽到筛选器中，设定筛选范围为2019/5/25~~2020/9/7.. 修改坐标轴范围为最小2000 2.3 创建参数鼠标右键 创建参数 参数名字为移动窗口，数据类型设置为整数，允许的值改为范围，，值范围改为最小值：1，最大值：30，步长：1，，之后显示参数控件 2.4 快速表计算将行上的平均值（收盘）进行移动平均的快速表计算，将其拖到数据-度量中并进行编辑， 修改名字为MA，将其公式中的**-2改为-移动窗口** 之后将MA替换原来的平均值（收盘），再将【收盘】将其拖到坐标轴中 。并重新设置坐标轴范围 2.5 创建SD计算字段与参数创建计算字段，名字为SD，公式为WINDOW_STDEV(AVG([收盘]),-移动窗口,0) 创建参数，名字为SD倍数，，数据类型为浮点，当前值为1，显示格式设置为一位小数，允许的值为范围，最小值为1，最大值为3.。最后创建完毕后显示参数控件。 2.6 创建上轨与下轨创建计算字段，名字为UP，公式为[MA]+[SD倍数]*[SD] 创建计算字段，名字为DOWN，公式为[MA]-[SD倍数]*[SD] 2.7 添加报警设定将度量值下的【收盘】度量改成平均值，拖到最右边，再同步轴，然后去掉这个轴 创建计算字段 名字为是否报警 公式为：IIF(AVG([收盘])&lt;UP AND AVG([收盘])&gt;[DOWN],FALSE,TRUE) 将其拖到标记中的平均值（收盘）中的颜色里，，调节颜色与不透明度，，将平均值（收盘）的不透明度设置为100%，将度量值的颜色设置为50%，再更改各线的颜色，增加美观与辨别度 三. 圆环图 有的版本没有记录数这个字段，这里提供了两种绘制方法，不过思路是一样的。 3.1 导入数据源示例超市 3.2 步骤（有记录数）3.2.1 创建饼图将【类别】拖到标记下的颜色中，将其改成饼图，将记录数拖拽到标记下的角度（要改成饼图后才有） 3.3.2 创建双图将【记录数】拖拽到行这一栏，并再复制一个，将两个【记录数】的度量改成最小值。移除第二个图的类别标记 3.2.3 修改大小将两个图，双轴，再同步轴 将视图改成整个视图，将标记下的最小（记录数）大小调大，标记下的最小（记录数）（2）大小稍微小点，并将其颜色改成白色 3.2.4 添加标签将【类别】、【记录数】拖到标记下的最小（记录数）的标签中，调节字体，字号大小 将【记录数】拖到标记下的最小（记录数）的标签中，调节字体，字号大小，标签再加总数 3.3 步骤（无记录数）3.3.1 创建饼图将【类别】拖到标记下的颜色中，将其改成饼图，将类别拖拽到标记下的角度（要改成饼图后才有），将其度量改成计数 3.3.2 创建双图将【类别】拖拽到行这一栏，并再复制一个，将两个【类别】的度量改成计数。对两者进行快速表计算——排序 移除第二个图的类别标记 3.3.3 其余操作类似四. 雷达图 4.1 导入数据源 转置后更改名称 4.2 创建计算字段（1）创建计算字段： 名字为路径 公式为： CASE [性质] WHEN '易抽取性' then 1 WHEN '粉尘量' then 2 WHEN '分层情况' then 3 WHEN '平整性' then 4 WHEN '厚度' then 5 WHEN '细腻度' then 6 WHEN '柔软度' then 7 WHEN '韧性' then 8 ELSE 9 END （2）创建计算字段， 名字为角度 公式为： IF [路径]=9 THEN 0 ELSE -([路径]-1)*2*PI()/8 END (3)创建计算字段 名字分别为X,Y X：公式：[大小]*COS([角度]) Y：公式：[大小]*SIN([角度]) 4.3 拖拽字段将X拖拽到列这一栏，Y拖拽到行这一栏，将F1拖拽到标记下的颜色中，将其类型有自动改成线，将【路径】拖拽到标记下的路径，，最后将取消聚合度量（菜单栏中的分析—&gt;聚合度量取消打勾） 这时基本雏形就出来了 4.4 添加标签为了使标签位于最外层，可直接在外层点手动加，但显得很LOW，这里才有创建计算字段来生成。 （1）创建计算字段 名字为性质标签 公式为：if [大小]=5 THEN [性质] END （2）创建计算字段 名字为数据标签 公式为： CASE [F1]WHEN '产品A' THEN [大小]WHEN '产品B' THEN [大小]WHEN '产品C' THEN [大小]END （3）拖拽标签 复制行上的Y，创建双图 将【性质标签】拖拽到标记下的总和(Y)(2)中的标签中 将【数据标签】拖拽到标记下的总和(Y)中的标签中，将数据标签类型改成离散，点击标签，勾选允许标签覆盖其他标记复选框 4.5 去除坐标轴将坐标轴去掉，也可添加筛选器来筛选产品，以方便观看。 4.6 调整多余数据，颜色将易抽取性中多余的数据隐藏掉（点击多余的数据，鼠标右键，将标记标签改成从不显示），将5个外围圆的颜色设置为灰色。","categories":[{"name":"技能之树","slug":"技能之树","permalink":"https://bingshanyishu.github.io/categories/%E6%8A%80%E8%83%BD%E4%B9%8B%E6%A0%91/"}],"tags":[{"name":"Tableau绘图","slug":"Tableau绘图","permalink":"https://bingshanyishu.github.io/tags/Tableau%E7%BB%98%E5%9B%BE/"}],"author":"Sankey"},{"title":"Tableau绘制热图、日历图、人口金字塔、标靶图、凹凸图、帕累托图","slug":"Tableau绘制热图、日历图、人口金字塔、标靶图、凹凸图、帕累托图","date":"2022-02-02T16:13:48.000Z","updated":"2022-03-08T01:18:46.828Z","comments":true,"path":"posts/220202ba.html","link":"","permalink":"https://bingshanyishu.github.io/posts/220202ba.html","excerpt":"","text":"Tableau绘图一热图、日历图、人口金字塔、标靶图、凹凸图、帕累托图一.热图 例子：示例超市 可以通过更改颜色来改变颜色的显示情况 二.日历/日历图 数据源：示例超市 按要求修改日期的格式 三.人口金字塔/旋风图 数据源：绘图数据 由于数据源中含有85岁以上的人，不能之间判断。这里可将Age转换为字符串，然后创建计算字段，命名为 年龄=if [Age]='85+' THEN 85 ELSE INT([Age]) END 将年龄创建数据桶 再分别创建以下字段 分别拖字段，以及倒序轴，设置颜色 四. 标靶图 4.1 数据源:示例超市+销售目标从Tableau【帮助】——【示例工作簿】——【示例超市】加载 4.2 步骤：（1）新建一个工作簿 （2）把【销售额】拖到列这一栏，把【订单日期】拖到行这一栏，同时钻取日期为年和月，之后再把【细分】拖到行这一栏（为了图表美观，可【订单日期】拖到筛选器，筛选任意一年的时间，本图表筛选日期为年——2016， （3）切换数据源为销售目标，把销售目标（注意：这里是度量值的销售目标，而非数据源名） （4）为图添加趋势线，点击分析，将参考线拖到单元格，并把值改为【总和(销售目标)】 (5)切换到示例-超市数据源，将度量值【销售额是否超过目标？】拖入到标记中的颜色,此时图表按是否达到目标有不同的颜色，若没有该度量值，可按下列公式计算 （6）为了在与图表互动时能够显示差值，可把【销售额】拖入到详细信息，再把公式编辑成如下第一张图所示。之后点击工具提示，把内容改为如第二张图所示 （7）点击分析，把分布区间拖入到弹出的窗口的单元格中，值可设为40,60,80,填充选取一个颜色，，选择向下填充复选框。 （8）结果——（可按自己要求更改图表配色） 五. 凹凸图 5.1 数据源系统自带示例超市 5.2 步骤（1）打开示例超市数据源 （2）将【订单日期】拖到列这一栏，把【销售额】拖到行这一栏 把【子类别】托到标记中的颜色。 （3）把【销售额】添加快速表计算，之后再编辑快速表计算，计算依据改为特定维度，只勾选【子类别】复选框，大致可以得到凹凸图雏形。 （4）按住CTRL键把销售额往后拖，即复制销售额这一栏，之后把第二个总和（销售额）改为圆，并点击标签，勾选显示标记标签和允许标签覆盖其他标记两个复选框,把对齐中的水平与垂直均设置为居中 （5)之后点击行这一栏的第二个【销售额】的小三角，然后弹出的对话框点击双轴，可得到基本图形了，但仍有不足，线与圆之间不对称，这是由于两个轴不同步引起的。此时可对右侧坐标轴鼠标右键，点击同步轴 （6）调整坐标刻度为倒序，此时排序为1的排到最上面，之后由于坐标轴在凹凸图中没有意义，可把坐标轴隐藏掉。分别对两个轴鼠标右键，去掉显示标题的勾 （7）结果 六. 帕累托图 数据源——示例超市 6.1 基础版（1）连接数据源，新建一个工作簿 （2）将【子类别】拖到列这一栏，将【销售额】拖到行这一栏，之后对【销售额】进行降序排序，即可得到基本的条形图 （3）将按住CTRL的同时把行上的【销售额】往后拖一个，即复制销售额，之后再对第二个销售额快速表计算——汇总 （4）将第二个【销售额】的标记改为线，，之后编辑表计算，在弹出来的对话框中计算依据勾选特定维度，最下面勾选添加辅助计算复选框，在新的辅助计算中从属计算类型选择合计百分比，计算依据改为特定维度 （5）合并双轴，并把第一个【销售额】的标记改为条形图 （6）可为图表添加常量线，便于决策，最后图表如果颜色不美观，还可更改图表颜色——点击标记下的”全部“中的颜色即可。 6.2 复杂版复杂版，即，将横坐标改为百分比递增，而不再是子类别 （1)在基础版的图形上进行更改，将【子类别】拖到标记下的全部的详细信息中，同时将列这一栏的度量改为计数（不同） （2）对列这一栏的子类别进行添加表计算，主要计算类型改为汇总，计算依据改为特定维度，排序顺序改为自定义排序，选择【销售额】，降序排序，并勾选添加辅助计算复选框，从属计算类型改为合计百分比，计算依据改为特定维度 （3）也可为图表添加参考线 (4)结果","categories":[{"name":"技能之树","slug":"技能之树","permalink":"https://bingshanyishu.github.io/categories/%E6%8A%80%E8%83%BD%E4%B9%8B%E6%A0%91/"}],"tags":[{"name":"Tableau绘图","slug":"Tableau绘图","permalink":"https://bingshanyishu.github.io/tags/Tableau%E7%BB%98%E5%9B%BE/"}],"author":"Sankey"},{"title":"Tableau学习Step6一如何制作炫彩地图","slug":"Tableau学习Step6一如何制作炫彩地图","date":"2022-02-02T14:08:59.000Z","updated":"2022-02-13T07:19:40.483Z","comments":true,"path":"posts/220202af.html","link":"","permalink":"https://bingshanyishu.github.io/posts/220202af.html","excerpt":"","text":"Tableau学习Step6——如何制作炫彩地图一.统计地图概述 1.1 统计地图的基本概念 统计地图的本质:数据的正确对应 将数据信息和地理位置严格对应起来,并加以图形呈现 如何将数据和地理位置对应起来? 将数据信息和其所在的地理点/地理区域直接关联起来 将相应信息用适当的图形元素在相应地理点/地理区域加以表示 常见的数据对应方式 ·统计数据和地图数据分表/库存储,用地名关键字将两个数据表进行连接 ·当使用可识别的标准地名关键字时, Tableau中这种连接操作是自动进行的 ·例:“中国”、“ China”均可识别,但“三哥”、“巴铁”就会让 Tableau-脸懵圈 1.2 地图地图的优劣合理运用地图展现数据关系和大小。 同样是展示总销售额和总订单数 二.标准统计地图的绘制 2.1 比例符号地图 2.2 填充地图 2.3 点分布图 2.4 热力图 2.5 蜘蛛图 2.6 动态路径图 2.7 复合统计地图将统计地图与其他统计图层相叠加 统计地图显示主要信息 其他统计图显示主要信息二 最常用的为饼图,其余图形种类非常少见 绘制要点 以双轴图的方式进行图层的叠加 ·进行图层的配色调整,使关键信息更加突出 2.8 地图的编辑和设定 搜索框、界面操作钮等的使用 显示比例尺 图形背景的深浅设置 冲蚀效果 图层和数据层 图层可供用户进行效果微调 ·数据层目前基本上是提供美国范围的数据 三.突破默认的地图框架 3.1 默认无法满足要求 3.2 如何处理非标准名称 3.3 自定义地理信息数据 3.4 基于已有地图添加新层级 1 3.5 基于已有地理单元添加新的地理分层 3.6 使用嵌套地图自动显示省市详情 3.7 如何计算两点间的距离数据格式整理 要求经纬度已在数据集中显式存在以内连接方式关联两两数据点(并去除无意义的同点关联) 将原数据源中的数据取并集，连接方式为**&lt;&gt;** 在数据源中计算出两两点间距离用大圆距离公式计算实际距离(使用地球的平均半径) 创建计算字段：距离，将距离变量设置为维度,公式如下： 3959* ACOS( SIN(RADIANS([lat]))*SIN(RADIANS([lat2]))+ COS(RADIANS([lat]))*COS(RADIANS([lat2]))* COS(RADIANS([long2])-RADIANS([long]))) 在地图中显示出两两点间距离并设定为线标记下的颜色，修改标签显示至合适方式 将距离添加到标签，同时设置标签的只显示距离 双轴，将国际名称添加到标签，合并双轴 为了更好交互，还可将国际名称（直辖市名称1）拖到工具提示，其设置如下 四.炫彩地图DIY 4.1 使用静态背景图片 截取符合需求的图源为静态图片 谷歌地图 Open Street开源地图 测量四个端点的GPS坐标,以取得相应的横纵轴尺度范围 设定相应图片为地图的背景图像,设定纵横轴相对应的变量,以及变量的取值范围 取消背景地图的显示 根据显示效果调整纵横轴尺度,以使数据和背景地图准确匹配 （1）截取背景图片 （2）取左上角与右下角经纬度坐标 （3）载入图片 4.2 使用自定义图片方法同4.1，不断调试 4.3 绘制多边形地图与如何采集 采集封闭多边形各个连续端点的经纬度坐标 同时记录各连续端点的绘制顺序 如果同一区域被分为多个独立多边形,则分别绘制,并取相同名称/D号即可 为便于管理,应当为每个区域提供不同的subd 将经度、纬度变量指定为正确的地理角色 要求绘制多边形图形,并将绘制顺序变量设定为路径 名称D变量用于区分不同地理区域, subid则辅助绘制不同的区域 推荐在线工具 https://drawingtool.powertoolsfortableau.com https://tableaudraw.com/ 4.使用外部地理空间文件 5.使用在线地图服务","categories":[{"name":"技能之树","slug":"技能之树","permalink":"https://bingshanyishu.github.io/categories/%E6%8A%80%E8%83%BD%E4%B9%8B%E6%A0%91/"}],"tags":[{"name":"Tableau学习","slug":"Tableau学习","permalink":"https://bingshanyishu.github.io/tags/Tableau%E5%AD%A6%E4%B9%A0/"}],"author":"Sankey"},{"title":"Tableau学习Step5一表计算、详细级别表达式、动作、外接python","slug":"Tableau学习Step5一表计算、详细级别表达式、动作、外接python","date":"2022-02-02T14:07:59.000Z","updated":"2022-02-13T07:19:41.009Z","comments":true,"path":"posts/220202ae.html","link":"","permalink":"https://bingshanyishu.github.io/posts/220202ae.html","excerpt":"","text":"Tableau学习Step5一表计算、详细级别表达式、动作、外接python一. 表计算1.1 什么是表计算 是特殊类型的计算字段 根据当前的可视化内容（基于当前内容构建的虚拟表）进行计算，如排名、汇总、差分、定基比/环比……. 表计算并不考虑当前可视化内容中被筛选掉的任何度量或维度 表计算的结果并不影响数据源中的数据表 1.2 分区与寻址 分区字段 用于定义计算组方式(确定执行表计算所针对的数据范围)的维度 分区字段将视图拆分成多个子视图(或子表),系统在每个分区内单独执行表计算 寻址字段 执行表计算所需要使用的其余维度 用于确定计算时的移动方向 横穿(从左到右) 向下(从上到下) 横穿,然后向下 向下,然后横穿 1.2.1 横穿 VS 向下 1.2.2 横穿,然后向下 VS 向下,然后横穿 1.2.3 加入分区维度 1.2.4 单元格内计算与特殊级别 1.3 表计算常见类型 1.4 如何创建表计算1.4.1 快速表计算 1.4.2 自定义表计算 1.4.3 计算新变量方式添加表计算(1) (2) 二. 详细级别表达式2.1 表达式级别 2.2 什么是详细级别表达式 2.3 FIXED 2.4 INCLUDE 2.5 EXCLUDE 2.6 全表范围LOD表达式的类型:全表范围 2.7 注意事项 三. 动作3.1 集动作 集动作使得用户在与可视化项或仪表板交互时可以直接更改集值 为集分配值、将值添加到集、从集中移除值 集动作的一般步骤 创建一个或多个集 创建一个集动作,该动作使用某一个集 可选:创建使用集的计算字段 构建一个可视化项,该可视化项使用集动作所引用的集 测试并修改集动作 3.1.1 选择性数据下钻展示 步骤： 3.1.2 动态切换标色 3.2 参数动作 四. 外接Python4.1 直接外接Python 按 tableau调用的数据格式编写 python代码 import numpy as np #传入时使用单个值或者lst a=[1,23,4] b=[5.6,7,8] #传出时为lst np. add(np array(a), np array (b)). tolisto 如何在tableau中调用tably SCRIPT BOOL/INT/REAL/STRO 需要调用的 python代码\",依次给出使用的参数列表 )# python代码中,参数依次用_arg1,arg2.进行标识 SCRIPT REAL( import numpy as np return np. add(np array( arg 1), np array( arg2 ). tolisto) avg(现状指数]),avg(预期指数] ) 注意：在 tableau中调用 tabby针对的是表计算级别! 因此计算中完全适用寻址和分区概念 传送入 python的数据是以每个单元格为单位先进行汇总 Tableau会对每个分区调用一次分析扩展程序,因此传入数据时会按分区形成数据序列 由于是按照分区进行调用,因此需要注意计算量 4.2 python预定义环境加载 from tabpy tabpy tools client import Client client=Client(http://localhost:9004/) 定义函数 import numpy as np def ado(x,y):#由于要在 tableau中使用函数结果,函数必须要有 return值 return np. add(np array(x), nparray(y). tolisto 部署函数 client deploy (addo, add, 'Adds two numbers x and y) 在 python环境中测试函数 res client query (addo, a, b） 在 tableau中调用预定义函数 SCRIPT REAL( return tabpy query (addo, arg1, arg2)Response] avg(现状指数]),ag([预期指数] 再次强调:在 tableau中调用 tabby针对的是表计算级别 当沿着表横穿时,会将该行单元格汇总结果形成list进行传送,那么考虑一下它是如何实现计算的? SCRIPT REAL( import numpy as np return np corrcoef( arg1, arg2)[0, 1 avg(现状指数]),avg(顶预期指数])","categories":[{"name":"技能之树","slug":"技能之树","permalink":"https://bingshanyishu.github.io/categories/%E6%8A%80%E8%83%BD%E4%B9%8B%E6%A0%91/"}],"tags":[{"name":"Tableau学习","slug":"Tableau学习","permalink":"https://bingshanyishu.github.io/tags/Tableau%E5%AD%A6%E4%B9%A0/"}],"author":"Sankey"},{"title":"Tableau学习Step4一数据解释、异常值监测、参数使用、分析结果如何对外发布","slug":"Tableau学习Step4一数据解释、异常值监测、参数使用、分析结果如何对外发布","date":"2022-02-02T14:06:59.000Z","updated":"2022-02-05T07:49:54.821Z","comments":true,"path":"posts/220202ad.html","link":"","permalink":"https://bingshanyishu.github.io/posts/220202ad.html","excerpt":"","text":"Tableau学习Step4一数据解释、异常值监测、参数使用、分析结果如何对外发布一. 前言 本教程通过一个案例从浅到深来学习Tableau知识 1.1 消费者信心指数定义消费者信心( Consumer Confidence or Consumer Sentiment)是指消费者根据国家或地区的经济发展形势,对就业、收入、物价、利率等问题综合判断后得出的一种看法和预期·居民在决策家庭的开销,特别是购买诸如住宅、汽车等耐用商品时,是经过深思熟虑才决定的。不仅是以目前的经济条件为基础,同时结合了对未来收入、就业、物价、利率变动等因素的判断和预期理论体系最早由美国密歇根大学调查研究中心的乔治-卡通纳( GeorgeKatona)在上世纪40年代后期提出六十多年的时间己经充分验证了上述理论在解释宏观经济现状时的有效性与合理性 1.2 中国消费者信心指数的需求 中国经济的重要性逐渐增高 国外对中国官方统计数据的质疑持续存在 地方数据和全国数据的较大差异 过高和过低数据时的修正(这个全世界其实都一样) 官方统计信息对于商业分析需求的匹配度较差 第三方数据:一大堆烂番茄! 1.3 指数研究方法调研的研究方法 1.4 中国消费者信心指数研究问卷 指数值的计算方法 1.5 分析需求 数据源可直接增添每月的新数据,且相应的图表均可分月浏览 对个体信心值中的异常值进行监测 展示不同群体的信心指数差异,并在图形中加汇参考线辅助分析 使用适当的工具展示开放题细节特征 二. 为数据源添加数据2.1 替换数据源 2.2 并集追加 2.3 提取后追加 添加只有一个工作表的数据源 三. 数据解释自动分析 四. 异常值监测4.1 参考线与参考区间对个体信心值中的异常值进行监测 单纯的直方图或者箱图并不能完全满足需求,需要考虑将其和点图、参考线等工具相结合 点图 常量、单值、区间和分布 填充方向和颜色渐变 百分位数 箱图 屏蔽正常范围的数据散点 4.2 箱图 五. 使用参数 六. 其余统计分析 七. 分析结果的对外发布 7.1 离线打包工作薄与打包工作簿，后者包括数据源 7.2 在线发布 八. 图表模板的应用直接替换数据源","categories":[{"name":"技能之树","slug":"技能之树","permalink":"https://bingshanyishu.github.io/categories/%E6%8A%80%E8%83%BD%E4%B9%8B%E6%A0%91/"}],"tags":[{"name":"Tableau学习","slug":"Tableau学习","permalink":"https://bingshanyishu.github.io/tags/Tableau%E5%AD%A6%E4%B9%A0/"}],"author":"Sankey"},{"title":"Tableau学习Step3一数据的连接与基本图形的制作","slug":"Tableau学习Step3一数据的连接与基本图形的制作","date":"2022-02-02T13:06:59.000Z","updated":"2022-02-13T07:19:41.415Z","comments":true,"path":"posts/220202ac.html","link":"","permalink":"https://bingshanyishu.github.io/posts/220202ac.html","excerpt":"","text":"Tableau学习Step3一数据的连接与基本图形的制作一. 前言 本教程通过一个案例从浅到深来学习Tableau知识 案例概述 Northwind公司的数据库架构 二. 商业理解 三. Tableau中的数据连接和数据源3.1 数据连接 3.2 数据源 3.3 数据模型数据表 数据库中存储数据的具体实现方式,有真实的物理存储空间 可以通过对表的操作来实现用户对数据的操作 数据视图 通过数据表间的逻辑关系,通过代码来将一些表中的数据进行连接整理后形成的一个逻辑表 视图在物理存储上并不存在,所有的数据都来自于对相关表的读取 对视图中数据的改变(如果允许的话)都直接是对源数据表内容的修改 优点:减少冗余数据,节省空间 缺点:功能受限,读写效率度,用不到的数据也必须进行逻辑拼接 在2020年2月，Tableau在数据底层对其数据模型进行了重大的更新，主要分为了物理层和逻辑层 如今Tableau在多表数据时的处理方式 3.4 基于SQL的多表关联可自定义SQL查询，编写了所需要的数据的SQL语言，大大简化了Tabeau直接对数据处理的方便性。 3.5 多数据源的融合不同的表可进行相互关联，实现不同表的数据的连接 3.6 远程数据的提取与保存3.6.1 接口差异Desktop版和 Public版的数据接口差异 3.6.1 文件类型Tableau常见的数据类型 四.Top监测表的制作4.1 数据表汇总方式分别将公司名称，地区，城市，地址，客户ID拖到行，将total拖入到列 4.2 数据提取汇总方式实时提取数据当数据源改变后，Tableau里连接的数据也会发生改变 若采用数据提取则当数据源改变后，Tableau里的连接的数据源也不会发生改变 4.3 筛选器Tableau中的筛选器 4.4 参数 五.近一步的分析需求需求 对Topn客户的订单情况做历史数据的深入考察 在名单中加入总金额未达到Topn,但总订单数较多的客户，如历史订单数&gt;=15 对上述信息形成动态监测界面,便于分析和观察 细化 5.1 刻度值的编辑操作 5.2 多个汇总值的考查 5.3 维度分层与维度钻取 5.4 集合的使用 5.5 绘制统计地图 5.6 构建仪表板","categories":[{"name":"技能之树","slug":"技能之树","permalink":"https://bingshanyishu.github.io/categories/%E6%8A%80%E8%83%BD%E4%B9%8B%E6%A0%91/"}],"tags":[{"name":"Tableau学习","slug":"Tableau学习","permalink":"https://bingshanyishu.github.io/tags/Tableau%E5%AD%A6%E4%B9%A0/"}],"author":"Sankey"},{"title":"Tableau学习Step2一数据文件的读取与统计图、表的概述","slug":"Tableau学习Step2一数据文件的读取与统计图、表的概述","date":"2022-02-02T13:06:48.000Z","updated":"2022-03-08T01:20:55.761Z","comments":true,"path":"posts/220202ab.html","link":"","permalink":"https://bingshanyishu.github.io/posts/220202ab.html","excerpt":"","text":"Tableau学习Step2一数据文件的读取与统计图、表的概述一. 前言 本教程通过一个案例从浅到深来学习Tableau知识 案例概述： 二. 文件读取2.1 数据结构 统计分析方法,都是以关系型数据库的二维表作为基本数据结构的 2.2 标准格式文件读取 2.3 非标准文件读取 2.4 数据透视表读取 2.5 并集文件与拼接文件 三. 编辑和整理数据3.1 基本的数据整理操作 名称与重命名 更改数据类型: 数值、日期、字符、逻辑 字符型变量 别名 数值拆分 数值型变量 数值分段(创建级) 创建 新变量 数据组 隐藏数据列 例：可使用创建计算字段来拆分列，如下图 SPLIT函数按逗号来拆分name行 四.维度与度量 五.统计表的基本类型5.1 表格的基本框架 5.2 表格绘制的基本步骤 5.3 叠加表 5.4 交叉表 5.5 嵌套表 5.6 多层表 5.7 复合表格 六.泰坦尼克号数据的表格化分析6.1 性别 6.2 舱位舱位操作同性别 6.3 交叉表分析 七.统计图的的基本类型7.1 统计图的分类框架 统计图的分类方法有许多种,但作为数据分析和呈现的工具,最好使用和统计学体系最为贴近的方法对其加以分类 首先按照其呈现变量的数量,将统计图大致分为单变量图、双变量图、多变量图等 随后再根据相应变量的测量尺度进行更细的区分 Tableau中提供了一些新式的图形,他们并不完全符合标准的统计绘 图要求,对这些图形的使用应当谨慎,注意不要因此冲淡分析主题 7.2 单个—分类变量 7.3 单个—数据变量 7.3.1 直方图 7.3.2 箱图 7.4 数据因变量 7.4.1 条图 7.4.2 点图 7.4.3 线图 7.5 分类因变量 7.6 组合图 注：以上内容为报名的Tableau课程笔记，仅作为个人复习自用。如有侵权，请联系删除","categories":[{"name":"技能之树","slug":"技能之树","permalink":"https://bingshanyishu.github.io/categories/%E6%8A%80%E8%83%BD%E4%B9%8B%E6%A0%91/"}],"tags":[{"name":"Tableau学习","slug":"Tableau学习","permalink":"https://bingshanyishu.github.io/tags/Tableau%E5%AD%A6%E4%B9%A0/"}],"author":"Sankey"},{"title":"Tableau学习step1一Tableau概述","slug":"Tableau学习step1一Tableau概述","date":"2022-02-02T13:06:48.000Z","updated":"2022-03-09T08:30:49.431Z","comments":true,"path":"posts/220202aa.html","link":"","permalink":"https://bingshanyishu.github.io/posts/220202aa.html","excerpt":"","text":"Tableau学习step1一Tableau概述一.Tableau优缺点优点 ·简单易用,只要是会用 EXCEL,几分钟就可掌握 Tableau的基本用法 急速高效 ·结果美观 ·轻松整合原始数据 ·高度交互 缺点 ·对统计数据文件的读取仍需改进 ·缺乏对数据深入分析和建模的能力 不免费 二.Tableau的产品线划分 2.1 Tableau Prep Builder（1）Tableau Prep Builder​ 用数据流的形式整理和清理数据 （2）Tableau Prep Conductor​ 在服务器环境中将数据自动化 2.2 Tableau Reader(免费) PC端结果浏览，免费使用 类似于Acrobat Reader 提供对已打包文件的浏览，动态交互能力，但不能作进一步的编辑操作 2.3 Tableau Public(免费) PC端编辑，web端存储，免费使用 提供基本的数据连接，和完整的展示，分析功能 不能读取远程数据库，不能将结果保存为本地文件（只能在web上公开发布） 2.4 Tableau Desktop提供完整的数据连接，展示，分析功能，并可将结果保存为本地文件，或直接发布至Server端 2.5 Tableau Server 服务器版本 可在本地或者云服务器上部署 可通过Desktop连接并上传已完成的可视化结果 通过浏览器界面直接使用，并实现在Desktop中几乎所有功能 2.6 Tableau Online Server的云托管版本 是SaaS形式的Tableau Server,带有由Tableau完全托管的维护，升级和安全性服务 2.7 Tableau Mobile 移动端APP，免费使用 为移动客服端提供完整的数据连接，展示，分析功能 必须结合Server才能使用（实际上是直接连接至Server) 三.Tableau的安装与激活Tableau官网下载：商业智能和分析软件 (tableau.com) 安装失败方法：Tableau 在Windows环境下安装失败的处理 – 喜乐君 (yupengwu.com) 安装之后重启 打开后 学生可免费申请一年使用 注：以上内容为报名的Tableau课程笔记，仅作为个人复习自用。如有侵权，请联系删除","categories":[{"name":"技能之树","slug":"技能之树","permalink":"https://bingshanyishu.github.io/categories/%E6%8A%80%E8%83%BD%E4%B9%8B%E6%A0%91/"}],"tags":[{"name":"Tableau学习","slug":"Tableau学习","permalink":"https://bingshanyishu.github.io/tags/Tableau%E5%AD%A6%E4%B9%A0/"}],"author":"Sankey"},{"title":"Tableau绘制漏斗图、甘特图、瀑布图、镶边面积图、阴影坡度图","slug":"Tableau绘制漏斗图、甘特图、瀑布图、镶边面积图、阴影坡度图","date":"2022-02-02T13:06:48.000Z","updated":"2022-03-09T08:30:50.027Z","comments":true,"path":"posts/220203aa.html","link":"","permalink":"https://bingshanyishu.github.io/posts/220203aa.html","excerpt":"","text":"Tableau绘制漏斗图、甘特图、瀑布图、镶边面积图、阴影坡度图一. 漏斗图 数据源 1.1 分色直条漏斗图（1）导入数据 （2）将【数量】拖到行这一栏，将【阶段】拖到标记下的颜色选项卡吗，之后对数量进行降序排列。 （3)把【数量】拖到标记下的大小选项卡，视图设置为整个视图 （4）把【阶段】，【数量】拖到标签选项卡，并对数量进行快速表计算——合计百分比。 （5）下面的图形由于太少而导致无法显示标签，对此可手动的选择，添加注释。（当然，为了美观，也可以选择不加） 1.2 同色斜边框漏斗图（1）导入数据 （2）将【数量】拖到行这一栏，将【阶段】拖到标记下的颜色选项卡吗，之后对数量进行降序排列。并将“标记”下的自动改为区域 （3）重复列一栏的【数量】，并将左边图的坐标轴倒序 （4）将图表颜色不透明度改成100%，鼠标右键设置格式，将边界的列分隔符改成无 （5）去掉坐标轴，并为图表添加标签，左侧添加【阶段】，右侧添加【数量】的百分比。并调整相应得大小，位置。 1.3 分条彩色漏斗图（1）导入数据 （2）将【数量】拖到行这一栏，将【阶段】拖到标记下的颜色选项卡吗，之后对数量进行降序排列。把【阶段】拖到标记下得颜色。 （3）复制【数量】这一栏，将【数量2】标记下的自动改为线，【数量1】标记下的自动改为条形图，并合并双轴，再同步轴 （4）同理，再做一个相同的图形 （5)将第一个图形的轴倒序，并对图形鼠标右键——设置格式，将边界下的列分隔符改成无（以去掉合并图形中间的线），之后再去掉图形的坐标轴。 （6）将【阶段】拖到【数量2】的标记下的标签中，【数量】拖到【数量4】的标记下的标签中。并快速表计算——合计百分比。调整相应的大小，位置。 （7）如果不想要边缘的线，也可以删除两个线图所对应栏的【数量】，然后添加标签，并将此时标签左侧图设置为偏右/中，右侧图设置为偏左/中，添加相应位置，大小。(注:如果不设置，会导致标签使图形压缩) 二. 甘特图 (1).导入数据源 (2).拖拽字段 1.将【实际开始日期】拖到列这一栏，并将其设置为度量的日。 2.将【阶段】，【项目名称】拖到行这一栏。将【实际用天】拖到大小这一栏（如何没有这个度量值），可通过创建计算字段来计算。 (3).添加参考线/区间 1.分别将【实际开始日期】，【实际完成日期】，【计划开始日期】，【计划完成日期】拖到标记下的详细信息，并将其全部设置为度量的日。 2.添加参考线，设置如下 3.也可添加参考区间。 (4).图表变色 接下来可以按照具体要求制作 1.如果想要图表显示出负责人，可之间将【负责人】拖到颜色 2.如果想要图表表示出完成情况而显示相应的颜色 可创建计算字段，并将其拖到颜色。 三. 瀑布图 (1)导入数据源 示例超市 (2)字段拖拽 将【利润】拖到行这一栏上，【子类别】拖到列这一栏上，按利润从小到大排列，并将标记下的自动改成甘特条形图。 (3)汇总指标 将【利润】快速表计算——汇总 (4)创建计算字段 为了得到直条的长度，这里计算负值的【利润】值，并将其拖到大小 (5)添加标签/色彩 (6)添加行总计 四. 镶边面积图 (1)导入数据源 示例超市 (2)拖拽字段 将【订单日期】拖拽到列这一栏。，【销售额】拖拽到列这一栏。【类别】拖拽到标记下的颜色。 (3)创建计算字段 销售额_办公用品 销售额_家具 销售额_技术 (4)合并字段 将【销售额_办公用品]拖到行这一栏，【销售额】的后面 将标记下的 总和【销售额_办公用品】中的类别去掉 将【销售额_家具】拖到销售额_办公用品图的前面 将【销售额_技术】拖到标记下的度量值中 (5)调节顺序和标记 对应顺序就是面积图的顺序 (6)更改公式 将标记下的总和（销售额_技术）的公式更改为 SUM([销售额_技术])+SUM([销售额_家具]) 将标记下的总和（销售额_办公用品）的公式更改为 SUM([销售额_办公用品])+SUM([销售额_技术])+SUM([销售额_家具]) 之后双轴，再同步轴。 最后按自己需求更改标签颜色这些 五. 阴影坡度图 (1)导入数据源 示例超市 (2)拖拽字段 将【订单日期】拖拽到列这一栏。，【销售额】拖拽到列这一栏。【类别】拖拽到标记下的颜色。 (3)创建计算字段 销售额_办公用品 销售额_家具 (4)合并字段 将【销售额_办公用品]拖到行这一栏，【销售额】的后面 将标记下的 总和【销售额_办公用品】中的类别去掉 将【销售额_家具】拖到销售额_办公用品图的前面 之后将标记下的度量值改成区域，调整总和（销售额_办公用品）与总和（销售额_家具的位置。 (5)更改公式 将标记下的总和（销售额_家具）的公式更改为 SUM([销售额_家具])-SUM([销售额_办公用品]) 之后双轴，再同步轴。 (6)更改颜色 将销售额_办公用品更改为白色 最后再自由调整即可","categories":[{"name":"技能之树","slug":"技能之树","permalink":"https://bingshanyishu.github.io/categories/%E6%8A%80%E8%83%BD%E4%B9%8B%E6%A0%91/"}],"tags":[{"name":"Tableau绘图","slug":"Tableau绘图","permalink":"https://bingshanyishu.github.io/tags/Tableau%E7%BB%98%E5%9B%BE/"}],"author":"Sankey"},{"title":"个人知识树博客搭建一环境的安装与配置","slug":"个人知识树博客搭建一环境的安装与配置","date":"2022-01-31T13:06:48.000Z","updated":"2022-03-09T08:08:58.054Z","comments":true,"path":"posts/f3fb008f.html","link":"","permalink":"https://bingshanyishu.github.io/posts/f3fb008f.html","excerpt":"","text":"博客搭建前言：博客框架介绍参考搭建博客、自己的小窝？快来看看这些开源静态网站生成器_灵魂画师牧码-CSDN博客 1. Hexo GitHub 仓库：https://github.com/hexojs/hexo Stars 数量：29.6k 官方网站：https://hexo.io Hexo 使用 Node.js 开发，很流行。它有数以百计的主题和插件，支持 GFM（GitHub Flavored Markdown），只需要一条命令也能将 Hexo 网站部署到 GitHub Pages、Heroku 等平台上。目前 Vue.js 的官方文档就由它驱动着。不过 Hexo 的速度对比其他框架而言，并不算非常快。 hexo原理hexo是怎么工作的 | 把生命浪费在美好的代码上 (coderunthings.com) hexo原理浅析 - SegmentFault 思否 2. Hugo GitHub 仓库：https://github.com/gohugoio/hugo Stars 数量：41.9k 官方网站：https://gohugo.io/ Hugo 使用 Go 语言开发，号称”世界上最快的网页生成器“。Stars 数量远高于 Hexo。目前有三百多个主题。 3. VuePress GitHub 仓库：https://github.com/vuejs/vuepress Stars 数量：15.6k 官方网站：https://vuepress.vuejs.org/zh/ VuePress 在一众生成器之中算是一个”后起之秀“，起初由尤雨溪牵头开发。等发展到一定程度之后，将会取代 Hexo 成为 Vue.js 官方文档的生成器。它基于 Vue，可以在 Markdown 中使用 Vue 组件，又可以使用 Vue 来开发自定义主题。 4. MkDocs GitHub 仓库：https://github.com/mkdocs/mkdocs Stars 数量：9.1k 官方网站：http://www.mkdocs.org/ MkDocs 使用 Python 开发，更偏向于文档生成。用户不是特别多，只有十几个主题。 5. Gatsby GitHub 仓库：https://github.com/gatsbyjs/gatsby Stars 数量：42.5k 官方网站：https://www.gatsbyjs.org/ Gatsby 作为 GitHub 上面 #static-site-generator 话题最多 Star 数量的项目，基于 React。它超越了静态网站，更强大。可以从任何地方加载数据。 6. Docsify GitHub 仓库：https://github.com/docsifyjs/docsify Stars 数量：12.6k 官方网站：https://docsify.js.org/ Docsify 同样基于 Vue，偏向于文档，动态生成网页，最大的特点是它只有一个 index.html，在你打开网页的时候才开始生成。Docsify 还兼容 IE 11。缺点是对 SEO 并不太友好。 7. Jekyll GitHub 仓库：https://github.com/jekyll/jekyll Stars 数量：39.8k 官方网站：https://jekyllrb.com/ Jekyll 使用 Ruby 开发，它足够简单，能够让你专注于内容。它有将近四百种主题和两百多个插件，光这两项就足以证明它的优秀。 一. 安装Git工具下载地址： Git官网下载：https://git-scm.com/ 国内镜像下载：https://npm.taobao.org/mirrors/git-for-windows/v2.22.0.windows.1/Git-2.22.0-64-bit.exe 国内其他版本下载：https://npm.taobao.org/mirrors/git-for-windows/ 建议使用国内镜像下载，速度最快！ ps:我自己用了官网下载，下载了20多分钟 下载后请安装请参考这篇文章 Windows系统Git安装教程（详解Git安装过程） 装完成后在命令提示符中输入git –version验证是否安装成功 git --version 二. 安装Node.js Node.js 是一个开源和跨平台的 JavaScript 运行时环境。 它几乎是任何类型项目的流行工具！ Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。 Download | Node.js (nodejs.org)这个网站直接进去下载就行 具体安装教程可参考这篇文章 nodejs下载安装及配置环境 可通过命令行进行查看是否安装成功，打开命令提示符，输入node -v和npm -v，如果出现版本号，那么就安装成功了。如下图 因为node.js用的是国外的网站，为了提高下载速度，可使用国内淘宝镜像的方法。 命令 npm config set registry https://registry.npm.taobao.org 验证命令 npm config get registry 如果返回https://registry.npm.taobao.org，说明镜像配置成功。 三. 安装HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页 官网文档 | Hexo 在你的某个磁盘中创建一个空的文件 比如我的这里是D/HexoBlog，以后所有的git命令都要在这个文件夹里面运行 在该文件夹下点击 Git Bash Here，输入以下 npm 命令即可安装 $ npm install hexo-cli -g 输入hexo -v即可检验是否安装成功，我这里就不演示了。 具体参考： φ(゜▽゜*)♪咦，又好了！ (yshawlon.cn) (5条消息) 使用 Hexo 搭建静态个人博客与绑定个人域名_bwqiang的博客-CSDN博客 安装好后初始化， $ hexo init 分别执行 $npm install 执行npm install之后 以上如果报错就多运行几次，可能是网络不好，比如我下面的错误 执行hexo g：生成页面文件，也就是一些html,css，js文件，这样打开就是一个渲染好的网站 浏览器，输入网站，localhost:4000,就可以看到初步的本地博客，以后优化博客都要先本地看，再上传到github 四. 创建Github仓库 没有GitHub账号的先注册一下 https://github.com/join，很简单。不会就去网上搜 创建repository。右上角 加号 New repository。 注意：repository名字必须是自己 GitHub 账户名，否则出现 404 错误。 我这里以及弄好了，没有截图，仓库名字就是你的github名字.github.io, 比如我的 bingshanyishu.github.io 这里借别人的图用一下，谢谢 注意：下面readme也要勾选， 最后就创建成功了。 后面上传博客还需要注册令牌： 点击settings 找到了再点击developer settings 点击personal access token 然后点击创建token， note可以随便命名，expiration建议勾选no expiration,意思就是没有时间限制。最后生成令牌，保存好令牌，后面用，最好单独保存，因为令牌只能看一次，也就是注册这次，以后都不能看令牌了。 五. 上传到github仓库5.1 _config.yml修改找到在D:\\HexoBlog下的_config.yml文件，然后打开，我这里使用vscode打开，也可以用记事本打开。 找到： # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: 修改后：（注意：后面冒号的值需要有一个空格） # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repository: 自己的仓库地址如下图，直接复制粘贴 //自己的仓库地址 branch: main 5.2 生成ssh右键单击鼠标，点击 Git Bash Here输入以下命令：（第一次使用需要），后面不需要了 git config --global user.name \"Name\" git config --global user.email \"Email\" name是你的github名字，email是你注册github的地址。 生成密钥： 再输入，email是你的github邮箱 ssh-keygen -t rsa -C \"Email\" 按下四次enter后，就可以得到ssh了 复制ssh 找到c盘，用户，个人账户文件下的.ssh文件 例如我的路径：C:\\Users\\27532\\.ssh，27532，和你们不一样 打开id_rsa.pub文件打开，后直接Ctrl+A,Ctrl+C。就复制好了ssh密钥。 5.3 绑定github打开github，点击头像，再点击settings,找到SSH and GPG keys点击 新建SSH，title可以随便取，Key粘贴刚才复制的**.ssh**文件内容 最后点击add ssh key即可 5.4 本地连接github你的博客文件夹下，右键单击鼠标，点击 Git Bash Here输入以下命令，如果如下图所示，出现你的用户名，那就成功了 ssh -T git@github.com 这样就将git与github仓库连接起来了 5.5 上传你的博客文件夹下，右键单击鼠标，点击 Git Bash Here输入以下命令 npm install hexo-deployer-git --save 这样以后可直接通过命令上传博客 最后点击 Git Bash Here输入以下命令 hexo g hexo d 输入hexo d 后第一次会弹出github对话框，然后点击token，输入刚才产生的令牌就可以将其本地的文件上传到github 最后输入网址http://bingshanyishu.github.io/ 即可查看网址了 注意：每次修改本地文件后。 每次使用命令时，都要在D:\\HexoBlog目录下。 hexo cl hexo g hexo s //本地查看 hexo d //上传到github 六. 参考Github + Hexo 搭建个人博客超详细教程_feezxe的博客-CSDN博客 使用 Hexo 搭建静态个人博客与绑定个人域名_bwqiang的博客-CSDN博客 基于Hexo的matery主题搭建博客并优化_悟尘修行记-CSDN博客_hexo matery","categories":[{"name":"项目之树","slug":"项目之树","permalink":"https://bingshanyishu.github.io/categories/%E9%A1%B9%E7%9B%AE%E4%B9%8B%E6%A0%91/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"https://bingshanyishu.github.io/tags/Blog/"}],"author":"Sankey"},{"title":"hexo部署到github时，提示typeError","slug":"hexo部署到github时，提示typeError [ERR_INVALID_ARG_TYPE] The “mode“ argument must be integer. Receive","date":"2022-01-30T16:00:00.000Z","updated":"2022-03-09T08:28:41.570Z","comments":true,"path":"posts/4b2340a4.html","link":"","permalink":"https://bingshanyishu.github.io/posts/4b2340a4.html","excerpt":"","text":"hexo部署到github时，提示typeError [ERR_INVALID_ARG_TYPE]: The “mode“ argument must be integer. Receive…一. 错误情况在部署部署博客时，遇到这个错误， $ hexo d INFO Deploying: git INFO Clearing .deploy_git folder... INFO Copying files from public folder... FATAL Something's wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html TypeError [ERR_INVALID_ARG_TYPE]: The \"mode\" argument must be integer. Received an instance of Object at copyFile (fs.js:2040:10) at tryCatcher (D:\\HexoBlog\\node_modules\\bluebird\\js\\release\\util.js:16:23) at ret (eval at makeNodePromisifiedEval (C:\\Users\\27532\\AppData\\Roaming\\npm\\node_modules\\hexo-cli\\node_modules\\bluebird\\js\\release\\promisify.js:184:12), &lt;anonymous&gt;:13:39) at D:\\HexoBlog\\node_modules\\hexo-fs\\lib\\fs.js:144:39 at tryCatcher (D:\\HexoBlog\\node_modules\\bluebird\\js\\release\\util.js:16:23) at Promise._settlePromiseFromHandler (D:\\HexoBlog\\node_modules\\bluebird\\js\\release\\promise.js:517:31) at Promise._settlePromise (D:\\HexoBlog\\node_modules\\bluebird\\js\\release\\promise.js:574:18) at Promise._settlePromise0 (D:\\HexoBlog\\node_modules\\bluebird\\js\\release\\promise.js:619:10) at Promise._settlePromises (D:\\HexoBlog\\node_modules\\bluebird\\js\\release\\promise.js:699:18) at Promise._fulfill (D:\\HexoBlog\\node_modules\\bluebird\\js\\release\\promise.js:643:18) at Promise._resolveCallback (D:\\HexoBlog\\node_modules\\bluebird\\js\\release\\promise.js:437:57) at Promise._settlePromiseFromHandler (D:\\HexoBlog\\node_modules\\bluebird\\js\\release\\promise.js:529:17) at Promise._settlePromise (D:\\HexoBlog\\node_modules\\bluebird\\js\\release\\promise.js:574:18) at Promise._settlePromise0 (D:\\HexoBlog\\node_modules\\bluebird\\js\\release\\promise.js:619:10) at Promise._settlePromises (D:\\HexoBlog\\node_modules\\bluebird\\js\\release\\promise.js:699:18) at Promise._fulfill (D:\\HexoBlog\\node_modules\\bluebird\\js\\release\\promise.js:643:18) at Promise._resolveCallback (D:\\HexoBlog\\node_modules\\bluebird\\js\\release\\promise.js:437:57) at Promise._settlePromiseFromHandler (D:\\HexoBlog\\node_modules\\bluebird\\js\\release\\promise.js:529:17) at Promise._settlePromise (D:\\HexoBlog\\node_modules\\bluebird\\js\\release\\promise.js:574:18) at Promise._settlePromise0 (D:\\HexoBlog\\node_modules\\bluebird\\js\\release\\promise.js:619:10) at Promise._settlePromises (D:\\HexoBlog\\node_modules\\bluebird\\js\\release\\promise.js:699:18) at Promise._fulfill (D:\\HexoBlog\\node_modules\\bluebird\\js\\release\\promise.js:643:18) 二. 解决方法查阅相关文章得知，是node版本过高导致的 查看了我的版本号 $ hexo -v hexo: 3.9.0 hexo-cli: 4.3.0 os: win32 10.0.19042 node: 14.17.5 v8: 8.4.371.23-node.76 uv: 1.41.0 zlib: 1.2.11 brotli: 1.0.9 ares: 1.17.2 modules: 83 nghttp2: 1.42.0 napi: 8 llhttp: 2.1.3 openssl: 1.1.1k cldr: 39.0 icu: 69.1 tz: 2021a unicode: 13.0 hexo 版本才3.9.0, 而node 版本已经是14.17.5了 更换版本 Releases · coreybutler/nvm-windows (github.com)下载nvm 安装 (5条消息) Node版本的升级和降级之node版本管理工具nvm_Pioneer-CSDN博客_nvm升级node版本 windows如何把已安装的nodejs高版本降级为低版本(图文教程)_node.js_脚本之家 (jb51.net) 三. 附常用nvm命令查看安装过的node版本 nvm list 安装某个版本nvm install &lt;version&gt; 使用某个版本 nvm use&lt;version&gt; 载某个node版本 nvm uninstall &lt;version&gt; 如果出现乱码 更改了cmd的权限成功解决问题，以管理员运行cmd窗口，再输入nvm use 12.14.0解决问题 再运行 hexo d 成功解决","categories":[{"name":"项目之树","slug":"项目之树","permalink":"https://bingshanyishu.github.io/categories/%E9%A1%B9%E7%9B%AE%E4%B9%8B%E6%A0%91/"}],"tags":[{"name":"Blog问题","slug":"Blog问题","permalink":"https://bingshanyishu.github.io/tags/Blog%E9%97%AE%E9%A2%98/"}],"author":"Sankey"},{"title":"jQuery+CSS3实现的文字背景粒子特效-副本","slug":"jQuery+CSS3 - 副本","date":"2022-01-30T16:00:00.000Z","updated":"2022-03-11T12:00:47.742Z","comments":true,"path":"posts/4b35102222.html","link":"","permalink":"https://bingshanyishu.github.io/posts/4b35102222.html","excerpt":"","text":"前言一款jQuery+CSS3的文字背景粒子动画特效，一共6种粒子效果，每种文字背景的粒子效果都不同，有漂浮的有坠落的等等。 本文转载于LuckySEc用于自用，文字背景粒子特效 | LuckySec (luckyzmj.cn)。感谢大佬的分享。 0x001 特效演示 This is fires This is lines This is hearts This is bubbles This is confetti This is sunbeams .particletext { } .fire > .particle { position: absolute; background-color: rgba(255, 193, 7, 0.5); border-radius: 40px; border-top-right-radius: 0px; -webkit-animation: fires 0.8s linear infinite; animation: fires 0.8s linear infinite; -webkit-transform: rotate(-45deg); transform: rotate(-45deg); opacity: 0; } /*css keyframes 动画*/ @-webkit-keyframes fires { 0% { -webkit-transform: rotate(-70deg) translateY(0%); transform: rotate(-70deg) translateY(0%); } 25% { -webkit-transform: rotate(-20deg) translateY(-5%); transform: rotate(-20deg) translateY(-5%); opacity: 1; } 50% { -webkit-transform: rotate(-70deg) translateY(-10%); transform: rotate(-70deg) translateY(-10%); } 75% { -webkit-transform: rotate(-20deg) translateY(-20%); transform: rotate(-20deg) translateY(-20%); } 100% { -webkit-transform: rotate(-70deg) translateY(-40%); transform: rotate(-70deg) translateY(-40%); opacity: 1; } } @keyframes fires { 0% { -webkit-transform: rotate(-70deg) translateY(0%); transform: rotate(-70deg) translateY(0%); } 25% { -webkit-transform: rotate(-20deg) translateY(-5%); transform: rotate(-20deg) translateY(-5%); opacity: 1; } 50% { -webkit-transform: rotate(-70deg) translateY(-10%); transform: rotate(-70deg) translateY(-10%); } 75% { -webkit-transform: rotate(-20deg) translateY(-20%); transform: rotate(-20deg) translateY(-20%); } 100% { -webkit-transform: rotate(-70deg) translateY(-40%); transform: rotate(-70deg) translateY(-40%); opacity: 1; } } function fire() { $.each($(\".particletext.fire\"), function(){ var firecount = ($(this).width()/50)*20; for(var i = 0; i .particle { position: absolute; background-color: rgba(244, 67, 54, 0.5); -webkit-animation: lines 3s linear infinite; animation: lines 3s linear infinite; } @-webkit-keyframes lines { 0%, 50%, 100% { -webkit-transform: translateY(0%); transform: translateY(0%); } 25% { -webkit-transform: translateY(100%); transform: translateY(100%); } 75% { -webkit-transform: translateY(-100%); transform: translateY(-100%); } } @keyframes lines { 0%, 50%, 100% { -webkit-transform: translateY(0%); transform: translateY(0%); } 25% { -webkit-transform: translateY(100%); transform: translateY(100%); } 75% { -webkit-transform: translateY(-100%); transform: translateY(-100%); } } function lines() { $.each($(\".particletext.lines\"), function(){ var linecount = ($(this).width()/50)*10; for(var i = 0; i .particle { opacity: 0; position: absolute; background-color: #cc2a5d; -webkit-animation: hearts 3s ease-in infinite; animation: hearts 3s ease-in infinite; } .hearts > .particle:before,.hearts > .particle:after { position: absolute; content: ''; border-radius: 100px; top: 0px; left: 0px; width: 100%; height: 100%; background-color: #cc2a5d; } .hearts > .particle:before { -webkit-transform: translateX(-50%); transform: translateX(-50%); } .hearts > .particle:after { -webkit-transform: translateY(-50%); transform: translateY(-50%); } @-webkit-keyframes hearts { 0% { opacity: 0; -webkit-transform: translate(0, 0%) rotate(45deg); transform: translate(0, 0%) rotate(45deg); } 20% { opacity: 0.8; -webkit-transform: translate(0, -20%) rotate(45deg); transform: translate(0, -20%) rotate(45deg); } 100% { opacity: 0; -webkit-transform: translate(0, -1000%) rotate(45deg); transform: translate(0, -1000%) rotate(45deg); } } @keyframes hearts { 0% { opacity: 0; -webkit-transform: translate(0, 0%) rotate(45deg); transform: translate(0, 0%) rotate(45deg); } 20% { opacity: 0.8; -webkit-transform: translate(0, -20%) rotate(45deg); transform: translate(0, -20%) rotate(45deg); } 100% { opacity: 0; -webkit-transform: translate(0, -1000%) rotate(45deg); transform: translate(0, -1000%) rotate(45deg); } } function hearts() { $.each($(\".particletext.hearts\"), function(){ var heartcount = ($(this).width()/50)*5; for(var i = 0; i .particle { opacity: 0; position: absolute; background-color: rgba(33, 150, 243, 0.5); -webkit-animation: bubbles 3s ease-in infinite; animation: bubbles 3s ease-in infinite; border-radius: 100%; } @-webkit-keyframes bubbles { 0% { opacity: 0; } 20% { opacity: 1; -webkit-transform: translate(0, -20%); transform: translate(0, -20%); } 100% { opacity: 0; -webkit-transform: translate(0, -1000%); transform: translate(0, -1000%); } } @keyframes bubbles { 0% { opacity: 0; } 20% { opacity: 1; -webkit-transform: translate(0, -20%); transform: translate(0, -20%); } 100% { opacity: 0; -webkit-transform: translate(0, -1000%); transform: translate(0, -1000%); } } function bubbles() { $.each($(\".particletext.bubbles\"), function(){ var bubblecount = ($(this).width()/50)*10; for(var i = 0; i .particle { opacity: 0; position: absolute; -webkit-animation: confetti 3s ease-in infinite; animation: confetti 3s ease-in infinite; } .confetti > .particle.c1 { background-color: rgba(76, 175, 80, 0.5); } .confetti > .particle.c2 { background-color: rgba(156, 39, 176, 0.5); } @-webkit-keyframes confetti { 0% { opacity: 0; -webkit-transform: translateY(0%) rotate(0deg); transform: translateY(0%) rotate(0deg); } 10% { opacity: 1; } 35% { -webkit-transform: translateY(-800%) rotate(270deg); transform: translateY(-800%) rotate(270deg); } 80% { opacity: 1; } 100% { opacity: 0; -webkit-transform: translateY(2000%) rotate(1440deg); transform: translateY(2000%) rotate(1440deg); } } @keyframes confetti { 0% { opacity: 0; -webkit-transform: translateY(0%) rotate(0deg); transform: translateY(0%) rotate(0deg); } 10% { opacity: 1; } 35% { -webkit-transform: translateY(-800%) rotate(270deg); transform: translateY(-800%) rotate(270deg); } 80% { opacity: 1; } 100% { opacity: 0; -webkit-transform: translateY(2000%) rotate(1440deg); transform: translateY(2000%) rotate(1440deg); } } function confetti() { $.each($(\".particletext.confetti\"), function(){ var confetticount = ($(this).width()/50)*10; for(var i = 0; i .particle { position: absolute; background-color: rgba(253, 216, 53, 0.5); -webkit-animation: sunbeams 3s linear infinite; animation: sunbeams 3s linear infinite; } @-webkit-keyframes sunbeams { 0% { -webkit-transform: translateY(40%) rotate(0deg); transform: translateY(40%) rotate(0deg); } 50% { -webkit-transform: translateY(-40%) rotate(180deg); transform: translateY(-40%) rotate(180deg); } 100% { -webkit-transform: translateY(40%) rotate(360deg); transform: translateY(40%) rotate(360deg); } 0%,14%,17%,43%,53%,71%,80%,94%,100% { opacity: 0; } 6%,15%,24%,28%,48%,55%,78%,82%,99% { opacity: 1; } } @keyframes sunbeams { 0% { -webkit-transform: translateY(40%) rotate(0deg); transform: translateY(40%) rotate(0deg); } 50% { -webkit-transform: translateY(-40%) rotate(180deg); transform: translateY(-40%) rotate(180deg); } 100% { -webkit-transform: translateY(40%) rotate(360deg); transform: translateY(40%) rotate(360deg); } 0%,14%,17%,43%,53%,71%,80%,94%,100% { opacity: 0; } 6%,15%,24%,28%,48%,55%,78%,82%,99% { opacity: 1; } } function sunbeams() { $.each($(\".particletext.sunbeams\"), function(){ var linecount = ($(this).width()/50)*10; for(var i = 0; i","categories":[{"name":"技能之树","slug":"技能之树","permalink":"https://bingshanyishu.github.io/categories/%E6%8A%80%E8%83%BD%E4%B9%8B%E6%A0%91/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"https://bingshanyishu.github.io/tags/CSS3/"}],"author":"Sankey"},{"title":"jQuery+CSS3实现的文字背景粒子特效","slug":"jQuery+CSS3","date":"2022-01-30T16:00:00.000Z","updated":"2022-02-13T07:19:44.763Z","comments":true,"path":"posts/4b3510a4.html","link":"","permalink":"https://bingshanyishu.github.io/posts/4b3510a4.html","excerpt":"","text":"前言一款jQuery+CSS3的文字背景粒子动画特效，一共6种粒子效果，每种文字背景的粒子效果都不同，有漂浮的有坠落的等等。 本文转载于LuckySEc用于自用，文字背景粒子特效 | LuckySec (luckyzmj.cn)。感谢大佬的分享。 0x001 特效演示 This is fires This is lines This is hearts This is bubbles This is confetti This is sunbeams .particletext { } .fire > .particle { position: absolute; background-color: rgba(255, 193, 7, 0.5); border-radius: 40px; border-top-right-radius: 0px; -webkit-animation: fires 0.8s linear infinite; animation: fires 0.8s linear infinite; -webkit-transform: rotate(-45deg); transform: rotate(-45deg); opacity: 0; } /*css keyframes 动画*/ @-webkit-keyframes fires { 0% { -webkit-transform: rotate(-70deg) translateY(0%); transform: rotate(-70deg) translateY(0%); } 25% { -webkit-transform: rotate(-20deg) translateY(-5%); transform: rotate(-20deg) translateY(-5%); opacity: 1; } 50% { -webkit-transform: rotate(-70deg) translateY(-10%); transform: rotate(-70deg) translateY(-10%); } 75% { -webkit-transform: rotate(-20deg) translateY(-20%); transform: rotate(-20deg) translateY(-20%); } 100% { -webkit-transform: rotate(-70deg) translateY(-40%); transform: rotate(-70deg) translateY(-40%); opacity: 1; } } @keyframes fires { 0% { -webkit-transform: rotate(-70deg) translateY(0%); transform: rotate(-70deg) translateY(0%); } 25% { -webkit-transform: rotate(-20deg) translateY(-5%); transform: rotate(-20deg) translateY(-5%); opacity: 1; } 50% { -webkit-transform: rotate(-70deg) translateY(-10%); transform: rotate(-70deg) translateY(-10%); } 75% { -webkit-transform: rotate(-20deg) translateY(-20%); transform: rotate(-20deg) translateY(-20%); } 100% { -webkit-transform: rotate(-70deg) translateY(-40%); transform: rotate(-70deg) translateY(-40%); opacity: 1; } } function fire() { $.each($(\".particletext.fire\"), function(){ var firecount = ($(this).width()/50)*20; for(var i = 0; i .particle { position: absolute; background-color: rgba(244, 67, 54, 0.5); -webkit-animation: lines 3s linear infinite; animation: lines 3s linear infinite; } @-webkit-keyframes lines { 0%, 50%, 100% { -webkit-transform: translateY(0%); transform: translateY(0%); } 25% { -webkit-transform: translateY(100%); transform: translateY(100%); } 75% { -webkit-transform: translateY(-100%); transform: translateY(-100%); } } @keyframes lines { 0%, 50%, 100% { -webkit-transform: translateY(0%); transform: translateY(0%); } 25% { -webkit-transform: translateY(100%); transform: translateY(100%); } 75% { -webkit-transform: translateY(-100%); transform: translateY(-100%); } } function lines() { $.each($(\".particletext.lines\"), function(){ var linecount = ($(this).width()/50)*10; for(var i = 0; i .particle { opacity: 0; position: absolute; background-color: #cc2a5d; -webkit-animation: hearts 3s ease-in infinite; animation: hearts 3s ease-in infinite; } .hearts > .particle:before,.hearts > .particle:after { position: absolute; content: ''; border-radius: 100px; top: 0px; left: 0px; width: 100%; height: 100%; background-color: #cc2a5d; } .hearts > .particle:before { -webkit-transform: translateX(-50%); transform: translateX(-50%); } .hearts > .particle:after { -webkit-transform: translateY(-50%); transform: translateY(-50%); } @-webkit-keyframes hearts { 0% { opacity: 0; -webkit-transform: translate(0, 0%) rotate(45deg); transform: translate(0, 0%) rotate(45deg); } 20% { opacity: 0.8; -webkit-transform: translate(0, -20%) rotate(45deg); transform: translate(0, -20%) rotate(45deg); } 100% { opacity: 0; -webkit-transform: translate(0, -1000%) rotate(45deg); transform: translate(0, -1000%) rotate(45deg); } } @keyframes hearts { 0% { opacity: 0; -webkit-transform: translate(0, 0%) rotate(45deg); transform: translate(0, 0%) rotate(45deg); } 20% { opacity: 0.8; -webkit-transform: translate(0, -20%) rotate(45deg); transform: translate(0, -20%) rotate(45deg); } 100% { opacity: 0; -webkit-transform: translate(0, -1000%) rotate(45deg); transform: translate(0, -1000%) rotate(45deg); } } function hearts() { $.each($(\".particletext.hearts\"), function(){ var heartcount = ($(this).width()/50)*5; for(var i = 0; i .particle { opacity: 0; position: absolute; background-color: rgba(33, 150, 243, 0.5); -webkit-animation: bubbles 3s ease-in infinite; animation: bubbles 3s ease-in infinite; border-radius: 100%; } @-webkit-keyframes bubbles { 0% { opacity: 0; } 20% { opacity: 1; -webkit-transform: translate(0, -20%); transform: translate(0, -20%); } 100% { opacity: 0; -webkit-transform: translate(0, -1000%); transform: translate(0, -1000%); } } @keyframes bubbles { 0% { opacity: 0; } 20% { opacity: 1; -webkit-transform: translate(0, -20%); transform: translate(0, -20%); } 100% { opacity: 0; -webkit-transform: translate(0, -1000%); transform: translate(0, -1000%); } } function bubbles() { $.each($(\".particletext.bubbles\"), function(){ var bubblecount = ($(this).width()/50)*10; for(var i = 0; i .particle { opacity: 0; position: absolute; -webkit-animation: confetti 3s ease-in infinite; animation: confetti 3s ease-in infinite; } .confetti > .particle.c1 { background-color: rgba(76, 175, 80, 0.5); } .confetti > .particle.c2 { background-color: rgba(156, 39, 176, 0.5); } @-webkit-keyframes confetti { 0% { opacity: 0; -webkit-transform: translateY(0%) rotate(0deg); transform: translateY(0%) rotate(0deg); } 10% { opacity: 1; } 35% { -webkit-transform: translateY(-800%) rotate(270deg); transform: translateY(-800%) rotate(270deg); } 80% { opacity: 1; } 100% { opacity: 0; -webkit-transform: translateY(2000%) rotate(1440deg); transform: translateY(2000%) rotate(1440deg); } } @keyframes confetti { 0% { opacity: 0; -webkit-transform: translateY(0%) rotate(0deg); transform: translateY(0%) rotate(0deg); } 10% { opacity: 1; } 35% { -webkit-transform: translateY(-800%) rotate(270deg); transform: translateY(-800%) rotate(270deg); } 80% { opacity: 1; } 100% { opacity: 0; -webkit-transform: translateY(2000%) rotate(1440deg); transform: translateY(2000%) rotate(1440deg); } } function confetti() { $.each($(\".particletext.confetti\"), function(){ var confetticount = ($(this).width()/50)*10; for(var i = 0; i .particle { position: absolute; background-color: rgba(253, 216, 53, 0.5); -webkit-animation: sunbeams 3s linear infinite; animation: sunbeams 3s linear infinite; } @-webkit-keyframes sunbeams { 0% { -webkit-transform: translateY(40%) rotate(0deg); transform: translateY(40%) rotate(0deg); } 50% { -webkit-transform: translateY(-40%) rotate(180deg); transform: translateY(-40%) rotate(180deg); } 100% { -webkit-transform: translateY(40%) rotate(360deg); transform: translateY(40%) rotate(360deg); } 0%,14%,17%,43%,53%,71%,80%,94%,100% { opacity: 0; } 6%,15%,24%,28%,48%,55%,78%,82%,99% { opacity: 1; } } @keyframes sunbeams { 0% { -webkit-transform: translateY(40%) rotate(0deg); transform: translateY(40%) rotate(0deg); } 50% { -webkit-transform: translateY(-40%) rotate(180deg); transform: translateY(-40%) rotate(180deg); } 100% { -webkit-transform: translateY(40%) rotate(360deg); transform: translateY(40%) rotate(360deg); } 0%,14%,17%,43%,53%,71%,80%,94%,100% { opacity: 0; } 6%,15%,24%,28%,48%,55%,78%,82%,99% { opacity: 1; } } function sunbeams() { $.each($(\".particletext.sunbeams\"), function(){ var linecount = ($(this).width()/50)*10; for(var i = 0; i","categories":[{"name":"技能之树","slug":"技能之树","permalink":"https://bingshanyishu.github.io/categories/%E6%8A%80%E8%83%BD%E4%B9%8B%E6%A0%91/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"https://bingshanyishu.github.io/tags/CSS3/"},{"name":"粒子特效","slug":"粒子特效","permalink":"https://bingshanyishu.github.io/tags/%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88/"}],"author":"Sankey"},{"title":"博客搭建，修改基本信息，建立个人风格","slug":"博客搭建，修改基本信息，建立个人风格","date":"2022-01-30T16:00:00.000Z","updated":"2022-03-11T14:42:28.016Z","comments":true,"path":"posts/4b3500a4.html","link":"","permalink":"https://bingshanyishu.github.io/posts/4b3500a4.html","excerpt":"","text":"博客搭建，修改基本信息，建立个人风格 本博客基于Lucky大佬的博客进行优化，改成属于自己的风格，再此感谢大佬的开源，让自己节约大部分调试，以及寻找资料的时间与精力。 Lucky大佬博客：LuckySec (luckyzmj.cn) 开源博客指导文章：LuckyBlog开源搭建教程 | LuckySec (luckyzmj.cn) 博客环境搭建请去浏览[[个人知识树博客搭建一环境的安装与配置]]，可直接右上角点击搜索即可。 1. 设计图标和logo每个网站都有相对于的图标彰显特色与理念，我也想设计出自己的图标，无奈自己不会设计，只能去那些logo网站看看找找灵感 第一个： LOGO设计神器 - logo在线设计生成器，免费在线生成公司logo设计！ (logosc.cn) step1 : 输入logo名称 step2:选择行业 step3:选择色系，我这里我选择冷色系 step4:选择字体 点击生成logo就可以看到很多logo了 挑选所需要的logo 我挑了大半天都没有找到想要的。 我就用另外一个网站在进行设计 YEELOGO_logo在线制作 点击下载，然后在做一些优化，比如去背景，调整大小，logo就做好了。 去背景网站消除图片中的背景 – remove.bg 最后将自己做的logo替换原来的logo， 2. 修改部署平台编辑根目录下的配置文件MyBlog/_config.yml，找到如下内容并修改 deploy: - type: git repo: git@github.com:bingshanyishu/bingshanyishu.github.io.git branch: master 3. 修改网站信息编辑根目录下的配置文件MyBlog/_config.yml，找到如下内容并修改为自己的信息 # Site title: 冰山一树Sankey subtitle: 'Zsの博客' description: '向下以触冰山，向上以触云层，而中以桑基为流，所见即所得！' keywords: '可视化 前端 数据分析 电气' author: Sankey language: zh-CN timezone: '' # URL ## If your site is put in a subdirectory, set url as 'http://example.com/child' and root as '/child/' url: https://bingshanyishu.github.io/ root: / # permalink: :year/:month/:day/:title/ permalink: posts/:abbrlink.html # p 是自定义的前缀 abbrlink: alg: crc32 #算法： crc16(default) and crc32 rep: hex #进制： dec(default) and hex permalink_defaults: pretty_urls: trailing_index: true # Set to false to remove trailing 'index.html' from permalinks trailing_html: true # Set to false to remove trailing '.html' from permalinks 4. 修改博客头像编辑主题目录下的配置文件MyBlog/themes/hexo-theme-matery/_config.yml，找到如下内容并修改,也可直接替换主题文件下的source中的favicon.png和medias中的logo.png # Configure website favicon and LOGO # 将以下改为自己的头像链接即可 favicon: https://s1.ax1x.com/2020/05/17/YR20js.jpg logo: https://s1.ax1x.com/2020/05/17/YRWsYT.png #如果是替换主题文件中内容·： # 配置网站favicon和网站LOGO favicon: /favicon.png logo: /medias/logo.png 5. 修改留言板简介演示效果如下： 编辑 /MyBlog/contact/index.md，修改为如下信息 --- title: contact date: 2019-10-25 00:00:00 type: \"contact\" layout: \"contact\" --- ## 畅所欲言 --- 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ ## 友链 --- Zsの友链信息 博客名称: 冰山一树Sankey 博客网址: https://bingshanyishu.github.io 博客介绍: 向下以触冰山，向上以触云层，而中以桑基为流，所见即所得！ 6. 修改音乐列表想要修改自己喜欢的音乐之前，需要先获取音乐列表的id。 登录网易云音乐网页版，找到自己喜欢的歌单，上面的ID对应修改 server： netease——&gt;网易云音乐 tencent——&gt;QQ音乐 kugou——&gt;酷狗音乐 编辑主题目录下的配置文件MyBlog/themes/hexo-theme-matery/_config.yml，找到如下内容并修改 # Whether to display the musics. # 是否在首页显示音乐. music: enable: true title: #非吸底模式有效 enable: true show: 听听音乐 autoHide: true # hide automaticaly server: netease #require music platform: netease, tencent, kugou, xiami, baidu type: playlist #require song, playlist, album, search, artist id: 7262197380 #require song id / playlist id / album id / search keyword fixed: true # 开启吸底模式 autoplay: false # 是否自动播放 theme: '#42b983' loop: 'all' # 音频循环播放, 可选值: 'all', 'one', 'none' order: 'random' # 音频循环顺序, 可选值: 'list', 'random' preload: 'auto' # 预加载，可选值: 'none', 'metadata', 'auto' volume: 0.7 # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效 listFolded: true # 列表默认折叠 hideLrc: true # 隐藏歌词 # Whether to display the musics. # 单独的音乐页面. musics: enable: true title: #非吸底模式有效 enable: true show: 听听音乐 server: netease #require music platform: netease, tencent, kugou, xiami, baidu type: playlist #require song, playlist, album, search, artist id: 7262197380 #require song id / playlist id / album id / search keyword fixed: false # 开启吸底模式 autoplay: true # 是否自动播放 theme: '#42b983' loop: 'all' # 音频循环播放, 可选值: 'all', 'one', 'none' order: 'random' # 音频循环顺序, 可选值: 'list', 'random' preload: 'auto' # 预加载，可选值: 'none', 'metadata', 'auto' volume: 0.7 # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效 listFolded: false # 列表默认折叠 listMaxHeight: \"525px\" #列表最大高度 7. 绑定 Valine 评论可参考Valine：一款基于Leancloud的无后端评论系统 - 简书 (jianshu.com) 先注册leancloud账号，官网 valine官网快速开始 | Valine 一款快速、简洁且高效的无后端评论系统。，进去点击注册可进入leancount官网 注册后（这里挺简单，按步骤直接注册就行） 然后实名认证加验证邮箱 然后回到leancloud主页，应用名称随便，选择开发板即可 然后点击应用，设置，应用凭证，即可看到自己的AppID和AppKey 编辑主题目录下的配置文件MyBlog/themes/hexo-theme-matery/_config.yml，找到如下内容并修改 # Valine 评论模块的配置，默认为不激活，如要使用，就请激活该配置项，并设置 appId 和 appKey. valine: enable: true appId: Ucrxxxxxxxxxxxxxxxx-xxxxsz # 自行注册valine获取 appKey: zPsLxxxxxxxxxxxxxxerLmd # 自行注册valine获取 notify: true verify: true visitor: true avatar: 'monsterid' # Gravatar style : mm/identicon/monsterid/wavatar/retro/hide pageSize: 10 placeholder: '留下你的足迹..' # Comment Box placeholder background: /medias/comment_bg.png count: true enableQQ: 16463223 # 改为自己的QQ号 recordIP: true requiredFields: - nick - mail guest_info: - nick - mail - link master: - 46606772953bed0812789d6dc955614e # md5加密后的博主邮箱 metaPlaceholder: # 输入框的背景文字 nick: 昵称/QQ号(必填) mail: 邮箱(必填) link: 网址(https://) lang: zh-CN tagMeta: # The String Array of Words to show Flag.[Just Only xCss Style mode] - 博主 - 小伙伴 - 访客 friends: # The MD5 String Array of friends Email to show friends Flag.[Just Only xCss Style mode] - cb3e577ff029d6073400d5557effd41f - 之后设计MD5加密邮箱，百度随便搜搜MD5加密就有 放在上面中 master: - 46606772953bed0812789d6dc955614e # md5加密后的博主邮箱 8. 绑定 DaoVoice 在线聊天首先在DaoVoice官网上注册一个账号。 注册成功后，第一次登录，会弹出一个窗口，填完相关信息后。点击应用设置，点击安装到网站，然后就可以找到我们需要的appid了。 编辑主题目录下的配置文件MyBlog/themes/hexo-theme-matery/_config.yml，找到如下内容并修改 daovoice: enable: true app_id: 4xxxxxxxe #DaoVoice中的app_id 小tips：点击应用设置，聊天设置可自行设计图标显示样式 ， 9. 快捷导航页面个性化编辑文件MyBlog/source/tools/index.html，以下简单标记出几处，还有其他涉及到博客信息的内容都需要改为你自己的博客信息即可。 10. 添加友情链接编辑文件MyBlog/suorce/_data/friends.json，按如下格式添加友情 [ { \"avatar\": \"https://s1.ax1x.com/2020/05/17/YRWsYT.png\", \"name\": \"Luckey\", \"introduction\": \"越努力，越幸运\", \"url\": \"http://www.luckyzmj.cn\", \"title\": \"访问主页\" },{ \"avatar\": \"https://sunhwee.com/hwsun.jpg\", \"name\": \"洪卫の博客\", \"introduction\": \"UESTC CVer\", \"url\": \"http://sunhwee.com\", \"title\": \"访问主页\" } ] 11. 添加相册比如你的图片上传图床后，链接地址如下 https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/galleries/璀璨星空/01.jpg https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/galleries/璀璨星空/02.jpg https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/galleries/动漫风景/01.jpg https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/galleries/动漫风景/02.jpg ... 首先提取出图片链接公共的部分，作为图床地址 https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/galleries/ 然后再提取图片地址中不同的部分，作为图片地址 璀璨星空/01.jpg 璀璨星空/02.jpg 动漫风景/01.jpg 动漫风景/03.jpg ... 具体怎么分割根据你自己图床的链接格式而定，以上为我的github图床格式为例。 将相册图床的地址改为你自己的图床地址，需要更改两处文件 # 例如我的图床地址为： https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/galleries/ themes/hexo-theme-matery/layout/galleries.ejs themes/hexo-theme-matery/layout/gallerie.ejs 为每个相册添加链接地址，在根目录/source/List/galleries/下新建 相册名称 文件夹，并在该文件夹下新建 index.md 最后，在根目录/source/_data/galleries.json中添加图片链接，格式如下, [ { \"name\": \"璀璨星空\", \"cover\": \"璀璨星空/01.jpg\", \"description\": \"璀璨星空\", \"photos\": [ \"璀璨星空/01.jpg\", \"璀璨星空/02.jpg\", \"璀璨星空/03.jpg\", \"璀璨星空/04.jpg\", \"璀璨星空/05.jpg\", \"璀璨星空/06.jpg\", \"璀璨星空/07.jpg\", \"璀璨星空/08.jpg\", \"璀璨星空/09.jpg\", \"璀璨星空/10.jpg\", \"璀璨星空/11.jpg\", \"璀璨星空/12.jpg\", \"璀璨星空/13.jpg\", \"璀璨星空/14.jpg\", \"璀璨星空/15.jpg\", \"璀璨星空/16.jpg\" ] }, { \"name\": \"动漫风景\", \"cover\": \"动漫风景/01.jpg\", \"description\": \"动漫风景\", \"photos\": [ \"动漫风景/01.jpg\", \"动漫风景/02.jpg\", \"动漫风景/03.jpg\", \"动漫风景/04.jpg\", \"动漫风景/05.jpg\", \"动漫风景/06.jpg\", \"动漫风景/07.jpg\", \"动漫风景/08.jpg\", \"动漫风景/09.jpg\", \"动漫风景/10.jpg\", \"动漫风景/11.jpg\", \"动漫风景/12.jpg\", \"动漫风景/13.jpg\", \"动漫风景/14.jpg\", \"动漫风景/15.jpg\", \"动漫风景/16.jpg\" ] } ] 12. 站点统计功能站点统计的数据来源于百度统计,当你的网站被百度收录后就会在百度统计中出现数据，具体效果如下： 由于博客的统计页面数据不能直接从百度站点中调用，因此需要自行从百度站点中将相应数据填入博客站点统计页面的源代码文件中，个人建议每隔一个月手动更新一次数据。 打开MyBlog\\themes\\hexo-theme-matery\\layout\\census.ejs文件，将百度统计中的数据填入源代码中，修改代码如下： 13. 仿Windows个性化仿Windows页面是采用YLUI实现的，YLUI提供了社区版本供大家学习使用，具体效果如下： 这里我选择关闭了 大家可以查看YLUI官方的开发文档进行开发，有不懂的可以加官方的QQ群：191372634 进行讨论。 14. 博客特色背景图无文章特色背景图： 打开主题配置文件MyBlog\\themes\\hexo-theme-matery\\_config.yml，修改替换如下代码即可： # The post featured images that needs to be displayed when there is no image. # 无文章特色图片时需要显示的文章特色图片. featureImages: - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/1.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/2.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/3.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/4.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/5.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/6.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/7.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/8.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/9.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/10.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/11.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/12.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/13.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/14.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/15.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/16.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/17.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/18.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/19.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/20.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/21.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/22.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/23.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/24.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/25.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/26.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/27.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/28.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/29.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/30.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/31.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/32.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/33.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/34.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/35.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/36.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/37.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/38.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/39.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/40.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/41.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/42.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/43.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/44.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/45.jpg - https://cdn.jsdelivr.net/gh/bingshanyishu/HexoBlog@main/imagesBlog/posts/46.jpg 15. 新增社交链接由于默认的链接没有b站，CSDN等，这里添加自定义 在主题的 _config.yml 文件中，默认支持 QQ、GitHub 和邮箱的配置，可以在主题文件的 /layout/_partial/social-link.ejs 文件中，新增、修改你需要的社交链接地址 将下面需要添加的链接代码放到该文件的最后面，如果每个可放在rss之前 添加csdn链接 &lt;% if (theme.socialLink.csdn) { %&gt; &lt;a href=\"https://www.csdn.net/&lt;%= theme.socialLink.csdn %&gt;\" class=\"tooltipped\" target=\"_blank\" data-tooltip=\"访问我的CSDN主页\" data-position=\"top\" data-delay=\"50\"&gt; &lt;i class=\"fa fa-codiepie\"&gt;&lt;/i&gt; &lt;/a&gt; &lt;% } %&gt; 添加b站链接 &lt;% if (theme.socialLink.bilibili) { %&gt; &lt;a href=\"&lt;%= theme.socialLink.bilibili %&gt;\" class=\"tooltipped\" target=\"_blank\" data-tooltip=\"访问我的bilibili主页\" data-position=\"top\" data-delay=\"50\"&gt; &lt;i class=\"fab fa-codiepie\"&gt;&lt;/i&gt; &lt;/a&gt; &lt;% } %&gt; 社交图标可去这个网站中查找：图标库 – Font Awesome 中文网，但是没有csdn和b站链接，可找相似的来替代。 但注意：使用font awesome图标版本也需要对应，不然无法显示。这里版本为5.11.0 然后在_config.yml中的socialLink: 加对应即可，awesome图标可去这些博客了解 Font Awesome5.x 页面引入的几种方式和应用,及与4.x的变化 Font Awesome，一套绝佳的图标字体库和CSS框架 (dashgame.com) socialLink: csdn: https://blog.csdn.net/m0_59464010?spm=1000.2115.3001.5343 //改成自己的 bilibili: https://bilibili.com/484432829?from=search&amp;seid=1051383716784056202 //改成自己的 16.勿渲染自定义页面hexo在生成页面后会自动渲染所有的html页面，但是有时候有一些自定义页面采用自己渲染的代码，如果再加上hexo的渲染，会引起混乱。为此我们可以定义让hexo不要渲染我们自己的页面。 font matter方法将代码直接写到index.md中，然后再Front matter 中添加 layout: false title: tools date: 2020-04-28 00:00:00 type: \"tools\" layout: false --- skip render方法在博客根目录下的 _config.yml，找到 skip_render # 指定目录跳过hexo渲染 skip_render: - 'tools/*' - 'tools/**' 注：tools/* 表示在目录 source/fireworks 下的文件全部跳过渲染，tools/** 表示在博客根目录 source/tools/ 文件夹下的文件全部跳过渲染（例如页面的 js、css 在另一个文件夹中） 例：webstackwebstack是一个纯静态的网址导航网站，内容均由viggo收集并整理。项目基于bootstrap前端框架开发。 Github：https://github.com/WebStackPage/WebStackPage.github.io 在博客根目录 source/下新建tools，然后新建index.html,将webstack网页源码全选复制粘贴到里面。 然后打开博客根目录下配置文件_config.yml，找到skip_render，做如下修改： skip_render: - 'tools/*' - 'tools/**'","categories":[{"name":"项目之树","slug":"项目之树","permalink":"https://bingshanyishu.github.io/categories/%E9%A1%B9%E7%9B%AE%E4%B9%8B%E6%A0%91/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"https://bingshanyishu.github.io/tags/Blog/"}],"author":"Sankey"}],"categories":[{"name":"技能之树","slug":"技能之树","permalink":"https://bingshanyishu.github.io/categories/%E6%8A%80%E8%83%BD%E4%B9%8B%E6%A0%91/"},{"name":"项目之树","slug":"项目之树","permalink":"https://bingshanyishu.github.io/categories/%E9%A1%B9%E7%9B%AE%E4%B9%8B%E6%A0%91/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://bingshanyishu.github.io/tags/Ajax/"},{"name":"前端","slug":"前端","permalink":"https://bingshanyishu.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"CSS3","slug":"CSS3","permalink":"https://bingshanyishu.github.io/tags/CSS3/"},{"name":"CSS","slug":"CSS","permalink":"https://bingshanyishu.github.io/tags/CSS/"},{"name":"布局","slug":"布局","permalink":"https://bingshanyishu.github.io/tags/%E5%B8%83%E5%B1%80/"},{"name":"HTML","slug":"HTML","permalink":"https://bingshanyishu.github.io/tags/HTML/"},{"name":"爬虫","slug":"爬虫","permalink":"https://bingshanyishu.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"scrapy","slug":"scrapy","permalink":"https://bingshanyishu.github.io/tags/scrapy/"},{"name":"selenium","slug":"selenium","permalink":"https://bingshanyishu.github.io/tags/selenium/"},{"name":"python","slug":"python","permalink":"https://bingshanyishu.github.io/tags/python/"},{"name":"pdf","slug":"pdf","permalink":"https://bingshanyishu.github.io/tags/pdf/"},{"name":"博客","slug":"博客","permalink":"https://bingshanyishu.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Tableau学习","slug":"Tableau学习","permalink":"https://bingshanyishu.github.io/tags/Tableau%E5%AD%A6%E4%B9%A0/"},{"name":"Tableau绘图","slug":"Tableau绘图","permalink":"https://bingshanyishu.github.io/tags/Tableau%E7%BB%98%E5%9B%BE/"},{"name":"Blog","slug":"Blog","permalink":"https://bingshanyishu.github.io/tags/Blog/"},{"name":"Blog问题","slug":"Blog问题","permalink":"https://bingshanyishu.github.io/tags/Blog%E9%97%AE%E9%A2%98/"},{"name":"粒子特效","slug":"粒子特效","permalink":"https://bingshanyishu.github.io/tags/%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88/"}]}